{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"IP",
				"IPV6_V6ONLY"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "   â“‚â€‚â€ƒ_POSIX_C_SOURCEâ€ƒâ€¦â€ƒâ€”â€ƒmacro object\n   â“‚â€‚â€ƒ_GNU_SOURCEâ€ƒâ€¦â€ƒâ€”â€ƒmacro object\nâ€”â’¸â€“â€ƒportâ€ƒ{â€‰â€¦â€‰}â€‰;â€ƒâ€”â€ƒtype\n   â“‰â€‚â€ƒport_tâ€‰;â€ƒâ€”â€ƒtypedef\nâ€”â’¸â€“â€ƒlinkâ€ƒ{â€‰â€¦â€‰}â€‰;â€ƒâ€”â€ƒtype\n   â“‰â€‚â€ƒlink_tâ€‰;â€ƒâ€”â€ƒtypedef\nâ€”â’»â€“â€ƒdir_entriesâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction\nâ€”â’»â€“â€ƒfind_portâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction\nâ€”â’»â€“â€ƒremove_portâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction\nâ€”â’»â€“â€ƒclear_portsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction\nâ€”â’»â€“â€ƒget_portsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction\nâ€”â’»â€“â€ƒserial_portsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction\nâ€”â’»â€“â€ƒserial_readâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction\nâ€”â’»â€“â€ƒterm_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction\nâ€”â’»â€“â€ƒterm_restoreâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction\nâ€”â’»â€“â€ƒprocess_serialâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction\nâ€”â“‚â€“â€ƒmaxâ€‰(â€‰)â€ƒâ€¦â€ƒâ€”â€ƒmacro function\nâ€”â’»â€“â€ƒprocess_loopâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction\nâ€”â’»â€“â€ƒusageâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction\nâ€”â’»â€“â€ƒsignal_handlerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction\nâ€”â’»â€“â€ƒmainâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
			"settings":
			{
				"buffer_size": 710,
				"line_ending": "Unix",
				"name": "ðŒ† Outline",
				"scratch": true
			}
		},
		{
			"file": "lib/io/io_wantread.c",
			"settings":
			{
				"buffer_size": 2936,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "logserial.c",
			"settings":
			{
				"buffer_size": 16701,
				"line_ending": "Unix"
			}
		},
		{
			"file": "genmakefile.h",
			"settings":
			{
				"buffer_size": 7835,
				"line_ending": "Unix"
			}
		},
		{
			"file": "genmakefile.c",
			"settings":
			{
				"buffer_size": 144523,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "lib/path.h",
			"settings":
			{
				"buffer_size": 2612,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 2657 files for \"int3\" (regex, case sensitive)\n\n/home/roman/Sources/c-utils/lib/binfmt.h:\n    4  #include \"typedefs.h\"\n    5  #include \"uint8.h\"\n    6: #include \"uint32.h\"\n    7  #include \"uint64.h\"\n    8  #include \"range.h\"\n    .\n   23    uint64 offs;\n   24    uint64 size;\n   25:   uint32 flags;\n   26  } binfmt_entry;\n   27  \n\n/home/roman/Sources/c-utils/lib/coff.h:\n    8  #include \"uint8.h\"\n    9  #include \"uint16.h\"\n   10: #include \"uint32.h\"\n   11  #include \"range.h\"\n   12  \n   ..\n   14    uint16 machine; /* machine_type */\n   15    uint16 number_of_sections;\n   16:   uint32 time_date_stamp;\n   17:   uint32 pointer_to_symbol_table;\n   18:   uint32 number_of_symbols;\n   19    uint16 size_of_optional_header;\n   20    uint16 characteristics; /* image_characteristics */\n   ..\n   76    char name[COFF_SECTION_NAME_SIZE]; /* TODO: Should we use char instead? */\n   77    union {\n   78:     uint32 physical_address; /* same value as next field */\n   79:     uint32 virtual_size;\n   80    };\n   81:   uint32 virtual_address;\n   82:   uint32 size_of_raw_data;\n   83:   uint32 pointer_to_raw_data;\n   84:   uint32 pointer_to_relocations; /* always zero in executables */\n   85:   uint32 pointer_to_linenumbers; /* deprecated */\n   86    uint16 number_of_relocations;\n   87    uint16 number_of_linenumbers; /* deprecated */\n   88:   uint32 characteristics;       /* section_characteristics */\n   89  }\n   90  coff_section_header;\n   ..\n  101    uint8 major_linker_version;\n  102    uint8 minor_linker_version;\n  103:   uint32 size_of_code;\n  104:   uint32 size_of_initialized_data;\n  105:   uint32 size_of_uninitialized_data;\n  106:   uint32 address_of_entry_point;\n  107:   uint32 base_of_code;\n  108:   uint32 base_of_data;\n  109  }\n  110  coff_opt_header;\n  ...\n  112  typedef struct __unaligned {\n  113    uint16 magic;\n  114:   uint32 vstamp; /* version of the compiler assembler */\n  115:   uint32 proc_type;\n  116:   uint32 rom_width_bits;\n  117:   uint32 ram_width_bits;\n  118  }\n  119  coff_opt_header_microchip;\n  ...\n  124  typedef struct __unaligned {\n  125    union {\n  126:     uint32 fname; // function name symbol table index, if Line == 0\n  127:     uint32 addr;  // section-relative address of code that corresponds to line\n  128    };\n  129    uint16 line; // line number\n  ...\n  141        char name[COFF_E_SYMNMLEN]; /* Symbol name (first 8 characters) */\n  142        struct {\n  143:         uint32 zeroes; /* Leading zeros */\n  144:         uint32 offset; /* Offset if this is a header section */\n  145        };\n  146      };\n  147  \n  148:     uint32 value; /* Value (address) of the segment */\n  149      uint16 scnum; /* Section number */\n  150      uint16 type;  /* Type of section */\n  ...\n  156    // Function definition\n  157    struct __unaligned {\n  158:     uint32 tag_index;                // Index to .bf entry\n  159:     uint32 code_size;                // Size of function code\n  160:     uint32 pointer_to_line_number;   // Pointer to line number entry\n  161:     uint32 pointer_to_next_function; // Symbol table index of next function\n  162      uint16 x_tvndx;                  // Unused\n  163    }\n  ...\n  166    // .bf abd .ef\n  167    struct __unaligned {\n  168:     uint32 unused1;\n  169      uint16 source_line_number; // Line number in source file\n  170      uint16 unused2;\n  171:     uint32 unused3;                  // Pointer to line number entry\n  172:     uint32 pointer_to_next_function; // Symbol table index of next function\n  173      uint16 unused4;                  // Unused\n  174    }\n  ...\n  177    // Weak external\n  178    struct __unaligned {\n  179:     uint32 tag_index;       // Symbol table index of alternative symbol2\n  180:     uint32 characteristics; //\n  181:     uint32 unused1;\n  182:     uint32 unused2;\n  183      uint16 unused3; // Unused\n  184    }\n  ...\n  193    // String table index\n  194    struct {         // MS COFF uses multiple aux records rather than a string table entry!\n  195:     uint32 zeroes; // zeroes if name file name longer than 18\n  196:     uint32 offset; // string table entry\n  197    } stringindex;\n  198  \n  199    // Section definition\n  200    struct __unaligned {\n  201:     uint32 length;\n  202      uint16 number_of_relocations; // Line number in source file\n  203      uint16 number_of_line_numbers;\n  204:     uint32 check_sum; // Pointer to line number entry\n  205      uint16 number;    // Symbol table index of next function\n  206      uint8 selection;  // Unused\n  ...\n  218      char name[COFF_SSYMBOL_NAME_MAX]; /* symbol name if less than 8 characters */\n  219      struct __unaligned {\n  220:       uint32 zeroes; /* first four characters are 0 */\n  221:       uint32 offset; /* pointer to the string table */\n  222      };\n  223    };\n  224  \n  225:   uint32 value; /* symbol value */\n  226    int16 scnum;  /* section number */\n  227:   uint32 type;  /* type */\n  228    int8 sclass;  /* storage class */\n  229    uint8 numaux; /* number of auxiliary symbols */\n  ...\n  282  \n  283  coff_section_header* coff_get_section(void*, uint16 index);\n  284: const char* coff_get_strtab(void*, uint32* szptr);\n  285: coff_symtab_entry* coff_get_symtab(void*, uint32* num);\n  286  coff_file_header* coff_header_file(void*);\n  287  coff_opt_header* coff_header_opt(void*);\n\n/home/roman/Sources/c-utils/lib/coff/coff_get_strtab.c:\n    2  \n    3  const char*\n    4: coff_get_strtab(void* coff, uint32* szptr) {\n    5    range syms = coff_symbol_table(coff);\n    6:   uint32 size = uint32_get(syms.end);\n    7    if(szptr)\n    8      *szptr = size;\n\n/home/roman/Sources/c-utils/lib/coff/coff_get_symtab.c:\n    2  \n    3  coff_symtab_entry*\n    4: coff_get_symtab(void* coff, uint32* num) {\n    5    coff_file_header* fhdr = coff_header_file(coff);\n    6  \n    7    if(num) {\n    8:     *num = uint32_get(&fhdr->number_of_symbols);\n    9    }\n   10:   return (coff_symtab_entry*)((char*)coff + uint32_get(&fhdr->pointer_to_symbol_table));\n   11  }\n   12  \n\n/home/roman/Sources/c-utils/lib/coff/coff_line_numbers.c:\n    5    range r;\n    6  \n    7:   r.start = (char*)coff + uint32_get(&shdr->pointer_to_linenumbers);\n    8    r.elem_size = 6;\n    9    r.end = r.start + r.elem_size * uint16_get(&shdr->number_of_linenumbers);\n\n/home/roman/Sources/c-utils/lib/coff/coff_symbol_table.c:\n    7    range r;\n    8  \n    9:   r.start = (char*)coff + uint32_get(&fhdr->pointer_to_symbol_table);\n   10    r.elem_size = fhdr->machine == COFF_FILE_MACHINE_MICROCHIP_V2 ? 20 : 18;\n   11:   r.end = r.start + r.elem_size * uint32_get(&fhdr->number_of_symbols);\n   12  \n   13    return r;\n\n/home/roman/Sources/c-utils/lib/dns/dns_random.c:\n    3  #include \"../dns.h\"\n    4  #include \"../taia.h\"\n    5: #include \"../uint32.h\"\n    6  \n    7  #if WINDOWS_NATIVE\n    .\n   13  #endif\n   14  \n   15: static uint32 seed[32];\n   16: static uint32 in[12];\n   17: static uint32 out[8];\n   18  static int outleft = 0;\n   19  \n   ..\n   23  static void\n   24  surf(void) {\n   25:   uint32 t[12];\n   26:   uint32 x;\n   27:   uint32 sum = 0;\n   28    int r;\n   29    int i;\n   ..\n   50    char tpack[16];\n   51  \n   52:   for(i = 0; i < 32; ++i) uint32_unpack(data + 4 * i, seed + i);\n   53  \n   54    taia_now(&t);\n   55    taia_pack(tpack, &t);\n   56:   for(i = 0; i < 4; ++i) uint32_unpack(tpack + 4 * i, in + 4 + i);\n   57  \n   58  #if WINDOWS_NATIVE\n\n/home/roman/Sources/c-utils/lib/elf.h:\n    4  #include \"uint8.h\"\n    5  #include \"uint16.h\"\n    6: #include \"uint32.h\"\n    7  #include \"uint64.h\"\n    8  #include \"range.h\"\n    .\n   24    uint16 e_type;                /* Object file type */\n   25    uint16 e_machine;             /* Architecture */\n   26:   uint32 e_version;             /* Object file version */\n   27:   uint32 e_entry;               /* Entry point virtual address */\n   28:   uint32 e_phoff;               /* Program header table file offset */\n   29:   uint32 e_shoff;               /* Section header table file offset */\n   30:   uint32 e_flags;               /* Processor-specific flags */\n   31    uint16 e_ehsize;              /* ELF header size in bytes */\n   32    uint16 e_phentsize;           /* Program header table entry size */\n   ..\n   42    uint16 e_type;                /* Object file type */\n   43    uint16 e_machine;             /* Architecture */\n   44:   uint32 e_version;             /* Object file version */\n   45    uint64 e_entry;               /* Entry point virtual address */\n   46    uint64 e_phoff;               /* Program header table file offset */\n   47    uint64 e_shoff;               /* Section header table file offset */\n   48:   uint32 e_flags;               /* Processor-specific flags */\n   49    uint16 e_ehsize;              /* ELF header size in bytes */\n   50    uint16 e_phentsize;           /* Program header table entry size */\n   ..\n  218  \n  219  typedef struct {\n  220:   uint32 sh_name;      /* Section name (string tbl index) */\n  221:   uint32 sh_type;      /* Section type */\n  222:   uint32 sh_flags;     /* Section flags */\n  223:   uint32 sh_addr;      /* Section virtual addr at execution */\n  224:   uint32 sh_offset;    /* Section file offset */\n  225:   uint32 sh_size;      /* Section size in bytes */\n  226:   uint32 sh_link;      /* Link to another section */\n  227:   uint32 sh_info;      /* Additional section information */\n  228:   uint32 sh_addralign; /* Section alignment */\n  229:   uint32 sh_entsize;   /* Entry size if section holds table */\n  230  } elf32_shdr;\n  231  \n  232  typedef struct {\n  233:   uint32 sh_name;      /* Section name (string tbl index) */\n  234:   uint32 sh_type;      /* Section type */\n  235    uint64 sh_flags;     /* Section flags */\n  236    uint64 sh_addr;      /* Section virtual addr at execution */\n  237    uint64 sh_offset;    /* Section file offset */\n  238    uint64 sh_size;      /* Section size in bytes */\n  239:   uint32 sh_link;      /* Link to another section */\n  240:   uint32 sh_info;      /* Additional section information */\n  241    uint64 sh_addralign; /* Section alignment */\n  242    uint64 sh_entsize;   /* Entry size if section holds table */\n  ...\n  314  \n  315  typedef struct __unaligned {\n  316:   uint32 st_name;  /* Symbol name (string tbl index) */\n  317:   uint32 st_value; /* Symbol value */\n  318:   uint32 st_size;  /* Symbol size */\n  319    uint8 st_info;   /* Symbol type and binding */\n  320    uint8 st_other;  /* Symbol visibility */\n  ...\n  324  \n  325  typedef struct __unaligned {\n  326:   uint32 st_name;  /* Symbol name (string tbl index) */\n  327    uint8 st_info;   /* Symbol type and binding */\n  328    uint8 st_other;  /* Symbol visibility */\n  ...\n  422  \n  423  typedef struct {\n  424:   uint32 r_offset; /* Address */\n  425:   uint32 r_info;   /* Relocation type and symbol index */\n  426  } elf32_rel;\n  427  \n  ...\n  439  \n  440  typedef struct {\n  441:   uint32 r_offset; /* Address */\n  442:   uint32 r_info;   /* Relocation type and symbol index */\n  443:   int32 r_addend;  /* Addend */\n  444  } elf32_rela;\n  445  \n  ...\n  463  \n  464  typedef struct {\n  465:   uint32 p_type;   /* Segment type */\n  466:   uint32 p_offset; /* Segment file offset */\n  467:   uint32 p_vaddr;  /* Segment virtual address */\n  468:   uint32 p_paddr;  /* Segment physical address */\n  469:   uint32 p_filesz; /* Segment size in file */\n  470:   uint32 p_memsz;  /* Segment size in memory */\n  471:   uint32 p_flags;  /* Segment flags */\n  472:   uint32 p_align;  /* Segment alignment */\n  473  } elf32_phdr;\n  474  \n  475  typedef struct {\n  476:   uint32 p_type;   /* Segment type */\n  477:   uint32 p_flags;  /* Segment flags */\n  478    uint64 p_offset; /* Segment file offset */\n  479    uint64 p_vaddr;  /* Segment virtual address */\n  ...\n  562  \n  563  typedef struct {\n  564:   int32 d_tag; /* Dynamic entry type */\n  565    union {\n  566:     uint32 d_val; /* Integer value */\n  567:     uint32 d_ptr; /* Address value */\n  568    } d_un;\n  569  } elf32_dyn;\n  ...\n  679  #define ELF_DT_AUXILIARY 0x7ffffffd /* Shared object to load before self */\n  680  #define ELF_DT_FILTER 0x7fffffff    /* Shared object to get values from */\n  681: #define ELF_DT_EXTRATAGIDX(tag) ((uint32) - ((int32)(tag) << 1 >> 1) - 1)\n  682  #define ELF_DT_EXTRANUM 3\n  683  \n  ...\n  724    uint16 vd_ndx;     /* Version Index */\n  725    uint16 vd_cnt;     /* Number of associated aux entries */\n  726:   uint32 vd_hash;    /* Version name hash value */\n  727:   uint32 vd_aux;     /* Offset in bytes to verdaux array */\n  728:   uint32 vd_next;    /* Offset in bytes to next verdef\n  729                  entry */\n  730  }\n  ...\n  736    uint16 vd_ndx;     /* Version Index */\n  737    uint16 vd_cnt;     /* Number of associated aux entries */\n  738:   uint32 vd_hash;    /* Version name hash value */\n  739:   uint32 vd_aux;     /* Offset in bytes to verdaux array */\n  740:   uint32 vd_next;    /* Offset in bytes to next verdef\n  741                  entry */\n  742  }\n  ...\n  761  \n  762  typedef struct {\n  763:   uint32 vda_name; /* Version or dependency names */\n  764:   uint32 vda_next; /* Offset in bytes to next verdaux\n  765                entry */\n  766  } elf32_verdaux;\n  767  \n  768  typedef struct {\n  769:   uint32 vda_name; /* Version or dependency names */\n  770:   uint32 vda_next; /* Offset in bytes to next verdaux\n  771                entry */\n  772  } elf64_verdaux;\n  ...\n  777    uint16 vn_version; /* Version of structure */\n  778    uint16 vn_cnt;     /* Number of associated aux entries */\n  779:   uint32 vn_file;    /* Offset of filename for this\n  780                  dependency */\n  781:   uint32 vn_aux;     /* Offset in bytes to vernaux array */\n  782:   uint32 vn_next;    /* Offset in bytes to next verneed\n  783                  entry */\n  784  }\n  ...\n  788    uint16 vn_version; /* Version of structure */\n  789    uint16 vn_cnt;     /* Number of associated aux entries */\n  790:   uint32 vn_file;    /* Offset of filename for this\n  791                  dependency */\n  792:   uint32 vn_aux;     /* Offset in bytes to vernaux array */\n  793:   uint32 vn_next;    /* Offset in bytes to next verneed\n  794                  entry */\n  795  }\n  ...\n  804  \n  805  typedef struct __unaligned {\n  806:   uint32 vna_hash;  /* Hash value of dependency name */\n  807    uint16 vna_flags; /* Dependency specific information */\n  808    uint16 vna_other; /* Unused */\n  809:   uint32 vna_name;  /* Dependency name string offset */\n  810:   uint32 vna_next;  /* Offset in bytes to next vernaux\n  811                 entry */\n  812  }\n  ...\n  814  \n  815  typedef struct __unaligned {\n  816:   uint32 vna_hash;  /* Hash value of dependency name */\n  817    uint16 vna_flags; /* Dependency specific information */\n  818    uint16 vna_other; /* Unused */\n  819:   uint32 vna_name;  /* Dependency name string offset */\n  820:   uint32 vna_next;  /* Offset in bytes to next vernaux\n  821                 entry */\n  822  }\n  ...\n  836  \n  837  typedef struct {\n  838:   int32 a_type; /* Entry type */\n  839    union {\n  840      long int a_val;      /* Integer value */\n  ...\n  908  \n  909  typedef struct {\n  910:   uint32 n_namesz; /* Length of the note's name.  */\n  911:   uint32 n_descsz; /* Length of the note's descriptor.  */\n  912:   uint32 n_type;   /* Type of the note.  */\n  913  } elf32_nhdr;\n  914  \n  915  typedef struct {\n  916:   uint32 n_namesz; /* Length of the note's name.  */\n  917:   uint32 n_descsz; /* Length of the note's descriptor.  */\n  918:   uint32 n_type;   /* Type of the note.  */\n  919  } elf64_nhdr;\n  920  \n  ...\n  952  typedef struct __unaligned {\n  953    uint64 m_value;   /* Symbol value.  */\n  954:   uint32 m_info;    /* Size and index.  */\n  955:   uint32 m_poffset; /* Symbol offset.  */\n  956    uint16 m_repeat;  /* Repeat count.  */\n  957    uint16 m_stride;  /* Stride info.  */\n  ...\n 1033  typedef union {\n 1034    struct {\n 1035:     uint32 gt_current_g_value; /* -G value used for compilation */\n 1036:     uint32 gt_unused;          /* Not used */\n 1037    } gt_header;                 /* First entry in section */\n 1038    struct {\n 1039:     uint32 gt_g_value; /* If this value were used for -G */\n 1040:     uint32 gt_bytes;   /* This many bytes would be used */\n 1041    } gt_entry;          /* Subsequent entries in section */\n 1042  } elf32_gptab;\n ....\n 1045  \n 1046  typedef struct {\n 1047:   uint32 ri_gprmask;    /* General registers used */\n 1048:   uint32 ri_cprmask[4]; /* Coprocessor registers used */\n 1049:   int32 ri_gp_value;    /* $gp register value */\n 1050  } elf32_reg_info;\n 1051  \n ....\n 1058    uint16 section; /* Section header index of section affected,\n 1059                0 for global options.  */\n 1060:   uint32 info;    /* Kind-specific information.  */\n 1061  }\n 1062  elf_options;\n ....\n 1104  \n 1105  typedef struct {\n 1106:   uint32 hwp_flags1; /* Extra flags.  */\n 1107:   uint32 hwp_flags2; /* Extra flags.  */\n 1108  } elf_options_hw;\n 1109  \n ....\n 1116  \n 1117  typedef struct {\n 1118:   uint32 l_name;       /* Name (string table index) */\n 1119:   uint32 l_time_stamp; /* Timestamp */\n 1120:   uint32 l_checksum;   /* Checksum */\n 1121:   uint32 l_version;    /* Interface version */\n 1122:   uint32 l_flags;      /* Flags */\n 1123  } elf32_lib;\n 1124  \n 1125  typedef struct {\n 1126:   uint32 l_name;       /* Name (string table index) */\n 1127:   uint32 l_time_stamp; /* Timestamp */\n 1128:   uint32 l_checksum;   /* Checksum */\n 1129:   uint32 l_version;    /* Interface version */\n 1130:   uint32 l_flags;      /* Flags */\n 1131  } elf64_lib;\n 1132  \n ....\n 1143  /* Entries found in sections of type ELF_SHT_MIPS_CONFLICT.  */\n 1144  \n 1145: typedef uint32 elf32_conflict;\n 1146  \n 1147  /* ARM specific declarations */\n ....\n 1268  int elf_section_find(void*, const char* sname);\n 1269  range elf_section_headers(void*);\n 1270: int elf_section_index(void*, uint32 sh_type);\n 1271  const char* elf_section_name(void*, int sn);\n 1272  void* elf_section_offset(void*, int sn);\n 1273  size_t elf_section_size(void*, int sn);\n 1274: const char* elf_section_typename(uint32);\n 1275  range elf_section(void*, void* shdr);\n 1276  const char* elf_shstrtab(void*);\n\n/home/roman/Sources/c-utils/lib/elf/elf_get_value.c:\n   17    switch(size) {\n   18      case 8: ret = uint64_read((const char*)&p[off]); break;\n   19:     case 4: ret = uint32_read((const char*)&p[off]); break;\n   20      case 2: ret = uint16_read((const char*)&p[off]); break;\n   21      case 1: ret = p[off]; break;\n\n/home/roman/Sources/c-utils/lib/elf/elf_section_find.c:\n    7    range r = elf_section_headers(elf);\n    8    void* section;\n    9:   uint32 i = 0;\n   10  \n   11    range_foreach(&r, section) {\n   12:     uint32 name = ELF_GET(elf, section, shdr, sh_name);\n   13  \n   14      if(str_equal(sname, &(elf_shstrtab(elf)[name])))\n\n/home/roman/Sources/c-utils/lib/elf/elf_section_index.c:\n    3  \n    4  int\n    5: elf_section_index(void* elf, uint32 sh_type) {\n    6    range r = elf_section_headers(elf);\n    7    void* section;\n    8:   uint32 i = 0;\n    9  \n   10    range_foreach(&r, section) {\n   11:     uint32 type = uint32_get(ELF_ADDR(elf, section, shdr, sh_type));\n   12  \n   13      if(type == sh_type)\n\n/home/roman/Sources/c-utils/lib/elf/elf_section_name.c:\n    4  elf_section_name(void* elf, int sn) {\n    5    range r = elf_section_headers(elf);\n    6:   uint32 idx = ELF_GET(elf, range_index(&r, sn), shdr, sh_name);\n    7    const char* name = &(elf_shstrtab(elf)[idx]);\n    8    return name;\n\n/home/roman/Sources/c-utils/lib/elf/elf_section_typename.c:\n    2  \n    3  const char*\n    4: elf_section_typename(uint32 sh_type) {\n    5    static const char* const types[] = {\"<0>\",\n    6                                        \"PROGBITS\",\n\n/home/roman/Sources/c-utils/lib/entities.h:\n    1: #include \"uint32.h\"\n    2  #include \"uint8.h\"\n    3  \n    4  const struct {\n    5:   uint32 tab[9854];\n    6    uint8 data[8115];\n    7  } entities = {\n\n/home/roman/Sources/c-utils/lib/fmt.h:\n    4  \n    5  #include \"typedefs.h\"\n    6: #include \"uint32.h\"\n    7  #include \"uint64.h\"\n    8  \n    .\n   93  #define FMT_ASN1TAG 19    /* enough space to hold 2^128 - 1 */\n   94  /* some variable length encodings for integers */\n   95: size_t fmt_utf8(char* dest, uint32 n);          /* can store 0 - 0x7fffffff */\n   96  size_t fmt_asn1derlength(char* dest, uint64 l); /* 0 - 0x7f: 1 byte, above that 1 + bytes_needed bytes */\n   97  size_t fmt_asn1dertag(char* dest, uint64 l);    /* 1 byte for each 7 bits; upper bit = more bytes coming */\n   ..\n  144  \n  145  #ifdef UINT32_H\n  146: size_t fmt_escapecharc(char* dest, uint32 ch);\n  147  \n  148: size_t fmt_escapecharshell(char* dest, uint32 ch);\n  149: size_t fmt_escapecharquotedshell(char*, uint32 ch);\n  150: size_t fmt_escapecharjson(char* dest, uint32 ch, char quote);\n  151  #endif\n  152  \n\n/home/roman/Sources/c-utils/lib/fmt/fmt_escapecharc.c:\n    1  #include \"../fmt.h\"\n    2: #include \"../uint32.h\"\n    3  #include <sys/types.h>\n    4  \n    .\n   13  \n   14  size_t\n   15: fmt_escapecharc(char* dest, uint32 ch) {\n   16    char c;\n   17    if(ch > 0xff)\n\n/home/roman/Sources/c-utils/lib/fmt/fmt_escapecharjson.c:\n    1  #include \"../fmt.h\"\n    2  #include \"../uint16.h\"\n    3: #include \"../uint32.h\"\n    4  \n    5  static void\n    .\n   15  \n   16  size_t\n   17: fmt_escapecharjson(char* dest, uint32 ch, char quote) {\n   18    size_t n;\n   19  \n   ..\n   21      quote = '\"';\n   22  \n   23:   if(ch != (uint32)(unsigned)quote) {\n   24      if(ch == '\\'' || ch == '\"') {\n   25        dest[0] = ch;\n\n/home/roman/Sources/c-utils/lib/fmt/fmt_escapecharquotedshell.c:\n    1  #include \"../fmt.h\"\n    2: #include \"../uint32.h\"\n    3  #include <sys/types.h>\n    4  \n    5  size_t\n    6: fmt_escapecharquotedshell(char* dest, uint32 ch) {\n    7    char c;\n    8    switch(ch) {\n\n/home/roman/Sources/c-utils/lib/fmt/fmt_escapecharshell.c:\n    1  #include \"../fmt.h\"\n    2: #include \"../uint32.h\"\n    3  #include <sys/types.h>\n    4  \n    .\n    6  \n    7  size_t\n    8: fmt_escapecharshell(char* dest, uint32 ch) {\n    9    char c;\n   10    if(ch > 0xff)\n\n/home/roman/Sources/c-utils/lib/fmt/fmt_utf8.c:\n    2  \n    3  size_t\n    4: fmt_utf8(char* dest, uint32 n) {\n    5    size_t i, j;\n    6    if(n <= 0x7f) {\n\n/home/roman/Sources/c-utils/lib/http.h:\n    3  \n    4  #include \"uint16.h\"\n    5: #include \"uint32.h\"\n    6  #include \"uint64.h\"\n    7  #include \"stralloc.h\"\n    .\n   19  \n   20  typedef struct http_request_s {\n   21:   uint32 serial;\n   22    http_req_t type;\n   23    stralloc location;\n\n/home/roman/Sources/c-utils/lib/http/http_get.c:\n   23    char ip[FMT_IP4];\n   24    stralloc dns;\n   25:   uint32 serial = 0;\n   26    size_t len = str_len(location);\n   27    h->tls = len >= 5 && !byte_diff(location, 5, \"https\");\n\n/home/roman/Sources/c-utils/lib/ihex.h:\n    4  #include \"uint8.h\"\n    5  #include \"uint16.h\"\n    6: #include \"uint32.h\"\n    7  #include \"slist.h\"\n    8  \n    .\n   26  ssize_t ihex_load_buf(ihex_file* ihf, const char* in, size_t n);\n   27  ssize_t ihex_load_record(ihex_record** pihr, const char* in, size_t n);\n   28: size_t ihex_read_at(ihex_file* ihf, uint32 at, char* x, size_t n);\n   29  ssize_t ihex_read_record(ihex_record** pihr, const char* in, size_t n);\n   30: ihex_record* ihex_record_at(ihex_file* ihf, uint32 at, uint32* roffs);\n   31  \n   32  #endif /* IHEX_H_ */\n\n/home/roman/Sources/c-utils/lib/ihex/ihex_read_at.c:\n    1  #include \"../ihex.h\"\n    2  #include \"../slist.h\"\n    3: #include \"../uint32.h\"\n    4  #include \"../byte.h\"\n    5  \n    6  size_t\n    7: ihex_read_at(ihex_file* ihf, uint32 at, char* x, size_t n) {\n    8    ihex_record* rec;\n    9    char* start = x;\n   10    union {\n   11:     uint32 off32;\n   12      struct {\n   13        uint16 lo16;\n   ..\n   17  \n   18    if((rec = ihex_record_at(ihf, at, &o.off32))) {\n   19:     uint32 p = at - o.off32;\n   20:     uint32 end;\n   21  \n   22      while(rec && n > 0) {\n\n/home/roman/Sources/c-utils/lib/ihex/ihex_record_at.c:\n    1  #include \"../ihex.h\"\n    2  #include \"../slist.h\"\n    3: #include \"../uint32.h\"\n    4  \n    5  ihex_record*\n    6: ihex_record_at(ihex_file* ihf, uint32 at, uint32* roffs) {\n    7    union {\n    8      ihex_record* rec;\n    .\n   10    } it;\n   11    union {\n   12:     uint32 off32;\n   13      struct {\n   14        uint16 lo16;\n\n/home/roman/Sources/c-utils/lib/io/io_passfd.c:\n   43  struct cmsghdr {\n   44    size_t cmsg_len;    /* data byte count, including hdr */\n   45:   int32_t cmsg_level; /* originating protocol */\n   46:   int32_t cmsg_type;  /* protocol-specific type */\n   47  };\n   48  #endif\n\n/home/roman/Sources/c-utils/lib/ip4.h:\n    7  #include \"uint8.h\"\n    8  #include \"uint16.h\"\n    9: #include \"uint32.h\"\n   10  \n   11  #ifdef __cplusplus\n   ..\n   17    /** 32-bit IPv4 address, represented as 4 8-bit \\c unsigned \\c chars. */\n   18    uint8 addr[4];\n   19:   uint32 iaddr;\n   20  } ipv4addr;\n   21  /** IPv4 port number. */\n\n/home/roman/Sources/c-utils/lib/ip6.h:\n    4  \n    5  #include \"byte.h\"\n    6: #include \"uint32.h\"\n    7  \n    8  #ifdef __cplusplus\n    .\n   14  size_t fmt_ip6c(char* dest, const char* ip);\n   15  \n   16: size_t scan_ip6if(const char* src, char* ip, uint32* scope_id);\n   17: size_t fmt_ip6if(char* dest, const char* ip, uint32 scope_id);\n   18: size_t fmt_ip6ifc(char* dest, const char* ip, uint32 scope_id);\n   19  \n   20  size_t scan_ip6_flat(const char* src, char*);\n\n/home/roman/Sources/c-utils/lib/macho.h:\n    4  #include \"uint8.h\"\n    5  #include \"uint16.h\"\n    6: #include \"uint32.h\"\n    7  #include \"uint64.h\"\n    8  \n    .\n  356  \n  357  typedef struct macho_fat_header {\n  358:   uint32 magic;\n  359:   uint32 nfat_arch;\n  360  } macho_fat_header;\n  361  \n  ...\n  363    cpu_type_t cputype;\n  364    cpu_subtype_t cpusubtype;\n  365:   uint32 offset;\n  366:   uint32 size;\n  367:   uint32 align;\n  368  } macho_fat_arch;\n  369  \n  370  typedef struct macho_mach_header_magic {\n  371:   uint32 magic;\n  372  } macho_mach_header_magic;\n  373  \n  374  typedef struct macho_mach_header {\n  375:   uint32 magic;\n  376    cpu_type_t cputype;\n  377    cpu_subtype_t cpusubtype;\n  378:   uint32 filetype;\n  379:   uint32 ncmds;\n  380:   uint32 sizeofcmds;\n  381:   uint32 flags;\n  382  } macho_mach_header;\n  383  \n  384  typedef struct macho_mach_header_64 {\n  385:   uint32 magic;             /* mach magic number identifier */\n  386    cpu_type_t cputype;       /* cpu specifier */\n  387    cpu_subtype_t cpusubtype; /* machine specifier */\n  388:   uint32 filetype;          /* type of file */\n  389:   uint32 ncmds;             /* number of load commands */\n  390:   uint32 sizeofcmds;        /* the size of all the load commands */\n  391:   uint32 flags;             /* flags */\n  392:   uint32 reserved;          /* reserved */\n  393  } macho_mach_header_64;\n  394  \n  395  typedef struct macho_load_command {\n  396:   uint32 cmd;\n  397:   uint32 cmdsize;\n  398  } macho_load_command;\n  399  \n  400  typedef struct macho_segment_command {\n  401:   uint32 cmd;\n  402:   uint32 cmdsize;\n  403    char segname[16];\n  404:   uint32 vmaddr;\n  405:   uint32 vmsize;\n  406:   uint32 fileoff;\n  407:   uint32 filesize;\n  408    vm_prot_t maxprot;\n  409    vm_prot_t initprot;\n  410:   uint32 nsects;\n  411:   uint32 flags;\n  412  } macho_segment_command;\n  413  \n  414  typedef struct macho_segment_command_64 { /* for 64-bit architectures */\n  415:   uint32 cmd;                             /* LC_SEGMENT_64 */\n  416:   uint32 cmdsize;                         /* includes sizeof macho_section_64 structs */\n  417    char segname[16];                       /* segment name */\n  418    uint64 vmaddr;                          /* memory address of this segment */\n  ...\n  422    vm_prot_t maxprot;                      /* maximum VM protection */\n  423    vm_prot_t initprot;                     /* initial VM protection */\n  424:   uint32 nsects;                          /* number of sections in segment */\n  425:   uint32 flags;                           /* flags */\n  426  } macho_segment_command_64;\n  427  \n  ...\n  429    char sectname[16];\n  430    char segname[16];\n  431:   uint32 addr;\n  432:   uint32 size;\n  433:   uint32 offset;\n  434:   uint32 align;\n  435:   uint32 reloff;\n  436:   uint32 nreloc;\n  437:   uint32 flags;\n  438:   uint32 reserved1;\n  439:   uint32 reserved2;\n  440  } macho_section;\n  441  \n  ...\n  445    uint64 addr;                    /* memory address of this macho_section */\n  446    uint64 size;                    /* size in bytes of this macho_section */\n  447:   uint32 offset;                  /* file offset of this macho_section */\n  448:   uint32 align;                   /* macho_section alignment (power of 2) */\n  449:   uint32 reloff;                  /* file offset of relocation entries */\n  450:   uint32 nreloc;                  /* number of relocation entries */\n  451:   uint32 flags;                   /* flags (macho_section type and attributes)*/\n  452:   uint32 reserved1;               /* reserved (for offset or index) */\n  453:   uint32 reserved2;               /* reserved (for count or sizeof) */\n  454:   uint32 reserved3;               /* reserved */\n  455  } macho_section_64;\n  456  \n  457  union lc_str {\n  458:   uint32 offset;\n  459  #ifndef __LP64__\n  460    char* ptr;\n  ...\n  463  \n  464  typedef struct macho_symtab_command {\n  465:   uint32 cmd;\n  466:   uint32 cmdsize;\n  467:   uint32 symoff;\n  468:   uint32 nsyms;\n  469:   uint32 stroff;\n  470:   uint32 strsize;\n  471  } macho_symtab_command;\n  472  \n  473  typedef struct macho_dylib {\n  474    union lc_str name;\n  475:   uint32 timestamp;\n  476:   uint32 current_version;\n  477:   uint32 compatibility_version;\n  478  } macho_dylib;\n  479  \n  480  typedef struct macho_dylib_command {\n  481:   uint32 cmd;\n  482:   uint32 cmdsize;\n  483    macho_dylib dylib;\n  484  } macho_dylib_command;\n  485  \n  486  typedef struct macho_dylinker_command {\n  487:   uint32 cmd;\n  488:   uint32 cmdsize;\n  489    union lc_str name;\n  490  } macho_dylinker_command;\n  491  \n  492  typedef struct macho_dysymtab_command {\n  493:   uint32 cmd;\n  494:   uint32 cmdsize;\n  495:   uint32 ilocalsym;\n  496:   uint32 nlocalsym;\n  497:   uint32 iextdefsym;\n  498:   uint32 nextdefsym;\n  499:   uint32 iundefsym;\n  500:   uint32 nundefsym;\n  501:   uint32 tocoff;\n  502:   uint32 ntoc;\n  503:   uint32 modtaboff;\n  504:   uint32 nmodtab;\n  505:   uint32 extrefsymoff;\n  506:   uint32 nextrefsyms;\n  507:   uint32 indirectsymoff;\n  508:   uint32 nindirectsyms;\n  509:   uint32 extreloff;\n  510:   uint32 nextrel;\n  511:   uint32 locreloff;\n  512:   uint32 nlocrel;\n  513  } macho_dysymtab_command;\n  514  \n  515  typedef struct macho_dylib_table_of_contents {\n  516:   uint32 symbol_index;\n  517:   uint32 module_index;\n  518  } macho_dylib_table_of_contents;\n  519  \n  520  typedef struct macho_dylib_module {\n  521:   uint32 module_name;\n  522:   uint32 iextdefsym;\n  523:   uint32 nextdefsym;\n  524:   uint32 irefsym;\n  525:   uint32 nrefsym;\n  526:   uint32 ilocalsym;\n  527:   uint32 nlocalsym;\n  528:   uint32 iextrel;\n  529:   uint32 nextrel;\n  530:   uint32 iinit_iterm;\n  531:   uint32 ninit_nterm;\n  532:   uint32 objc_module_info_addr;\n  533:   uint32 objc_module_info_size;\n  534  } macho_dylib_module;\n  535  \n  536  typedef struct macho_twolevel_hints_command {\n  537:   uint32 cmd;\n  538:   uint32 cmdsize;\n  539:   uint32 offset;\n  540:   uint32 nhints;\n  541  } macho_twolevel_hints_command;\n  542  \n  543  typedef struct macho_nlist {\n  544:   uint32 n_strx;\n  545    uint8 n_type;\n  546    uint8 n_sect;\n\n/home/roman/Sources/c-utils/lib/open/open_temp.c:\n    4  #include \"../open.h\"\n    5  #include \"../str.h\"\n    6: #include \"../uint32.h\"\n    7  \n    8  #if WINDOWS_NATIVE\n    .\n   68  \n   69    for(;;) {\n   70:     random = uint32_random();\n   71  \n   72      for(i = 0; i < 6; ++i) {\n\n/home/roman/Sources/c-utils/lib/pe.h:\n    4  #include \"typedefs.h\"\n    5  #include \"uint64.h\"\n    6: #include \"uint32.h\"\n    7  #include \"uint16.h\"\n    8  #include \"uint8.h\"\n    .\n   13  \n   14  typedef struct {\n   15:   uint32 virtual_address;\n   16:   uint32 size;\n   17  } pe_data_directory;\n   18  \n   19  typedef struct __unaligned {\n   20:   uint32 characteristics;     /**< 0x00 */\n   21:   uint32 time_date_stamp;     /**< 0x04 */\n   22    uint16 major_version;       /**< 0x08 */\n   23    uint16 minor_version;       /**< 0x0a */\n   24:   uint32 name;                /**< 0x0c */\n   25:   uint32 base;                /**< 0x10 */\n   26:   uint32 number_of_functions; /**< 0x14 */\n   27:   uint32 number_of_names;     /**< 0x18 */\n   28:   uint32 address_of_functions;\n   29:   uint32 address_of_names;\n   30:   uint32 address_of_name_ordinals;\n   31  }\n   32  pe_export_directory;\n   33  \n   34  typedef struct __unaligned {\n   35:   uint32 characteristics;\n   36:   uint32 time_date_stamp;\n   37    uint16 major_version;\n   38    uint16 minor_version;\n   ..\n   44    union {\n   45      struct {\n   46:       uint32 name_offset : 31;\n   47:       uint32 name_is_string : 1;\n   48      };\n   49:     uint32 name;\n   50      uint16 id;\n   51    };\n   52    union {\n   53:     uint32 offset_to_data;\n   54      struct {\n   55:       uint32 offset_to_directory : 31;\n   56:       uint32 data_is_directory : 1;\n   57      };\n   58    };\n   ..\n   73  \n   74  typedef struct __unaligned {\n   75:   uint32 offset_to_data;\n   76:   uint32 size;\n   77:   uint32 code_page;\n   78:   uint32 reserved;\n   79  }\n   80  pe_resource_data_entry;\n   81  \n   82  typedef struct __unaligned {\n   83:   uint32 size;\n   84:   uint32 time_date_stamp;\n   85    uint16 major_version;\n   86    uint16 minor_version;\n   87:   uint32 global_flags_clear;\n   88:   uint32 global_flags_set;\n   89:   uint32 critical_section_default_timeout;\n   90:   uint32 de_commit_free_block_threshold;\n   91:   uint32 de_commit_total_free_threshold;\n   92:   uint32 lock_prefix_table;\n   93:   uint32 maximum_allocation_size;\n   94:   uint32 virtual_memory_threshold;\n   95:   uint32 process_heap_flags;\n   96:   uint32 process_affinity_mask;\n   97    uint16 csd_version;\n   98    uint16 reserved1;\n   99:   uint32 edit_list;\n  100:   uint32 security_cookie;\n  101:   uint32 se_handler_table;\n  102:   uint32 se_handler_count;\n  103  }\n  104  pe32_load_config_directory;\n  105  \n  106  typedef struct __unaligned {\n  107:   uint32 size;\n  108:   uint32 time_date_stamp;\n  109    uint16 major_version;\n  110    uint16 minor_version;\n  111:   uint32 global_flags_clear;\n  112:   uint32 global_flags_set;\n  113:   uint32 critical_section_default_timeout;\n  114    uint64 de_commit_free_block_threshold;\n  115    uint64 de_commit_total_free_threshold;\n  ...\n  118    uint64 virtual_memory_threshold;\n  119    uint64 process_affinity_mask;\n  120:   uint32 process_heap_flags;\n  121    uint16 csd_version;\n  122    uint16 reserved1;\n  ...\n  129  \n  130  typedef struct __unaligned {\n  131:   uint32 characteristics;\n  132:   uint32 time_date_stamp;\n  133    uint16 major_version;\n  134    uint16 minor_version;\n  ...\n  139  \n  140  typedef struct __unaligned {\n  141:   uint32 characteristics;\n  142:   uint32 time_date_stamp;\n  143    uint16 major_version;\n  144    uint16 minor_version;\n  145:   uint32 type;\n  146:   uint32 size_of_data;\n  147:   uint32 address_of_raw_data;\n  148:   uint32 pointer_to_raw_data;\n  149  }\n  150  pe_debug_directory;\n  ...\n  155    uint64 address_of_index;\n  156    uint64 address_of_call_backs;\n  157:   uint32 size_of_zero_fill;\n  158:   uint32 characteristics;\n  159  }\n  160  pe64_tls_directory;\n  161  \n  162  typedef struct __unaligned {\n  163:   uint32 start_address_of_raw_data;\n  164:   uint32 end_address_of_raw_data;\n  165:   uint32 address_of_index;\n  166:   uint32 address_of_call_backs;\n  167:   uint32 size_of_zero_fill;\n  168:   uint32 characteristics;\n  169  }\n  170  pe32_tls_directory;\n  ...\n  172  typedef struct {\n  173    union {\n  174:     uint32 characteristics;\n  175:     uint32 original_first_thunk;\n  176    };\n  177:   uint32 time_date_stamp;\n  178:   uint32 forwarder_chain;\n  179:   uint32 name;\n  180:   uint32 first_thunk;\n  181  } pe_import_descriptor;\n  182  \n  ...\n  188  typedef struct {\n  189    union {\n  190:     uint32 all_attributes;\n  191      struct {\n  192        int rva_based : 1;\n  ...\n  194      };\n  195    } attributes;\n  196:   uint32 dll_name_rva;\n  197:   uint32 module_handle_rva;\n  198:   uint32 import_address_table_rva;\n  199:   uint32 import_name_table_rva;\n  200:   uint32 bound_import_address_table_rva;\n  201:   uint32 unload_information_table_rva;\n  202:   uint32 time_date_stamp;\n  203  } pe_delayload_descriptor;\n  204  \n  ...\n  222    uint16 e_oeminfo;\n  223    uint16 e_res2[10];\n  224:   uint32 e_lfanew; /* sizeof(image_dos_h_eader) + size of MS-DOS stub */\n  225  }\n  226  pe_dos_header;\n  ...\n  229    uint16 machine; /* machine_type */\n  230    uint16 number_of_sections;\n  231:   uint32 time_date_stamp;\n  232:   uint32 pointer_to_symbol_table;\n  233:   uint32 number_of_symbols;\n  234    uint16 size_of_optional_header;\n  235    uint16 characteristics; /* image_characteristics */\n  ...\n  242    char name[PE_SECTION_NAME_SIZE]; /* TODO: Should we use char instead? */\n  243    union {\n  244:     uint32 physical_address; /* same value as next field */\n  245:     uint32 virtual_size;\n  246    };\n  247:   uint32 virtual_address;\n  248:   uint32 size_of_raw_data;\n  249:   uint32 pointer_to_raw_data;\n  250:   uint32 pointer_to_relocations; /* always zero in executables */\n  251:   uint32 pointer_to_linenumbers; /* deprecated */\n  252    uint16 number_of_relocations;\n  253    uint16 number_of_linenumbers; /* deprecated */\n  254:   uint32 characteristics;       /* section_characteristics */\n  255  }\n  256  pe_section_header;\n  ...\n  294    unsigned char major_linker_version;\n  295    unsigned char minor_linker_version;\n  296:   uint32 size_of_code;\n  297:   uint32 size_of_initialized_data;\n  298:   uint32 size_of_uninitialized_data;\n  299:   uint32 address_of_entry_point;\n  300:   uint32 base_of_code;\n  301:   uint32 base_of_data; /* only in PE32 */\n  302:   uint32 image_base;\n  303:   uint32 section_alignment;\n  304:   uint32 file_alignment;\n  305    uint16 major_operating_system_version;\n  306    uint16 minor_operating_system_version;\n  ...\n  309    uint16 major_subsystem_version;\n  310    uint16 minor_subsystem_version;\n  311:   uint32 reserved1;\n  312:   uint32 size_of_image;\n  313:   uint32 size_of_headers;\n  314:   uint32 checksum;\n  315    uint16 subsystem; /* windows_subsystem */\n  316    uint16 dll_characteristics;\n  317:   uint32 size_of_stack_reserve;\n  318:   uint32 size_of_stack_commit;\n  319:   uint32 size_of_heap_reserve;\n  320:   uint32 size_of_heap_commit;\n  321:   uint32 loader_flags;\n  322:   uint32 number_of_rva_and_sizes;\n  323    pe_data_directory data_directory[PE_NUMBEROF_DIRECTORY_ENTRIES];\n  324  }\n  ...\n  329    unsigned char major_linker_version;\n  330    unsigned char minor_linker_version;\n  331:   uint32 size_of_code;\n  332:   uint32 size_of_initialized_data;\n  333:   uint32 size_of_uninitialized_data;\n  334:   uint32 address_of_entry_point;\n  335:   uint32 base_of_code;\n  336    uint64 image_base;\n  337:   uint32 section_alignment;\n  338:   uint32 file_alignment;\n  339    uint16 major_operating_system_version;\n  340    uint16 minor_operating_system_version;\n  ...\n  343    uint16 major_subsystem_version;\n  344    uint16 minor_subsystem_version;\n  345:   uint32 reserved1;\n  346:   uint32 size_of_image;\n  347:   uint32 size_of_headers;\n  348:   uint32 checksum;\n  349    uint16 subsystem; /* windows_subsystem */\n  350    uint16 dll_characteristics;\n  ...\n  353    uint64 size_of_heap_reserve;\n  354    uint64 size_of_heap_commit;\n  355:   uint32 loader_flags; /* must be zero */\n  356:   uint32 number_of_rva_and_sizes;\n  357    pe_data_directory data_directory[PE_NUMBEROF_DIRECTORY_ENTRIES];\n  358  }\n  ...\n  361  typedef struct __unaligned {\n  362    pe_dos_header dos_hdr;\n  363:   uint32 signature;\n  364    pe_coff_header* coff_hdr;\n  365    void* optional_hdr_ptr;\n  366:   uint32 num_directories;\n  367    void* directories_ptr;\n  368    uint16 num_sections;\n  ...\n  417    char name[PE_SIZEOF_SHORT_NAME];\n  418    union {\n  419:     uint32 physical_address;\n  420:     uint32 virtual_size;\n  421    } misc;\n  422:   uint32 virtual_address;\n  423:   uint32 size_of_raw_data;\n  424:   uint32 pointer_to_raw_data;\n  425:   uint32 pointer_to_relocations;\n  426:   uint32 pointer_to_linenumbers;\n  427    uint16 number_of_relocations;\n  428    uint16 number_of_linenumbers;\n  429:   uint32 characteristics;\n  430  }\n  431  section_header;\n  ...\n  442  typedef struct {\n  443    union {\n  444:     uint32 forwarder_string;\n  445:     uint32 function;\n  446:     uint32 ordinal;\n  447:     uint32 address_of_data;\n  448    } u1;\n  449  } pe_thunk_data32;\n  ...\n  451  // typedef struct {\n  452  //  union {\n  453: //    uint32 characteristics;\n  454: //    uint32 original_first_thunk;\n  455  //  };\n  456: //  uint32 time_date_stamp;\n  457  //\n  458: //  uint32 forwarder_chain;\n  459: //  uint32 name;\n  460: //  uint32 first_thunk;\n  461  //} pe_import_descriptor;\n  462  \n  463  typedef struct __unaligned {\n  464:   uint32 signature;\n  465    pe_coff_header coff_header;\n  466    pe64_opt_header optional_header;\n  ...\n  469  \n  470  typedef struct {\n  471:   uint32 signature;\n  472    pe_coff_header coff_header;\n  473    pe32_opt_header optional_header;\n  ...\n  482    uint16 number_of_sections;    /* 0x28 (ULONG) */\n  483    pe_section_header* sections;  /* 0x30 (pe_section_header) */\n  484:   uint32 characteristics;       /* 0x38 (ULONG) */\n  485    char f_system_image;          /* 0x3c (BOOLEAN) */\n  486    char fdos_image;              /* 0x3d (BOOLEAN) */\n  ...\n  558  void* pe_header_nt(void*);\n  559  void* pe_header_opt(void*);\n  560: int pe_rva2section(void* base, uint32 rva);\n  561: int64 pe_rva2offset(void*, uint32 rva);\n  562: void* pe_rva2ptr(void*, uint32 rva);\n  563: uint32 pe_header_sig(void*);\n  564: uint32 pe_offset2rva(uint8*, int64 off);\n  565  uint64 pe_thunk(void*, void* ptr, int64 index);\n  566  pe_coff_header* pe_header_coff(void*);\n  ...\n  572  pe_data_directory* pe_header_datadir(void*);\n  573  pe_section_header* pe_header_sections(void*, uint16* nsections);\n  574: pe_data_directory* pe_get_datadir(void*, uint32* num);\n  575  const char* pe_datadir_name(int);\n  576  char* pe_dllname(uint8*);\n\n/home/roman/Sources/c-utils/lib/pe/pe_dllname.c:\n    7      pe_data_directory* data_dir = &pe_header_datadir(base)[PE_DIRECTORY_ENTRY_EXPORT];\n    8      pe_export_directory* export_dir = pe_rva2ptr(base, data_dir->virtual_address);\n    9:     return pe_rva2ptr(base, uint32_get(&export_dir->name));\n   10    }\n   11    return NULL;\n\n/home/roman/Sources/c-utils/lib/pe/pe_get_datadir.c:\n    2  \n    3  pe_data_directory*\n    4: pe_get_datadir(void* pe, uint32* num) {\n    5    char* opthdr = (char*)pe_header_opt(pe);\n    6  \n    7    if(num)\n    8:     *num = uint32_get(PE_ADDR(pe, opthdr, opt_header, number_of_rva_and_sizes));\n    9  \n   10    return (pe_data_directory*)(opthdr + PE_OFFSET(pe, opt_header, data_directory));\n\n/home/roman/Sources/c-utils/lib/pe/pe_get_value.c:\n   17    switch(size) {\n   18      case 8: ret = uint64_get(&p[off]); break;\n   19:     case 4: ret = uint32_get(&p[off]); break;\n   20      case 2: ret = uint16_get(&p[off]); break;\n   21      case 1: ret = p[off]; break;\n\n/home/roman/Sources/c-utils/lib/pe/pe_header.c:\n    6  pe_header_nt(void* pe) {\n    7    pe_dos_header* dos = (pe_dos_header*)pe;\n    8:   uint32 lfanew;\n    9:   lfanew = uint32_get(&dos->e_lfanew);\n   10    return (unsigned char*)dos + lfanew;\n   11  }\n   12  \n   13: uint32\n   14  pe_header_sig(void* pe) {\n   15:   return *(uint32*)pe_header_nt(pe);\n   16  }\n   17  \n   ..\n   28  pe_coff_header*\n   29  pe_header_coff(void* pe) {\n   30:   uint32* sign = (uint32*)pe_header_nt(pe);\n   31    return (pe_coff_header*)&sign[1];\n   32  }\n\n/home/roman/Sources/c-utils/lib/pe/pe_offset2rva.c:\n    1  #include \"../pe.h\"\n    2: #include \"../uint32.h\"\n    3  \n    4: uint32\n    5  pe_offset2rva(uint8* base, int64 off) {\n    6    uint16 i, n;\n    7    pe_section_header* sections = pe_header_sections(base, &n);\n    8  \n    9:   if((uint32)off < sections[0].pointer_to_raw_data)\n   10      return off;\n   11  \n   12    for(i = 0; i < n; i++) {\n   13:     uint32 start, size;\n   14:     start = uint32_get(&sections[i].pointer_to_raw_data);\n   15:     size = uint32_get(&sections[i].size_of_raw_data);\n   16  \n   17:     if((uint32)off >= start && (uint32)off < start + size)\n   18:       return (uint32)off - start + sections[i].virtual_address;\n   19    }\n   20    return 0;\n\n/home/roman/Sources/c-utils/lib/pe/pe_rva2offset.c:\n    2  \n    3  int64\n    4: pe_rva2offset(void* base, uint32 rva) {\n    5    int i;\n    6    pe_section_header* sections;\n\n/home/roman/Sources/c-utils/lib/pe/pe_rva2ptr.c:\n    2  \n    3  void*\n    4: pe_rva2ptr(void* base, uint32 rva) {\n    5    int64 off = pe_rva2offset(base, rva);\n    6    if(off == -1)\n\n/home/roman/Sources/c-utils/lib/pe/pe_rva2section.c:\n    2  \n    3  int\n    4: pe_rva2section(void* base, uint32 rva) {\n    5    uint16 i, n;\n    6    pe_section_header* sections = pe_header_sections(base, &n);\n    .\n   10  \n   11    for(i = 0; i < n; i++) {\n   12:     uint32 start = sections[i].virtual_address;\n   13:     uint32 end = start + sections[i].size_of_raw_data;\n   14  \n   15      if(rva >= start && rva < end)\n\n/home/roman/Sources/c-utils/lib/pe/pe_thunk.c:\n    6    switch(PE_TYPE(pe)) {\n    7      case PE_MAGIC_PE32: {\n    8:       uint32 u = uint32_get(((uint32*)ptr + index));\n    9        ret = ((uint64)(u & 0x80000000) << 32) | (u & 0x7fffffff);\n   10        break;\n\n/home/roman/Sources/c-utils/lib/playlist.h:\n    6  \n    7  #include \"stralloc.h\"\n    8: #include \"uint32.h\"\n    9  #include \"buffer.h\"\n   10  \n   ..\n   15  struct playlist;\n   16  \n   17: typedef void(playlist_callback)(struct playlist*, stralloc* title, stralloc* path, uint32 len);\n   18  typedef playlist_callback* playlist_callback_ptr;\n   19  \n   ..\n   28    stralloc title;\n   29    stralloc path;\n   30:   uint32 length;\n   31  } playlist_entry;\n   32  \n\n/home/roman/Sources/c-utils/lib/playlist/playlist_pls.c:\n   39        }\n   40        /*\n   41:       uint32 index = 8;\n   42        index += scan_ulong(&line.s[index], &len);\n   43        entry.length = len;\n\n/home/roman/Sources/c-utils/lib/playlist/playlist_xspf.c:\n   12    stralloc tag;\n   13    stralloc title, location;\n   14:   uint32 length;\n   15    playlist* pl;\n   16  } track;\n\n/home/roman/Sources/c-utils/lib/process/process_create.c:\n    8  #include \"../wait.h\"\n    9  #include \"../str.h\"\n   10: #include \"../uint32.h\"\n   11  \n   12  #if WINDOWS_NATIVE\n   ..\n   58  process_create(const char* filename, const char* argv[], fd_t std[3], const char* cwd) {\n   59    fd_t fds[3];\n   60:   int32 pid;\n   61    int status = 0;\n   62  \n\n/home/roman/Sources/c-utils/lib/rangecheck.h:\n    4  \n    5  #include \"typedefs.h\"\n    6: #include \"uint32.h\"\n    7  \n    8  #ifdef __cplusplus\n\n/home/roman/Sources/c-utils/lib/safemult.h:\n    4  \n    5  #include \"uint16.h\"\n    6: #include \"uint32.h\"\n    7  #include \"uint64.h\"\n    8  \n    .\n   32  \n   33  static inline int\n   34: umult32(uint32 a, uint32 b, uint32* c) {\n   35    return !__builtin_mul_overflow(a, b, c);\n   36  }\n   37  static inline int\n   38: imult32(int32 a, int32 b, int32* c) {\n   39    return !__builtin_mul_overflow(a, b, c);\n   40  }\n   ..\n   55  int imult16(int16 a, int16 b, int16* c);\n   56  \n   57: int umult32(uint32 a, uint32 b, uint32* c);\n   58: int imult32(int32 a, int32 b, int32* c);\n   59  \n   60  int umult64(uint64 a, uint64 b, uint64* c);\n\n/home/roman/Sources/c-utils/lib/safemult/imult16.c:\n   15  int\n   16  imult16(int16 a, int16 b, int16* c) {\n   17:   int32 x = (int32)a * b;\n   18    if((int16)x != x)\n   19      return 0;\n\n/home/roman/Sources/c-utils/lib/safemult/imult32.c:\n    4  #if defined(__GNUC__) && (__GNUC__ >= 5)\n    5  \n    6: #include \"../uint32.h\"\n    7  \n    8  int\n    9: imult32(int32 a, int32 b, int32* c) {\n   10    return !__builtin_mul_overflow(a, b, c);\n   11  }\n   ..\n   14  \n   15  int\n   16: imult32(int32 a, int32 b, int32* c) {\n   17    int64 x = (int64)a * b;\n   18:   if((int32)x != x)\n   19      return 0;\n   20    *c = x;\n\n/home/roman/Sources/c-utils/lib/safemult/range_str4inbuf.c:\n    6  int\n    7  range_str4inbuf(const void* buf, size_t len, const void* stringstart) {\n    8:   const uint32* x;\n    9:   const uint32* y;\n   10:   if(!range_ptrinbuf(buf, len, x = (const uint32*)stringstart))\n   11      return 0;\n   12:   y = (const uint32*)((char*)x + len);\n   13    for(; x + 1 <= y && *x; ++x)\n   14      ;\n\n/home/roman/Sources/c-utils/lib/safemult/umult32.c:\n    4  #if defined(__GNUC__) && (__GNUC__ >= 5)\n    5  \n    6: #include \"../uint32.h\"\n    7  #include \"../uint64.h\"\n    8  \n    9  int\n   10: umult32(uint32 a, uint32 b, uint32* c) {\n   11    return !__builtin_mul_overflow(a, b, c);\n   12  }\n   ..\n   15  \n   16  int\n   17: umult32(uint32 a, uint32 b, uint32* c) {\n   18    uint64 x = (uint64)a * b;\n   19    if(x > 0xffffffff)\n\n/home/roman/Sources/c-utils/lib/safemult/umult64.c:\n   51  int\n   52  umult64(uint64 a, uint64 b, uint64* c) {\n   53:   uint32 ahi = a >> 32;\n   54:   uint32 alo = (a & 0xffffffff);\n   55:   uint32 bhi = b >> 32;\n   56:   uint32 blo = (b & 0xffffffff);\n   57  \n   58    // a=ahi*x+alo, b=bhi*x+blo\n\n/home/roman/Sources/c-utils/lib/scan.h:\n    6  #include \"typedefs.h\"\n    7  \n    8: #include \"uint32.h\"\n    9  #include \"uint64.h\"\n   10  \n   ..\n   86  \n   87  /* some variable length encodings for integers */\n   88: size_t scan_utf8(const char* in, size_t len, uint32* n) __pure__;\n   89  size_t scan_asn1derlength(const char* in, size_t len, uint64* n) __pure__;\n   90  size_t scan_asn1dertag(const char* in, size_t len, uint64* n) __pure__;\n   ..\n  108  size_t scan_xmlescape(const char* src, char* dest);\n  109  \n  110: size_t scan_utf8_sem(const char* in, size_t len, uint32* num);\n  111  \n  112  size_t scan_eolskip(const char* s, size_t limit);\n\n/home/roman/Sources/c-utils/lib/scan/scan_pb_type5_fixed32.c:\n    1  #include \"../scan.h\"\n    2: #include \"../uint32.h\"\n    3  \n    4  size_t\n    5: scan_pb_type5_fixed32(const char* in, size_t len, uint32* d) {\n    6    if(len < 4)\n    7      return 0;\n    8:   uint32_unpack(in, d);\n    9    return 4;\n   10  }\n\n/home/roman/Sources/c-utils/lib/scan/scan_utf8_sem.c:\n    2  \n    3  size_t\n    4: scan_utf8_sem(const char* in, size_t len, uint32* num) {\n    5    size_t r = scan_utf8(in, len, num);\n    6    if(r > 0) {\n\n/home/roman/Sources/c-utils/lib/set.h:\n    2  #define SET_H\n    3  \n    4: #include \"uint32.h\"\n    5  \n    6  typedef struct bucket {\n    .\n    8    void* value;\n    9    size_t size;\n   10:   uint32 hash;\n   11  } bucket_t;\n   12  \n   13  typedef struct set {\n   14:   uint32 entries;\n   15:   uint32 overflow;\n   16:   uint32 len;\n   17:   uint32 (*hash_fp)(const void*, size_t);\n   18    bucket_t* array;\n   19  } set_t;\n   ..\n   21  // Iterator Definition\n   22  typedef struct set_iterator {\n   23:   uint32 index;\n   24    const bucket_t* current;\n   25    const set_t* set;\n   ..\n   35  void set_free(set_t*);\n   36  int set_has(const set_t*, const void*, const size_t);\n   37: uint32 set_hashfunc(const void*, size_t);\n   38: void set_init(set_t*, uint32 (*const)(const void*, size_t));\n   39  int set_cat(set_t*, const set_t*);\n   40  \n   ..\n   50  #define set_hash(s, x, len) ((s)->hash_fp((x), (len)))\n   51  \n   52: static inline uint32\n   53  set_size(const set_t* s) {\n   54    return s->entries;\n\n/home/roman/Sources/c-utils/lib/set/set_add.c:\n   45  int\n   46  set_add(set_t* set, const void* val, const size_t size) {\n   47:   uint32 hash, index;\n   48    bucket_t* b;\n   49  \n\n/home/roman/Sources/c-utils/lib/set/set_find.c:\n    5  bucket_t* set_bucket(const set_t* set, const void* val, const size_t size);\n    6  \n    7: uint32 set_index(const set_t* set, const void* val, const size_t size);\n    8  \n    9  bucket_t**\n   10: set_find_bucket(bucket_t** ptr, const void* val, const size_t size, uint32 hash) {\n   11    bucket_t* b;\n   12    while((b = *ptr)) {\n   ..\n   22  set_find(const set_t* set, const void* val, const size_t size) {\n   23    bucket_t** ptr;\n   24:   uint32 hash = set_hash(set, val, size);\n   25    set_iterator_t it;\n   26    it.set = set;\n\n/home/roman/Sources/c-utils/lib/set/set_has.c:\n    2  #include <string.h>\n    3  \n    4: uint32\n    5  set_index(const set_t* set, const void* val, const size_t size) {\n    6:   uint32 hash;\n    7    hash = set_hash(set, val, size);\n    8    return hash & (set->len - 1);\n    .\n   12  set_has(const set_t* set, const void* val, const size_t size) {\n   13    bucket_t* b;\n   14:   uint32 hash, i;\n   15    hash = set_hash(set, val, size);\n   16  \n\n/home/roman/Sources/c-utils/lib/set/set_hashfunc.c:\n    1  #include \"../set.h\"\n    2  \n    3: uint32\n    4  set_hashfunc(const void* x, size_t len) {\n    5    const char* key = x;\n    6    unsigned char c;\n    7    size_t i;\n    8:   uint32 hash = 5381;\n    9  \n   10    for(i = 0; i < len; i++) {\n\n/home/roman/Sources/c-utils/lib/set/set_init.c:\n    6  \n    7  void\n    8: set_init(set_t* set, uint32 (*const hash_fp)(const void*, size_t)) {\n    9  \n   10    assert(set);\n\n/home/roman/Sources/c-utils/lib/set/set_iterator_erase.c:\n    7    set_t* s;\n    8    bucket_t* b;\n    9:   uint32 i;\n   10  \n   11    if(!(b = (bucket_t*)it->current) || !(s = (set_t*)it->set))\n\n/home/roman/Sources/c-utils/lib/set/set_iterator_init.c:\n   11  init_bucket(set_iterator_t* it) {\n   12    bucket_t* b = it->set->array;\n   13:   uint32 index = 0;\n   14    if(!b)\n   15      return 0;\n\n/home/roman/Sources/c-utils/lib/set/set_iterator_next.c:\n    6  set_iterator_next(set_iterator_t* it) {\n    7    const bucket_t* b;\n    8:   uint32 index;\n    9  \n   10    if(!(b = it->current))\n\n/home/roman/Sources/c-utils/lib/socket.h:\n    5  #include \"typedefs.h\"\n    6  #include \"uint16.h\"\n    7: #include \"uint32.h\"\n    8  \n    9  #include <errno.h>\n   ..\n   31  \n   32  int socket_connect4(int s, const char* ip, uint16 port);\n   33: int socket_connect6(int s, const char* ip, uint16 port, uint32 scope_id);\n   34  int socket_connected(int s);\n   35  int socket_bind4(int s, const char* ip, uint16 port);\n   36  int socket_bind4_reuse(int s, const char* ip, uint16 port);\n   37: int socket_bind6(int s, const char* ip, uint16 port, uint32 scope_id);\n   38: int socket_bind6_reuse(int s, const char* ip, uint16 port, uint32 scope_id);\n   39  int socket_listen(int s, unsigned int backlog);\n   40  int socket_accept4(int s, char* ip, uint16* port);\n   41: int socket_accept6(int s, char* ip, uint16* port, uint32* scope_id);\n   42  ssize_t socket_recv4(int s, char* buf, size_t len, char* ip, uint16* port);\n   43: ssize_t socket_recv6(int s, char* buf, size_t len, char* ip, uint16* port, uint32* scope_id);\n   44  ssize_t socket_send4(int s, const char* buf, size_t len, const char* ip, uint16 port);\n   45  ssize_t socket_send4_flag(int s, const char* buf, size_t len, const char* ip, uint16 port, int flags);\n   46: ssize_t socket_send6(int s, const char* buf, size_t len, const char* ip, uint16 port, uint32 scope_id);\n   47: ssize_t socket_send6_flag(int s, const char* buf, size_t len, const char* ip, uint16 port, uint32 scope_id, int flags);\n   48  int socket_local4(int s, char* ip, uint16* port);\n   49: int socket_local6(int s, char* ip, uint16* port, uint32* scope_id);\n   50  int socket_remote4(int s, char* ip, uint16* port);\n   51: int socket_remote6(int s, char* ip, uint16* port, uint32* scope_id);\n   52  \n   53  /* enable sending udp packets to the broadcast address */\n   ..\n   79  void socket_tryreservein(int s, int size);\n   80  \n   81: const char* socket_getifname(uint32 _interface);\n   82: uint32 socket_getifidx(const char* ifname);\n   83  \n   84  extern int noipv6;\n   ..\n   98   * just one step, so we need an API to do it in one step */\n   99  int socket_fastopen_connect4(int s, const char* ip, uint16 port, const char* buf, size_t len);\n  100: int socket_fastopen_connect6(int s, const char* ip, uint16 port, uint32 scope_id, const char* buf, size_t len);\n  101  \n  102  const char* socket_ip6loopback();\n\n/home/roman/Sources/c-utils/lib/socket/fmt_ip6if.c:\n   11  \n   12  size_t\n   13: fmt_ip6if(char* dest, const char* ip, uint32 scope_id) {\n   14    size_t i = fmt_ip6(dest, ip);\n   15    if(scope_id) {\n\n/home/roman/Sources/c-utils/lib/socket/fmt_ip6ifc.c:\n    5  \n    6  size_t\n    7: fmt_ip6ifc(char* s, const char ip[16], uint32 scope_id) {\n    8    if(ip6_isv4mapped(ip))\n    9      return fmt_ip4(s, ip + 12);\n\n/home/roman/Sources/c-utils/lib/socket/scan_ip6if.c:\n   12  \n   13  size_t\n   14: scan_ip6if(const char* src, char* ip, uint32* scope_id) {\n   15    size_t i = scan_ip6(src, ip);\n   16    *scope_id = 0;\n\n/home/roman/Sources/c-utils/lib/socket/socket_accept4.c:\n   75  #endif\n   76    if(ip)\n   77:     *(uint32*)ip = *(uint32*)&si.sin_addr;\n   78    if(port)\n   79      uint16_unpack_big((char*)&si.sin_port, port);\n\n/home/roman/Sources/c-utils/lib/socket/socket_accept6.c:\n    8  \n    9  int\n   10: socket_accept6(int s, char* ip, uint16* port, uint32* scope_id) {\n   11  #ifdef LIBC_HAS_IP6\n   12    struct sockaddr_in6 sa;\n\n/home/roman/Sources/c-utils/lib/socket/socket_bind4.c:\n    8  #include \"../byte.h\"\n    9  #include \"../uint16.h\"\n   10: #include \"../uint32.h\"\n   11  \n   12  int\n   ..\n   17    uint16_pack_big((char*)&si.sin_port, port);\n   18    if(ip)\n   19:     *(uint32*)&si.sin_addr = *(uint32*)ip;\n   20    else\n   21      si.sin_addr.s_addr = INADDR_ANY;\n\n/home/roman/Sources/c-utils/lib/socket/socket_bind6.c:\n   12  \n   13  int\n   14: socket_bind6(int s, const char* ip, uint16 port, uint32 scope_id) {\n   15  #ifdef LIBC_HAS_IP6\n   16    struct sockaddr_in6 sa;\n\n/home/roman/Sources/c-utils/lib/socket/socket_bind6_reuse.c:\n    9  \n   10  int\n   11: socket_bind6_reuse(int s, const char* ip, uint16 port, uint32 scope_id) {\n   12    int one = 1;\n   13    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (void*)&one, sizeof one);\n\n/home/roman/Sources/c-utils/lib/socket/socket_connect4.c:\n    8  #include \"../byte.h\"\n    9  #include \"../uint16.h\"\n   10: #include \"../uint32.h\"\n   11  \n   12  #if !WINDOWS_NATIVE\n   ..\n   20    si.sin_family = AF_INET;\n   21    uint16_pack_big((char*)&si.sin_port, port);\n   22:   *((uint32*)&si.sin_addr) = *((uint32*)ip);\n   23    return winsock2errno(connect(s, (struct sockaddr*)&si, sizeof(si)));\n   24  }\n\n/home/roman/Sources/c-utils/lib/socket/socket_connect6.c:\n   11  #include \"../ip6.h\"\n   12  /*#include \"haveip6.h\"*/\n   13: #include \"../uint32.h\"\n   14  #include \"../ip4.h\"\n   15  /*#include \"havescope.h\"*/\n   16  \n   17  int\n   18: socket_connect6(int s, const char ip[16], uint16 port, uint32 scope_id) {\n   19  #ifdef LIBC_HAS_IP6\n   20    struct sockaddr_in6 sa;\n\n/home/roman/Sources/c-utils/lib/socket/socket_fastopen_connect6.c:\n   10  #include <errno.h>\n   11  #include \"../typedefs.h\"\n   12: #include \"../uint32.h\"\n   13  \n   14  int\n   15: socket_fastopen_connect6(int s, const char* ip, uint16 port, uint32 scope_id, const char* buf, size_t len) {\n   16  #ifndef MSG_FASTOPEN\n   17    int r;\n\n/home/roman/Sources/c-utils/lib/socket/socket_getifidx.c:\n   14  \n   15  #if WINDOWS_NATIVE\n   16: static uint32\n   17  if_nametoindex(const char* name) {\n   18  \n   19:   typedef uint32(WINAPI ifn2idx_fn)(const char*);\n   20    static ifn2idx_fn* ifn2idx;\n   21  \n   ..\n   36  #if !defined(__wasi__)\n   37  \n   38: uint32\n   39  socket_getifidx(const char* ifname) {\n   40  #if defined(HAVE_N2I) && !defined(__EMSCRIPTEN__)\n\n/home/roman/Sources/c-utils/lib/socket/socket_getifname.c:\n   21  #if WINDOWS_NATIVE\n   22  static char*\n   23: if_indextoname(uint32 idx, const char* name) {\n   24  \n   25:   typedef char*(WINAPI idx2ifn_fn)(uint32, const char*);\n   26    static idx2ifn_fn* idx2ifn;\n   27  \n   ..\n   43  \n   44  const char*\n   45: socket_getifname(uint32 _interface) {\n   46    char* tmp = if_indextoname(_interface, ifname);\n   47    if(tmp)\n   ..\n   52  #else\n   53  const char*\n   54: socket_getifname(uint32 _interface) {\n   55    return \"[unknown]\";\n   56  }\n\n/home/roman/Sources/c-utils/lib/socket/socket_local4.c:\n   16      return winsock2errno(-1);\n   17    if(ip)\n   18:     *(uint32*)ip = *(uint32*)&si.sin_addr;\n   19    if(port)\n   20      uint16_unpack_big((char*)&si.sin_port, port);\n\n/home/roman/Sources/c-utils/lib/socket/socket_local6.c:\n   10  #include \"../ip6.h\"\n   11  /*#include \"haveip6.h\"*/\n   12: #include \"../uint32.h\"\n   13  /*#include \"havesl.h\"*/\n   14  /*#include \"havescope.h\"*/\n   15  \n   16  int\n   17: socket_local6(int s, char ip[16], uint16* port, uint32* scope_id) {\n   18  #ifdef LIBC_HAS_IP6\n   19    struct sockaddr_in6 si;\n\n/home/roman/Sources/c-utils/lib/socket/socket_recv4.c:\n   17      return winsock2errno(-1);\n   18    if(ip)\n   19:     *(uint32*)ip = *(uint32*)&si.sin_addr;\n   20    if(port)\n   21      uint16_unpack_big((char*)&si.sin_port, port);\n\n/home/roman/Sources/c-utils/lib/socket/socket_recv6.c:\n   14  \n   15  ssize_t\n   16: socket_recv6(int s, char* buf, size_t len, char ip[16], uint16* port, uint32* scope_id) {\n   17  #ifdef LIBC_HAS_IP6\n   18    struct sockaddr_in6 si;\n\n/home/roman/Sources/c-utils/lib/socket/socket_remote4.c:\n   17      return winsock2errno(-1);\n   18    if(ip)\n   19:     *(uint32*)ip = *(uint32*)&si.sin_addr;\n   20    if(port)\n   21      uint16_unpack_big((char*)&si.sin_port, port);\n\n/home/roman/Sources/c-utils/lib/socket/socket_remote6.c:\n   10  #include \"../ip6.h\"\n   11  /*#include \"haveip6.h\"*/\n   12: #include \"../uint32.h\"\n   13  /*#include \"havesl.h\"*/\n   14  /*#include \"havescope.h\"*/\n   15  \n   16  int\n   17: socket_remote6(int s, char ip[16], uint16* port, uint32* scope_id) {\n   18  #ifdef LIBC_HAS_IP6\n   19    struct sockaddr_in6 si;\n\n/home/roman/Sources/c-utils/lib/socket/socket_send4.c:\n   11    si.sin_family = AF_INET;\n   12    uint16_pack_big((char*)&si.sin_port, port);\n   13:   *((uint32*)&si.sin_addr) = *((uint32*)ip);\n   14    return winsock2errno(sendto(s, buf, len, flag, (void*)&si, sizeof si));\n   15  }\n\n/home/roman/Sources/c-utils/lib/socket/socket_send6.c:\n   15  \n   16  ssize_t\n   17: socket_send6_flag(int s, const char* buf, size_t len, const char ip[16], uint16 port, uint32 scope_id, int flag) {\n   18  #ifdef LIBC_HAS_IP6\n   19    struct sockaddr_in6 si;\n   ..\n   50  \n   51  ssize_t\n   52: socket_send6(int s, const char* buf, size_t len, const char ip[16], uint16 port, uint32 scope_id) {\n   53    return socket_send6_flag(s, buf, len, ip, port, scope_id, 0);\n   54  }\n\n/home/roman/Sources/c-utils/lib/taia.h:\n    6  \n    7  #include \"tai.h\"\n    8: #include \"uint32.h\"\n    9  \n   10  #ifdef __cplusplus\n   ..\n   18  typedef struct taia {\n   19    struct tai sec;\n   20:   uint32 nano; /* 0...999999999 */\n   21:   uint32 atto; /* 0...999999999 */\n   22  } tai6464;\n   23  \n\n/home/roman/Sources/c-utils/lib/taia/taia_add.c:\n    9    t->atto = u->atto + v->atto;\n   10    if(t->atto > 999999999UL) {\n   11:     t->atto -= (uint32)1000000000UL;\n   12      ++t->nano;\n   13    }\n   14    if(t->nano > 999999999UL) {\n   15:     t->nano -= (uint32)1000000000UL;\n   16      ++t->sec.x;\n   17    }\n\n/home/roman/Sources/c-utils/lib/taia/taia_half.c:\n    7    t->atto = u->atto >> 1;\n    8    if(u->nano & 1)\n    9:     t->atto += (uint32)500000000UL;\n   10    t->nano = u->nano >> 1;\n   11    if(u->sec.x & 1)\n   12:     t->nano += (uint32)500000000UL;\n   13    t->sec.x = u->sec.x >> 1;\n   14  }\n\n/home/roman/Sources/c-utils/lib/taia/taia_now.c:\n   37    gettimeofday(&now, (struct timezone*)0);\n   38    tai_unix(&t->sec, now.tv_sec);\n   39:   t->nano = (uint32)(1000 * now.tv_usec + 500);\n   40    t->atto = 0;\n   41  #endif\n\n/home/roman/Sources/c-utils/lib/taia/taia_pack.c:\n    4  void\n    5  taia_pack(char* s, const struct taia* t) {\n    6:   uint32 x;\n    7  \n    8    tai_pack(s, &t->sec);\n\n/home/roman/Sources/c-utils/lib/taia/taia_sub.c:\n    5  void\n    6  taia_sub(struct taia* t, const struct taia* u, const struct taia* v) {\n    7:   uint32 unano = u->nano;\n    8:   uint32 uatto = u->atto;\n    9  \n   10    t->sec.x = u->sec.x - v->sec.x;\n   ..\n   12    t->atto = uatto - v->atto;\n   13    if(t->atto > uatto) {\n   14:     t->atto += (uint32)1000000000UL;\n   15      --t->nano;\n   16    }\n   17    if(t->nano > unano) {\n   18:     t->nano += (uint32)1000000000UL;\n   19      --t->sec.x;\n   20    }\n\n/home/roman/Sources/c-utils/lib/textcode/fmt_jsonescape.c:\n    5  #include \"../str.h\"\n    6  #include \"../scan.h\"\n    7: #include \"../uint32.h\"\n    8  \n    9  /* src is UTF-8 encoded */\n   ..\n   43          } else if(s[i] > 0x7f) {\n   44            /* UTF-8! Convert to surrogate pair if needed. */\n   45:           uint32 u;\n   46            size_t j = scan_utf8_sem((const char*)s + i, len - i, &u);\n   47            if(j == 0) { /* Invalid UTF-8! Try to limp on! */\n\n/home/roman/Sources/c-utils/lib/ucs/scan_latin1_utf8.c:\n    6  size_t\n    7  scan_latin1_utf8(const char* x, size_t n, char* out) {\n    8:   uint32 wc;\n    9    size_t ret;\n   10    if((ret = scan_utf8(x, n, &wc))) {\n\n/home/roman/Sources/c-utils/lib/uint32.h:\n   23  #if defined(__BORLANDC__)\n   24  #elif defined(__UINT32_TYPE__) && defined(__INT32_TYPE__)\n   25: typedef __UINT32_TYPE__ uint32;\n   26: typedef __INT32_TYPE__ int32;\n   27  \n   28: #elif defined(___int32_t_defined) || defined(__BIT_TYPES_DEFINED__)\n   29: typedef u_int32_t uint32;\n   30: typedef int32_t int32;\n   31  \n   32  #elif defined(_MSC_VER)\n   33  #include <windows.h>\n   34: typedef UINT32 uint32;\n   35: typedef INT32 int32;\n   36  \n   37  #elif defined(__MINGW32__) || defined(__MINGW64__)\n   38: typedef uint32_t uint32;\n   39: typedef int32_t int32;\n   40  \n   41  #else\n   42: typedef uint32_t uint32;\n   43  \n   44  #if !(defined(_WINSOCK2API_) && defined(__LCC__))\n   45: typedef int32_t int32;\n   46  #endif\n   47  #endif\n   ..\n   52      defined(__LITTLE_ENDIAN__) || (BYTE_ORDER == _LITTLE_ENDIAN) || defined(_AMD64_) || defined(I_X86_))\n   53  inline static void\n   54: uint32_pack(char* out, uint32 in) {\n   55:   *(uint32*)out = in;\n   56  }\n   57  \n   58  inline static void\n   59: uint32_unpack(const char* in, uint32* out) {\n   60:   *out = *(uint32*)in;\n   61  }\n   62  \n   63: inline static uint32\n   64: uint32_get(const void* ptr) {\n   65    const char* in = (const char*)ptr;\n   66:   return *(uint32*)in;\n   67  }\n   68  \n   69: inline static uint32\n   70: uint32_read(const char* in) {\n   71:   return *(uint32*)in;\n   72  }\n   73  \n   74  #else\n   75  \n   76: inline static uint32\n   77: uint32_get(const void* ptr) {\n   78    const char* in = ptr;\n   79    return (in[0] << 24) | (in[1] << 16) | (in[2] << 8) | (in[3]);\n   80  }\n   81  \n   82: inline static uint32\n   83: uint32_read(const char* in) {\n   84    return (in[0] << 24) | (in[1] << 16) | (in[2] << 8) | (in[3]);\n   85  }\n   86  \n   87: void uint32_pack(char* out, uint32 in);\n   88: void uint32_unpack(const char* in, uint32* out);\n   89  #endif\n   90  #endif\n   91  \n   92: void uint32_pack_big(char* out, uint32 in);\n   93: void uint32_unpack_big(const char* in, uint32* out);\n   94: uint32 uint32_read_big(const char* in);\n   95  \n   96: uint32 uint32_random(void);\n   97: int uint32_seed(const void*, unsigned long n);\n   98: uint32 uint32_prng(uint32, uint32 seed);\n   99  \n  100  /* bit rotating macros */\n  101: #define uint32_ror(v, c) (((uint32)(v) >> (c)) | ((uint32)(v) << (32 - (c))))\n  102: #define uint32_rol(v, c) (((uint32)(v) << (c)) | ((uint32)(v) >> (32 - (c))))\n  103: #define uint32_ror_safe(v, c) (((uint32)(v) >> uint32rc(c)) | ((uint32)(v) << (32 - uint32rc(c))))\n  104: #define uint32_rol_safe(v, c) (((uint32)(v) << uint32rc(c)) | ((uint32)(v) >> (32 - uint32rc(c))))\n  105  \n  106  #ifdef __cplusplus\n\n/home/roman/Sources/c-utils/lib/uint32/uint32_pack.c:\n    1  #define NO_UINT32_MACROS\n    2: #include \"../uint32.h\"\n    3  \n    4  void\n    5: uint32_pack(char* out, uint32 in) {\n    6    *out = (char)in;\n    7    in >>= 8;\n\n/home/roman/Sources/c-utils/lib/uint32/uint32_pack_big.c:\n    1  #define NO_UINT32_MACROS\n    2: #include \"../uint32.h\"\n    3  \n    4  void\n    5: uint32_pack_big(char* out, uint32 in) {\n    6    out[3] = (char)in;\n    7    in >>= 8;\n\n/home/roman/Sources/c-utils/lib/uint32/uint32_prng.c:\n    1: #include \"../uint32.h\"\n    2  \n    3: uint32 uint32_entropy[8] = {\n    4      0xe25e40f8,\n    5      0x2839fba7,\n    .\n   13  \n   14  /* prng */\n   15: uint32\n   16: uint32_prng(uint32 value, uint32 seed) {\n   17    register int i = 27;\n   18    while(i >= 0) {\n   19      /* whatever, try to re-use entropy as many as possible with\n   20         as less as possible instructions */\n   21:     seed ^= uint32_ror(uint32_entropy[((value + seed) >> (i + 2)) & 7], seed & 0x1f);\n   22:     seed += uint32_rol(uint32_entropy[((value - seed) >> (i + 1)) & 7], seed & 0x1f);\n   23:     seed -= uint32_ror(uint32_entropy[((value ^ seed) >> (i)) & 7], seed & 0x1f);\n   24      i--;\n   25    }\n\n/home/roman/Sources/c-utils/lib/uint32/uint32_random.c:\n    1: #include \"../uint32.h\"\n    2  #include \"../taia.h\"\n    3  \n    4  #define UINT32_POOLSIZE 16\n    5  \n    6: uint32 uint32_pool[UINT32_POOLSIZE];\n    7: extern uint32 uint32_bytes_seeded;\n    8  \n    9: uint32\n   10: uint32_random(void) {\n   11    size_t i;\n   12:   uint32 r = 0;\n   13  \n   14    /* seed if not seeded */\n   15:   if(uint32_bytes_seeded == 0) {\n   16      struct taia t;\n   17      taia_now(&t);\n   18:     uint32_seed(&t, sizeof(t));\n   19    }\n   20  \n   21:   for(i = 0; i < sizeof(uint32_pool) / sizeof(uint32); i++) {\n   22:     r += uint32_prng(uint32_pool[i], r);\n   23:     uint32_pool[i] = r;\n   24    }\n   25  \n   26:   if(uint32_bytes_seeded)\n   27:     uint32_bytes_seeded--;\n   28  \n   29    return r;\n\n/home/roman/Sources/c-utils/lib/uint32/uint32_read.c:\n    1  #define NO_UINT32_MACROS\n    2: #include \"../uint32.h\"\n    3  \n    4: uint32\n    5: uint32_read(const char* in) {\n    6:   return (((uint32)(unsigned char)in[3]) << 24) | (((uint32)(unsigned char)in[2]) << 16) |\n    7:          (((uint32)(unsigned char)in[1]) << 8) | (uint32)(unsigned char)in[0];\n    8  }\n    9  \n\n/home/roman/Sources/c-utils/lib/uint32/uint32_read_big.c:\n    1  #define NO_UINT32_MACROS\n    2: #include \"../uint32.h\"\n    3  \n    4: uint32\n    5: uint32_read_big(const char* in) {\n    6:   return (((uint32)(unsigned char)in[0]) << 24) | (((uint32)(unsigned char)in[1]) << 16) |\n    7:          (((uint32)(unsigned char)in[2]) << 8) | (uint32)(unsigned char)in[3];\n    8  }\n    9  \n\n/home/roman/Sources/c-utils/lib/uint32/uint32_seed.c:\n    1  #include \"../windoze.h\"\n    2: #include \"../uint32.h\"\n    3  \n    4  #if WINDOWS_NATIVE\n    .\n   14  int open_read(const char* filename);\n   15  \n   16: uint32 uint32_bytes_seeded;\n   17  \n   18: extern uint32 uint32_pool[UINT32_POOLSIZE];\n   19  \n   20  /* feed data to the prng */\n   21  int\n   22: uint32_seed(const void* p, unsigned long n) {\n   23    int fd = -1;\n   24  \n   ..\n   26      int i;\n   27      if((fd = open(\"/dev/urandom\", O_RDONLY)) != -1) {\n   28:       i = read(fd, uint32_pool, sizeof(uint32_pool));\n   29        if(i > 0)\n   30:         uint32_bytes_seeded += i;\n   31        close(fd);\n   32      }\n   33    } else {\n   34      const char* b = (const char*)p;\n   35:     char* x = (char*)uint32_pool;\n   36  \n   37      while(n) {\n   38:       x[n % sizeof(uint32_pool)] ^= *b;\n   39        n--;\n   40        b++;\n   41:       uint32_bytes_seeded++;\n   42      }\n   43    }\n\n/home/roman/Sources/c-utils/lib/uint32/uint32_unpack.c:\n    1  #define NO_UINT32_MACROS\n    2: #include \"../uint32.h\"\n    3  \n    4  void\n    5: uint32_unpack(const char* in, uint32* out) {\n    6:   *out = (((uint32)(unsigned char)in[3]) << 24) | (((uint32)(unsigned char)in[2]) << 16) |\n    7:          (((uint32)(unsigned char)in[1]) << 8) | (uint32)(unsigned char)in[0];\n    8  }\n    9  \n\n/home/roman/Sources/c-utils/lib/uint32/uint32_unpack_big.c:\n    1  #define NO_UINT32_MACROS\n    2: #include \"../uint32.h\"\n    3  \n    4  void\n    5: uint32_unpack_big(const char* in, uint32* out) {\n    6:   *out = (((uint32)(unsigned char)in[0]) << 24) | (((uint32)(unsigned char)in[1]) << 16) |\n    7:          (((uint32)(unsigned char)in[2]) << 8) | (uint32)(unsigned char)in[3];\n    8  }\n    9  \n\n/home/roman/Sources/c-utils/lib/uint64/uint64_pack.c:\n    1  #define NO_UINT64_MACROS\n    2  #include \"../uint64.h\"\n    3: #include \"../uint32.h\"\n    4  \n    5  void\n    6  uint64_pack(char* out, uint64 in) {\n    7:   uint32_pack(out, in & 0xffffffff);\n    8:   uint32_pack(out + 4, (uint32)(in >> 32));\n    9  }\n   10  \n\n/home/roman/Sources/c-utils/lib/uint64/uint64_pack_big.c:\n    1  #define NO_UINT64_MACROS\n    2  #include \"../uint64.h\"\n    3: #include \"../uint32.h\"\n    4  \n    5  void\n    6  uint64_pack_big(char* out, uint64 in) {\n    7:   uint32_pack_big(out, (uint32)(in >> 32));\n    8:   uint32_pack_big(out + 4, in & 0xffffffff);\n    9  }\n   10  \n\n/home/roman/Sources/c-utils/lib/uint64/uint64_read.c:\n    1  #define NO_UINT64_MACROS\n    2  #include \"../uint64.h\"\n    3: #include \"../uint32.h\"\n    4  \n    5  uint64\n    6  uint64_read(const char* in) {\n    7:   return uint32_read(in) | ((uint64)uint32_read(in + 4) << 32);\n    8  }\n    9  \n\n/home/roman/Sources/c-utils/lib/uint64/uint64_read_big.c:\n    1  #define NO_UINT64_MACROS\n    2  #include \"../uint64.h\"\n    3: #include \"../uint32.h\"\n    4  \n    5  uint64\n    6  uint64_read_big(const char* in) {\n    7:   return ((uint64)uint32_read_big(in) << 32) | uint32_read_big(in + 4);\n    8  }\n    9  \n\n/home/roman/Sources/c-utils/lib/uint64/uint64_unpack_big.c:\n    1  #define NO_UINT64_MACROS\n    2  #include \"../uint64.h\"\n    3: #include \"../uint32.h\"\n    4  \n    5  void\n\n/home/roman/Sources/c-utils/bsdiffcat.c:\n   12  #include \"lib/path.h\"\n   13  #include \"lib/errmsg.h\"\n   14: #include \"lib/uint32.h\"\n   15  \n   16  #if !WINDOWS_NATIVE\n\n/home/roman/Sources/c-utils/cache.c:\n    1  #include \"lib/alloc.h\"\n    2  #include \"lib/byte.h\"\n    3: #include \"lib/uint32.h\"\n    4  #include \"lib/tai.h\"\n    5  #include \"lib/mmap.h\"\n    .\n   17  \n   18  static struct {\n   19:   uint32 writer, oldest, unused;\n   20    char x[];\n   21  }* data = 0;\n   22  \n   23  static char* x = 0;\n   24: static uint32 size;\n   25: static uint32 hsize;\n   26  \n   27: static uint32 writer;\n   28: static uint32 oldest;\n   29: static uint32 unused;\n   30  \n   31: static uint32 top;\n   32  \n   33  /*\n   ..\n   66  \n   67  static inline void\n   68: set4(uint32 pos, uint32 u) {\n   69    if(pos > size - 4)\n   70      cache_impossible();\n   71:   uint32_pack(x + pos, u);\n   72    top = pos + 4;\n   73  }\n   74  \n   75  static inline void\n   76: setb(uint32 pos, size_t len, const void* b) {\n   77    byte_copy(&x[pos], len, b);\n   78    top = pos + len;\n   79  }\n   80  \n   81: static inline uint32\n   82: get4(uint32 pos) {\n   83:   uint32 result;\n   84    if(pos > size - 4)\n   85      cache_impossible();\n   86:   uint32_unpack(x + pos, &result);\n   87    return result;\n   88  }\n   ..\n  105  char*\n  106  cache_find(const char* key, unsigned int keylen, unsigned int* datalen, struct tai* expire) {\n  107:   uint32 pos, prevpos, nextpos, u;\n  108    unsigned int loop;\n  109    double d;\n  ...\n  144  \n  145  char*\n  146: cache_get(const char* key, unsigned int keylen, unsigned int* datalen, uint32* ttl) {\n  147    struct tai expire, now;\n  148    double d;\n  ...\n  165  \n  166  void\n  167: cache_set(const char* key, unsigned int keylen, const char* data, unsigned int datalen, uint32 ttl) {\n  168    struct tai now;\n  169    struct tai expire;\n  170    unsigned int entrylen;\n  171    unsigned int keyhash;\n  172:   uint32 pos;\n  173  \n  174    if(!x)\n  ...\n  235  cache_update() {\n  236    if(data) {\n  237:     uint32_pack((char*)&data->writer, writer);\n  238:     uint32_pack((char*)&data->oldest, oldest);\n  239:     uint32_pack((char*)&data->unused, unused);\n  240  \n  241:     msync(data, sizeof(uint32) * 3 + top, MS_SYNC);\n  242      top = 0;\n  243    }\n  ...\n  250  \n  251    if(x != NULL && data != NULL)\n  252:     mmap_unmap((void*)data, size + sizeof(uint32) * 3);\n  253  \n  254    x = 0;\n  ...\n  297        return 0;\n  298  \n  299:     if(ftruncate(fd, cachesize + sizeof(uint32) * 3) == -1)\n  300        return 0;\n  301      close(fd);\n  ...\n  309  \n  310    x = data->x;\n  311:   size = cachesize - sizeof(uint32) * 3;\n  312  \n  313    hsize = 4;\n  ...\n  315  \n  316    if(exists) {\n  317:     uint32_unpack((const char*)&data->writer, &writer);\n  318:     uint32_unpack((const char*)&data->oldest, &oldest);\n  319:     uint32_unpack((const char*)&data->unused, &unused);\n  320    } else {\n  321  \n\n/home/roman/Sources/c-utils/cache.h:\n    2  #define DNSCACHE_CACHE_H\n    3  \n    4: #include \"lib/uint32.h\"\n    5  #include \"lib/uint64.h\"\n    6  \n    .\n    8  \n    9  char* cache_find(const char*, unsigned int, unsigned int*, struct tai*);\n   10: char* cache_get(const char*, unsigned int, unsigned int*, uint32*);\n   11: void cache_set(const char*, unsigned int, const char*, unsigned int, uint32);\n   12  void cache_update(void);\n   13  void cache_free(void);\n\n/home/roman/Sources/c-utils/CMakeLists.txt:\n  309  if(NOT CROSS)\n  310    check_type_size(int16_t INT16_T)\n  311:   check_type_size(int32_t INT32_T)\n  312    check_type_size(int64_t INT64_T)\n  313    check_type_size(intmax_t INTMAX_T)\n  314    check_type_size(uint8_t UINT8_T)\n  315    check_type_size(uint16_t UINT16_T)\n  316:   check_type_size(uint32_t UINT32_T)\n  317    check_type_size(uint64_t UINT64_T)\n  318    check_type_size(uintmax_t UINTMAX_T)\n  ...\n  337        set(uintptr_t \"uint64_t\")\n  338      else()\n  339:       set(uintptr_t \"uint32_t\")\n  340      endif()\n  341    endif()\n  ...\n 1070    # __int64, int, long, and long long\\n * that exists and is the right size.\\n */\\n#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)\\ntypedef __int64 int64_t;\\n#define HAVE_INT64_T\\n#endif\\n\\n#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8\\ntypedef int int64_t;\\n#define HAVE_INT64_T\\n#endif\\n\\n#if\n 1071    # !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8\\ntypedef long int64_t;\\n#define HAVE_INT64_T\\n#endif\\n\\n#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8\\ntypedef long long int64_t;\\n#define HAVE_INT64_T\\n#endif\\n\\n#if !defined(HAVE_INT64_T)\\n#error No 64-bit integer type was\n 1072:   # found.\\n#endif\\n\\n/*\\n * Similarly for int32_t\\n */\\n#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4\\ntypedef int int32_t;\\n#define HAVE_INT32_T\\n#endif\\n\\n#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4\\ntypedef long int32_t;\\n#define HAVE_INT32_T\\n#endif\\n\\n#if !defined(HAVE_INT32_T)\\n#error No\n 1073    # 32-bit integer type was found.\\n#endif\\n\\n/*\\n * Similarly for int16_t\\n */\\n#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2\\ntypedef int int16_t;\\n#define HAVE_INT16_T\\n#endif\\n\\n#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2\\ntypedef short int16_t;\\n#define HAVE_INT16_T\\n#endif\\n\\n#if\n 1074    # !defined(HAVE_INT16_T)\\n#error No 16-bit integer type was found.\\n#endif\\n\\n/*\\n * Similarly for uint64_t\\n */\\n#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)\\ntypedef unsigned __int64 uint64_t;\\n#define HAVE_UINT64_T\\n#endif\\n\\n#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED ==\n 1075    # 8\\ntypedef unsigned uint64_t;\\n#define HAVE_UINT64_T\\n#endif\\n\\n#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG == 8\\ntypedef unsigned long uint64_t;\\n#define HAVE_UINT64_T\\n#endif\\n\\n#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED_LONG_LONG == 8\\ntypedef unsigned long long\n 1076:   # uint64_t;\\n#define HAVE_UINT64_T\\n#endif\\n\\n#if !defined(HAVE_UINT64_T)\\n#error No 64-bit unsigned integer type was found.\\n#endif\\n\\n/*\\n * Similarly for uint32_t\\n */\\n#if !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED == 4\\ntypedef unsigned uint32_t;\\n#define HAVE_UINT32_T\\n#endif\\n\\n#if\n 1077:   # !defined(HAVE_UINT32_T) && SIZE_OF_UNSIGNED_LONG == 4\\ntypedef unsigned long uint32_t;\\n#define HAVE_UINT32_T\\n#endif\\n\\n#if !defined(HAVE_UINT32_T)\\n#error No 32-bit unsigned integer type was found.\\n#endif\\n\\n/*\\n * Similarly for uint16_t\\n */\\n#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED\n 1078    # == 2\\ntypedef unsigned uint16_t;\\n#define HAVE_UINT16_T\\n#endif\\n\\n#if !defined(HAVE_UINT16_T) && SIZE_OF_UNSIGNED_SHORT == 2\\ntypedef unsigned short uint16_t;\\n#define HAVE_UINT16_T\\n#endif\\n\\n#if !defined(HAVE_UINT16_T)\\n#error No 16-bit unsigned integer type was found.\\n#endif\\n\\n/*\\n *\n 1079    # Similarly for uint8_t\\n */\\n#if !defined(HAVE_UINT8_T)\\ntypedef unsigned char uint8_t;\\n#define HAVE_UINT8_T\\n#endif\\n\\n#if !defined(HAVE_UINT16_T)\\n#error No 8-bit unsigned integer type was found.\\n#endif\\n\\n/* Define intmax_t and uintmax_t if they are not already defined. */\\n#if\n ....\n 1267      textcode\n 1268      uint16\n 1269:     uint32\n 1270      uint64\n 1271      unix\n ....\n 1331    mmap\n 1332    uint64\n 1333:   uint32\n 1334    uint16)\n 1335: target_link_libraries(fmt byte str uint64 uint32)\n 1336  target_link_libraries(gpio mmap)\n 1337  target_link_libraries(hmap str)\n ....\n 1360  target_link_libraries(map str)\n 1361  target_link_libraries(mmap seek open scan ${LIBPSAPI})\n 1362: target_link_libraries(open str uint32)\n 1363  target_link_libraries(path dir strlist)\n 1364: target_link_libraries(pe uint64 uint32 uint16)\n 1365  target_link_libraries(playlist byte fmt scan str xml)\n 1366  target_link_libraries(rdir dir)\n ....\n 1380  target_link_libraries(taia tai)\n 1381  target_link_libraries(textbuf byte playlist)\n 1382: target_link_libraries(uint64 uint32)\n 1383  target_link_libraries(xml buffer array strlist hmap alloc)\n 1384  target_link_libraries(json slist hmap stralloc buffer alloc)\n ....\n 1386  target_link_libraries(process wait errmsg)\n 1387  target_link_libraries(ihex scan byte)\n 1388: target_link_libraries(uint32 taia tai)\n 1389  \n 1390  set(genmakefile_SOURCES mplab.c ini.c ini.h genmakefile.h)\n ....\n 1505      byte\n 1506      errmsg\n 1507:     uint32\n 1508      uint64\n 1509      ${COMPRESSION_LIBRARIES})\n ....\n 1615    scan\n 1616    str)\n 1617: add_program(elf64list elf mmap uint16 uint32 uint64)\n 1618  add_program(\n 1619    elflist\n ....\n 1733    uint64\n 1734    ${LIBADVAPI32})\n 1735: add_program(macho32list mmap uint32)\n 1736  if(USE_LZMA)\n 1737    add_program(\n ....\n 2118    scan\n 2119    io\n 2120:   uint32)\n 2121  target_link_libraries(tinyproxy ${LIBMSWSOCK})\n 2122  if(NOT WIN32)\n\n/home/roman/Sources/c-utils/cofflist.c:\n   22  \n   23  void\n   24: put_hex(buffer* b, uint32 v) {\n   25    if(v) {\n   26      buffer_puts(b, \"0x\");\n   ..\n   32  \n   33  void\n   34: put_value(buffer* b, const char* name, uint32 v) {\n   35    buffer_puts(b, name);\n   36    buffer_puts(b, \": \");\n   ..\n   43  coff_print_func(buffer* b, void* coff, coff_symtab_entry* fn) {\n   44  \n   45:   coff_symtab_entry* aux = coff_index_symtab(coff, uint32_get(&fn->func.tag_index));\n   46:   coff_symtab_entry* bfef = coff_index_symtab(coff, uint32_get(&fn->func.tag_index) + 1);\n   47    coff_section_header* shdr = coff_get_section(coff, aux->e.scnum);\n   48  \n   ..\n   74  \n   75        buffer_puts(b, \", offset: \");\n   76:       buffer_putxlong0(b, p->addr + uint32_get(&shdr->pointer_to_raw_data), 8);\n   77      } else {\n   78        coff_symtab_entry* sym = coff_index_symtab(coff, p->fname);\n   ..\n  162        buffer_putspad(b, coff_symtab_mchp_types[entry->type] ? coff_symtab_mchp_types[entry->type] : \"\", 16);\n  163        buffer_putspace(b);\n  164:       buffer_putlong0(b, (long)(uint32)entry->numaux, 2);\n  165  \n  166        buffer_putspace(b);\n  ...\n  340        put_value(buffer_2, \"COFF_FILE_HEADER\\nmachine\", uint16_get(&header->machine));\n  341        put_value(buffer_2, \"number_of_sections\", uint16_get(&header->number_of_sections));\n  342:       put_value(buffer_2, \"time_date_stamp\", uint32_get(&header->time_date_stamp));\n  343:       put_value(buffer_2, \"pointer_to_symbol_table\", uint32_get(&header->pointer_to_symbol_table));\n  344:       put_value(buffer_2, \"number_of_symbols\", uint32_get(&header->number_of_symbols));\n  345        put_value(buffer_2, \"size_of_optional_header\", uint16_get(&header->size_of_optional_header));\n  346        put_value(buffer_2, \"characteristics\", uint16_get(&header->characteristics));\n  ...\n  362            put_value(buffer_2, \"COFF_OPT_HEADER\\nmagic\", uint16_get(&opthdr_mchp->magic));\n  363            put_value(buffer_2, \"vstamp\", uint16_get(&opthdr_mchp->vstamp));\n  364:           put_value(buffer_2, \"proc_type\", /*uint32_get*/ (opthdr_mchp->proc_type));\n  365:           put_value(buffer_2, \"rom_width_bits\", /*uint32_get*/ (opthdr_mchp->rom_width_bits));\n  366:           put_value(buffer_2, \"ram_width_bits\", /*uint32_get*/ (opthdr_mchp->ram_width_bits));\n  367          }\n  368  \n  ...\n  393          }\n  394          if(print_data_dir) {\n  395:           uint32 num_dirs;\n  396            coff_data_directory* data_dir = coff_get_datadir(base, &num_dirs);\n  397  \n  ...\n  433      buffer_putspad(buffer_1, sections[i].name, 16);\n  434      buffer_putspace(buffer_1);\n  435:     put_hex(buffer_1, uint32_get(&sections[i].physical_address));\n  436      buffer_putspace(buffer_1);\n  437:     put_hex(buffer_1, uint32_get(&sections[i].virtual_address));\n  438      buffer_putspace(buffer_1);\n  439:     put_hex(buffer_1, uint32_get(&sections[i].size_of_raw_data));\n  440      buffer_putspace(buffer_1);\n  441:     put_hex(buffer_1, uint32_get(&sections[i].pointer_to_raw_data));\n  442      buffer_putnlflush(buffer_1);\n  443    }\n\n/home/roman/Sources/c-utils/cparser/lex.yy.c:\n   45  typedef int16_t flex_int16_t;\n   46  typedef uint16_t flex_uint16_t;\n   47: typedef int32_t flex_int32_t;\n   48: typedef uint32_t flex_uint32_t;\n   49  #else\n   50  typedef signed char flex_int8_t;\n   51  typedef short int flex_int16_t;\n   52: typedef int flex_int32_t;\n   53  typedef unsigned char flex_uint8_t;\n   54  typedef unsigned short int flex_uint16_t;\n   55: typedef unsigned int flex_uint32_t;\n   56  \n   57  /* Limits of integral types. */\n   ..\n  348     but its presence is necessary. */\n  349  struct yy_trans_info {\n  350:   flex_int32_t yy_verify;\n  351:   flex_int32_t yy_nxt;\n  352  };\n  353  static const flex_int16_t yy_accept[385] = {\n\n/home/roman/Sources/c-utils/crc.c:\n    1  #include \"lib/buffer.h\"\n    2  #include \"lib/errmsg.h\"\n    3: #include \"lib/uint32.h\"\n    4  \n    5: uint32\n    6: crc32(uint32 crc, const char* data, size_t size) {\n    7:   uint32 i, r = ~0;\n    8    const char* end = data + size;\n    9  \n   ..\n   12  \n   13      for(i = 0; i < 8; i++) {\n   14:       uint32 t = ~((r & 1) - 1);\n   15        r = (r >> 1) ^ (0xedb88320 & t);\n   16      }\n\n/home/roman/Sources/c-utils/dnscache.c:\n   31  \n   32  static char sendaddr[16], bindaddr[16];\n   33: static uint32 bindscope;\n   34  static char buf[1024];\n   35  uint64 numqueries = 0;\n   ..\n   51    char ip[16]; /* send response to this address */\n   52    uint16 port; /* send response to this port */\n   53:   uint32 scope_id;\n   54    char id[2];\n   55    int tcp; /* open TCP socket, if active */\n   ..\n   67    char ip[16];\n   68    uint16 port;\n   69:   uint32 scope_id;\n   70    char id[2];\n   71  };\n   ..\n   79  union {\n   80    char u8[128];\n   81:   uint32 u32[32];\n   82  } seed;\n   83  \n   ..\n  525    int v6only_prev;\n  526  \n  527:   uint32_seed(NULL, 0);\n  528  \n  529    for(i = 1; i < argc; i++) env_put(argv[i]);\n  ...\n  555    socket_tryreservein(udp53, 131072);\n  556  \n  557:   for(i = 0; i < 32; i++) seed.u32[i] = uint32_random();\n  558  \n  559    dns_random_init(seed.u8);\n\n/home/roman/Sources/c-utils/elf64list.c:\n    3  #include \"lib/mmap.h\"\n    4  #include \"lib/uint16.h\"\n    5: #include \"lib/uint32.h\"\n    6  #include \"lib/uint64.h\"\n    7  #include \"lib/str.h\"\n\n/home/roman/Sources/c-utils/elflist.c:\n  282      range code = elf_symbol_r(map.start, symbol);\n  283  \n  284:     uint32 name = ELF_GET(map.start, symbol, sym, st_name);\n  285      uint8 info = ELF_GET(map.start, symbol, sym, st_info);\n  286  \n  ...\n  362  \n  363    range_foreach(&sections, section) {\n  364:     uint32 name = ELF_GET(map.start, section, shdr, sh_name);\n  365      uint64 addr = ELF_GET(map.start, section, shdr, sh_addr);\n  366      uint64 size = ELF_GET(map.start, section, shdr, sh_size);\n  367      uint64 offs = ELF_GET(map.start, section, shdr, sh_offset);\n  368      uint64 align = ELF_GET(map.start, section, shdr, sh_addralign);\n  369:     uint32 type = ELF_GET(map.start, section, shdr, sh_type) % ELF_SHT_NUM;\n  370  \n  371      if(!name && !addr && !size)\n  ...\n  421      uint64 filesz = ELF_GET(map.start, segment, phdr, p_filesz);\n  422      uint64 memsz = ELF_GET(map.start, segment, phdr, p_memsz);\n  423:     uint32 flags = ELF_GET(map.start, segment, phdr, p_flags);\n  424  \n  425      if(!paddr && !vaddr && !filesz)\n\n/home/roman/Sources/c-utils/examples/client.c:\n   54    int s;\n   55    uint16 port = 2342;\n   56:   uint32 scope_id = 0;\n   57    char ip[16];\n   58    char buf[8192];\n\n/home/roman/Sources/c-utils/examples/CMakeLists.txt:\n    6  link_directories(${CMAKE_BINARY_DIR})\n    7  \n    8: link_libraries( dns io textcode strlist errmsg path stralloc mmap str taia tai buffer open scan fmt uint32)\n    9  #set(EXAMPLES  \n   10  #  array buffer_1 buffer_fromsa buffer_mmap buffer_tosa byte_copy fmt \n\n/home/roman/Sources/c-utils/examples/httpd.c:\n  209  main() {\n  210    int s = socket_tcp6();\n  211:   uint32 scope_id;\n  212    char ip[16];\n  213    uint16 port;\n\n/home/roman/Sources/c-utils/examples/io5.c:\n    8  main() {\n    9    int s = socket_tcp6();\n   10:   uint32 scope_id;\n   11    char ip[16];\n   12    uint16 port;\n\n/home/roman/Sources/c-utils/examples/marshal.c:\n   11  #include \"../lib/byte.h\"\n   12  #include \"../lib/uint16.h\"\n   13: #include \"../lib/uint32.h\"\n   14  #include \"../lib/uint64.h\"\n   15  #include \"../lib/open.h\"\n   ..\n   34  int\n   35  main() {\n   36:   uint32 x;\n   37  \n   38    unsigned long long ull;\n   ..\n  372  \n  373    assert(sizeof(uint16) == sizeof(uint16));\n  374:   assert(sizeof(uint32) == sizeof(uint32));\n  375    assert(sizeof(uint64) == sizeof(uint64));\n  376    assert(sizeof(int16) == sizeof(int16));\n  377:   assert(sizeof(int32) == sizeof(int32));\n  378    assert(sizeof(int64) == sizeof(int64));\n  379  \n  ...\n  388    assert(uint16_read_big(buf + 3) == 0x0304);\n  389  \n  390:   assert(uint32_read(buf) == 0x03020100);\n  391:   assert(uint32_read(buf + 1) == 0x04030201);\n  392:   assert(uint32_read(buf + 2) == 0x05040302);\n  393:   assert(uint32_read(buf + 3) == 0x06050403);\n  394  \n  395:   assert(uint32_read_big(buf) == 0x00010203);\n  396:   assert(uint32_read_big(buf + 1) == 0x01020304);\n  397:   assert(uint32_read_big(buf + 2) == 0x02030405);\n  398:   assert(uint32_read_big(buf + 3) == 0x03040506);\n  399  \n  400    assert(uint64_read(buf) == 0x0706050403020100ull);\n  ...\n  410    {\n  411      uint16 us;\n  412:     uint32 ui;\n  413      uint64 ul;\n  414      size_t i;\n  ...\n  416        uint16_unpack(buf + i, &us);\n  417        assert(us == uint16_read(buf + i));\n  418:       uint32_unpack(buf + i, &ui);\n  419:       assert(ui == uint32_read(buf + i));\n  420        uint64_unpack(buf + i, &ul);\n  421        assert(ul == uint64_read(buf + i));\n  422        uint16_unpack_big(buf + i, &us);\n  423        assert(us == uint16_read_big(buf + i));\n  424:       uint32_unpack_big(buf + i, &ui);\n  425:       assert(ui == uint32_read_big(buf + i));\n  426        uint64_unpack_big(buf + i, &ul);\n  427        assert(ul == uint64_read_big(buf + i));\n  ...\n  434        assert(buf[i + 2] == '_' && uint16_read_big(buf + i) == 0xc0de);\n  435        zap();\n  436:       uint32_pack(buf + i, 0xfefec0de);\n  437:       assert(buf[i + 4] == '_' && uint32_read(buf + i) == 0xfefec0de);\n  438        zap();\n  439:       uint32_pack_big(buf + i, 0xfefec0de);\n  440:       assert(buf[i + 4] == '_' && uint32_read_big(buf + i) == 0xfefec0de);\n  441        zap();\n  442        uint64_pack(buf + i, 0xfefec0dedeadbeef);\n\n/home/roman/Sources/c-utils/examples/mult.c:\n    5  main() {\n    6    int16 a;\n    7:   int32 b;\n    8    int64 c;\n    9    uint64 d;\n\n/home/roman/Sources/c-utils/examples/proxy.c:\n   21  main(int argc, char* argv[]) {\n   22    int s = socket_tcp6();\n   23:   uint32 scope_id;\n   24    char ip[16];\n   25    uint16 port;\n   26    char hisip[16];\n   27    uint16 hisport;\n   28:   uint32 hisscope_id;\n   29    static char seed[128];\n   30    static stralloc fqdn;\n\n/home/roman/Sources/c-utils/examples/range.c:\n   35  #endif\n   36  \n   37:   assert(__MIN(int32_t) == (int32_t)0x80000000);\n   38:   assert(__MAX(int32_t) == 0x7fffffff);\n   39:   assert(__MIN(uint32) == 0);\n   40:   assert(__MAX(uint32) == 0xffffffff);\n   41  }\n   42  \n   ..\n  126    assert(range_str4inbuf(buf, sizeof(buf), buf + sizeof(buf)) == 0);\n  127    {\n  128:     uint32 y[6];\n  129      int i;\n  130      for(i = 0; i < 6; ++i) y[i] = \"fnord\"[i];\n\n/home/roman/Sources/c-utils/examples/server.c:\n   54    int s, t;\n   55    uint16 port = 2342;\n   56:   uint32 scope_id = 0;\n   57    char ip[16];\n   58    char buf[8192];\n\n/home/roman/Sources/c-utils/examples/uint.c:\n    1  #include <assert.h>\n    2  #include \"../lib/uint16.h\"\n    3: #include \"../lib/uint32.h\"\n    4  #include \"../lib/uint64.h\"\n    5  #include \"../lib/byte.h\"\n    .\n   28  \n   29    {\n   30:     uint32 a;\n   31  \n   32      buf[0] = buf[1] = buf[2] = buf[3] = 0;\n   33:     uint32_pack_big(buf, 0x12345678);\n   34      assert(buf[0] == 0x12 && buf[1] == 0x34 && buf[2] == 0x56 && buf[3] == 0x78);\n   35:     uint32_unpack_big(buf, &a);\n   36      assert(a == 0x12345678);\n   37:     assert(uint32_read_big(buf) == 0x12345678);\n   38  \n   39      buf[0] = buf[1] = buf[2] = buf[3] = 0;\n   40:     uint32_pack(buf, 0x12345678);\n   41      assert(buf[0] == 0x78 && buf[1] == 0x56 && buf[2] == 0x34 && buf[3] == 0x12);\n   42:     uint32_unpack(buf, &a);\n   43      assert(a == 0x12345678);\n   44:     assert(uint32_read(buf) == 0x12345678);\n   45    }\n   46  \n\n/home/roman/Sources/c-utils/examples/utf8_example.c:\n    8  main() {\n    9    char buf[100];\n   10:   uint32 l;\n   11    unsigned int i;\n   12    /* first positive testing for the various lengths */\n\n/home/roman/Sources/c-utils/examples/uudecode.c:\n   19  #include \"../lib/case.h\"\n   20  \n   21: static const uint32 crc_table[256] = {\n   22      0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L, 0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L,\n   23      0x79dcb8a4L, 0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L, 0x90bf1d91L, 0x1db71064L, 0x6ab020f2L,\n   ..\n   50      0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL, 0x2d02ef8dL};\n   51  \n   52: uint32\n   53: crc32(uint32 crc, const char* buf, unsigned int len) {\n   54    const unsigned char* b = (const unsigned char*)buf;\n   55    crc = crc ^ 0xfffffffful;\n\n/home/roman/Sources/c-utils/fns.txt:\n 2108  xdr_int\n 2109  xdr_int16_t\n 2110: xdr_int32_t\n 2111  xdr_int64_t\n 2112  xdr_int8_t\n ....\n 2143  xdr_u_int\n 2144  xdr_uint16_t\n 2145: xdr_uint32_t\n 2146  xdr_uint64_t\n 2147  xdr_uint8_t\n\n/home/roman/Sources/c-utils/genmakefile.c:\n 1128   * @param t                           Target\n 1129   */\n 1130: static uint32 rule_dep_serial;\n 1131  \n 1132  void\n ....\n 1469  \n 1470    if(byte_chr(x, len, '/') == len && byte_ends(x, len, \"strlist_shift.c\"))\n 1471:     asm(\"int3\");\n 1472  \n 1473    if(is_source_b(x, len) || is_include_b(x, len)) {\n ....\n 1694        const char* s = \"strlist_shift.c\";\n 1695        if(stralloc_endsb(&real, s, str_len(s)))\n 1696:         asm(\"int3\");\n 1697      }\n 1698  \n ....\n 1970  #endif\n 1971  \n 1972:     asm(\"int3\");\n 1973    }\n 1974  \n ....\n 2174  \n 2175  void\n 2176: sourcedir_dep_recursive(sourcedir* srcdir, strlist* out, uint32 serial, sourcedir* parent) {\n 2177    const char* s;\n 2178    size_t n;\n ....\n 2199  void\n 2200  sourcedir_deps(sourcedir* srcdir, strlist* out) {\n 2201:   uint32 serial = uint32_random();\n 2202    return sourcedir_dep_recursive(srcdir, out, serial, 0);\n 2203  }\n ....\n 3361    if(output.len) {\n 3362      char* d;\n 3363:     uint32* count_ptr;\n 3364      stralloc_nul(&output);\n 3365      stralloc_zero(&dir);\n 3366      d = path_dirname(output.s, &dir);\n 3367      if(!(count_ptr = MAP_GET(targetdirs, dir.s, dir.len + 1))) {\n 3368:       uint32 count = 0;\n 3369        MAP_INSERT(targetdirs, dir.s, dir.len + 1, &count, sizeof(count));\n 3370        count_ptr = MAP_GET(targetdirs, dir.s, dir.len + 1);\n ....\n 3809  void\n 3810  output_script(buffer* b, target* rule) {\n 3811:   static uint32 serial;\n 3812    char* x;\n 3813    size_t n;\n ....\n 4914  \n 4915    errmsg_iam(argv[0]);\n 4916:   uint32_seed(NULL, 0);\n 4917  #ifdef _MSC_VER\n 4918    unix_optbuf = buffer_1;\n ....\n 5470  \n 5471      MAP_FOREACH(targetdirs, t) {\n 5472:       uint32* count_ptr = (uint32*)MAP_VALUE(t);\n 5473        buffer_puts(buffer_2, \"  '\");\n 5474        buffer_puts(buffer_2, MAP_KEY(t));\n ....\n 5500  \n 5501      MAP_FOREACH(targetdirs, t) {\n 5502:       uint32* count_ptr = (uint32*)MAP_VALUE(t);\n 5503        buffer_puts(buffer_2, \"  '\");\n 5504        buffer_puts(buffer_2, MAP_KEY(t));\n\n/home/roman/Sources/c-utils/genmakefile.h:\n   14  #include \"lib/strarray.h\"\n   15  #include \"lib/strlist.h\"\n   16: #include \"lib/uint32.h\"\n   17  #include \"lib/errmsg.h\"\n   18  #include \"lib/array.h\"\n   ..\n   78    set_t pptoks;\n   79    set_t deps;\n   80:   uint32 serial;\n   81  } sourcedir;\n   82  \n   ..\n   88    array deps;\n   89    array objs;\n   90:   uint32 serial;\n   91    strlist vars;\n   92  } target;\n   ..\n  240  void sourcedir_populate(strarray*);\n  241  void sourcedir_dump_all(buffer*);\n  242: void sourcedir_dep_recursive(sourcedir*, strlist*, uint32, sourcedir*);\n  243  void sourcedir_deps(sourcedir*, strlist*);\n  244  void sourcedir_deps_s(const char*, strlist*);\n\n/home/roman/Sources/c-utils/hexedit.c:\n   35    const char* name;\n   36    size_t file_size;\n   37:   uint32 crc32;\n   38    array records;\n   39  } patch_t;\n   ..\n   43  extern ssize_t buffer_dummyreadmmap();\n   44  \n   45: uint32\n   46: crc32(uint32 crc, const char* data, size_t size) {\n   47:   uint32 i, r = ~0;\n   48    const char* end = data + size;\n   49  \n   ..\n   52  \n   53      for(i = 0; i < 8; i++) {\n   54:       uint32 t = ~((r & 1) - 1);\n   55        r = (r >> 1) ^ (0xedb88320 & t);\n   56      }\n   ..\n   61  \n   62  int\n   63: get_crc32(const char* filename, uint32* crc) {\n   64    size_t n;\n   65    const char* x;\n   ..\n   74  }\n   75  \n   76: uint32\n   77  byte_crc32(const char* x, size_t n) {\n   78:   uint32 r;\n   79    r = crc32(0, (const char*)x, n);\n   80    return r;\n   81  }\n   82  \n   83: uint32\n   84  buffer_crc32(buffer* b) {\n   85    return byte_crc32(b->x, b->n);\n   ..\n  171  \n  172  patch_t*\n  173: patch_new(const char* name, size_t file_size, uint32 crc32) {\n  174    patch_t* patch = array_allocate(&patches, sizeof(patch_t), array_length(&patches, sizeof(patch_t)));\n  175  \n\n/home/roman/Sources/c-utils/httpproxy.c:\n   15  #include \"lib/mmap.h\"\n   16  #include \"lib/scan.h\"\n   17: #include \"lib/uint32.h\"\n   18  \n   19  #include <stdlib.h>\n   ..\n   31  #endif\n   32  \n   33: static map_t(uint32) hosts_db;\n   34  static char ipbuf[IP4_FMT];\n   35  \n   ..\n   85          stralloc_nul(&hostname);\n   86  \n   87:         map_set(&hosts_db, hostname.s, *(uint32*)ip);\n   88  \n   89          s += hlen;\n\n/home/roman/Sources/c-utils/impgen.c:\n   14  \n   15       You should have received a copy of the GNU General Public License\n   16:      auint32 with this program; if not, write to the Free Software\n   17       Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n   18   */\n   ..\n   23  #include \"lib/open.h\"\n   24  #include \"lib/pe.h\"\n   25: #include \"lib/uint32.h\"\n   26  #include \"lib/str.h\"\n   27  #include \"lib/fmt.h\"\n   ..\n   34      char *base, *filename, *dll_name;\n   35      size_t dllsz;\n   36:     uint32 i, *name_rvas, nexp, num_entries;\n   37      uint16* ord_rvas;\n   38      pe_data_directory* datadir;\n   ..\n   60        return 1;\n   61  \n   62:     exports = pe_rva2ptr(base, uint32_get(&datadir->virtual_address));\n   63  \n   64:     nexp = uint32_get(&exports->number_of_names);\n   65:     name_rvas = pe_rva2ptr(base, uint32_get(&exports->address_of_names));\n   66:     ord_rvas = pe_rva2ptr(base, uint32_get(&exports->address_of_name_ordinals));\n   67  \n   68      buffer_putm_internal(buffer_1, \"LIBRARY \", dll_name, \"\\n\", 0);\n   ..\n   72  \n   73      for(i = 0; i < nexp; i++) {\n   74:       buffer_putm_internal(buffer_1, \"  \", pe_rva2ptr(base, uint32_get(&name_rvas[i])), \" @ \", 0);\n   75        buffer_putulong(buffer_1, uint16_get(&ord_rvas[i]));\n   76        buffer_putnlflush(buffer_1);\n\n/home/roman/Sources/c-utils/intelhex.h:\n   24  class hex_data;\n   25  typedef hex_data container;\n   26: typedef uint32_t address_type;\n   27  typedef uint8_t value_type;\n   28  \n\n/home/roman/Sources/c-utils/lib.h:\n   57  #include \"lib/ucs.h\"\n   58  #include \"lib/rangecheck.h\"\n   59: #include \"lib/uint32.h\"\n   60  #include \"lib/likely.h\"\n   61  #include \"lib/textcode.h\"\n   ..\n 1119  #include \"lib/unix/getopt.c\"\n 1120  #include \"lib/unix/popen.c\"\n 1121: #include \"lib/uint32/uint32_seed.c\"\n 1122: #include \"lib/uint32/uint32_unpack.c\"\n 1123: //#include \"lib/uint32/uint32_pack.c\"\n 1124: #include \"lib/uint32/uint32_prng.c\"\n 1125: //#include \"lib/uint32/uint32_read.c\"\n 1126: #include \"lib/uint32/uint32_unpack_big.c\"\n 1127: #include \"lib/uint32/uint32_random.c\"\n 1128: #include \"lib/uint32/uint32_read_big.c\"\n 1129: #include \"lib/uint32/uint32_pack_big.c\"\n 1130  #include \"lib/strptime.c\"\n 1131  #include \"lib/wait/waitn.c\"\n\n/home/roman/Sources/c-utils/lib/binfmt.h:\n    4  #include \"typedefs.h\"\n    5  #include \"uint8.h\"\n    6: #include \"uint32.h\"\n    7  #include \"uint64.h\"\n    8  #include \"range.h\"\n    .\n   23    uint64 offs;\n   24    uint64 size;\n   25:   uint32 flags;\n   26  } binfmt_entry;\n   27  \n\n/home/roman/Sources/c-utils/lib/coff.h:\n    8  #include \"uint8.h\"\n    9  #include \"uint16.h\"\n   10: #include \"uint32.h\"\n   11  #include \"range.h\"\n   12  \n   ..\n   14    uint16 machine; /* machine_type */\n   15    uint16 number_of_sections;\n   16:   uint32 time_date_stamp;\n   17:   uint32 pointer_to_symbol_table;\n   18:   uint32 number_of_symbols;\n   19    uint16 size_of_optional_header;\n   20    uint16 characteristics; /* image_characteristics */\n   ..\n   76    char name[COFF_SECTION_NAME_SIZE]; /* TODO: Should we use char instead? */\n   77    union {\n   78:     uint32 physical_address; /* same value as next field */\n   79:     uint32 virtual_size;\n   80    };\n   81:   uint32 virtual_address;\n   82:   uint32 size_of_raw_data;\n   83:   uint32 pointer_to_raw_data;\n   84:   uint32 pointer_to_relocations; /* always zero in executables */\n   85:   uint32 pointer_to_linenumbers; /* deprecated */\n   86    uint16 number_of_relocations;\n   87    uint16 number_of_linenumbers; /* deprecated */\n   88:   uint32 characteristics;       /* section_characteristics */\n   89  }\n   90  coff_section_header;\n   ..\n  101    uint8 major_linker_version;\n  102    uint8 minor_linker_version;\n  103:   uint32 size_of_code;\n  104:   uint32 size_of_initialized_data;\n  105:   uint32 size_of_uninitialized_data;\n  106:   uint32 address_of_entry_point;\n  107:   uint32 base_of_code;\n  108:   uint32 base_of_data;\n  109  }\n  110  coff_opt_header;\n  ...\n  112  typedef struct __unaligned {\n  113    uint16 magic;\n  114:   uint32 vstamp; /* version of the compiler assembler */\n  115:   uint32 proc_type;\n  116:   uint32 rom_width_bits;\n  117:   uint32 ram_width_bits;\n  118  }\n  119  coff_opt_header_microchip;\n  ...\n  124  typedef struct __unaligned {\n  125    union {\n  126:     uint32 fname; // function name symbol table index, if Line == 0\n  127:     uint32 addr;  // section-relative address of code that corresponds to line\n  128    };\n  129    uint16 line; // line number\n  ...\n  141        char name[COFF_E_SYMNMLEN]; /* Symbol name (first 8 characters) */\n  142        struct {\n  143:         uint32 zeroes; /* Leading zeros */\n  144:         uint32 offset; /* Offset if this is a header section */\n  145        };\n  146      };\n  147  \n  148:     uint32 value; /* Value (address) of the segment */\n  149      uint16 scnum; /* Section number */\n  150      uint16 type;  /* Type of section */\n  ...\n  156    // Function definition\n  157    struct __unaligned {\n  158:     uint32 tag_index;                // Index to .bf entry\n  159:     uint32 code_size;                // Size of function code\n  160:     uint32 pointer_to_line_number;   // Pointer to line number entry\n  161:     uint32 pointer_to_next_function; // Symbol table index of next function\n  162      uint16 x_tvndx;                  // Unused\n  163    }\n  ...\n  166    // .bf abd .ef\n  167    struct __unaligned {\n  168:     uint32 unused1;\n  169      uint16 source_line_number; // Line number in source file\n  170      uint16 unused2;\n  171:     uint32 unused3;                  // Pointer to line number entry\n  172:     uint32 pointer_to_next_function; // Symbol table index of next function\n  173      uint16 unused4;                  // Unused\n  174    }\n  ...\n  177    // Weak external\n  178    struct __unaligned {\n  179:     uint32 tag_index;       // Symbol table index of alternative symbol2\n  180:     uint32 characteristics; //\n  181:     uint32 unused1;\n  182:     uint32 unused2;\n  183      uint16 unused3; // Unused\n  184    }\n  ...\n  193    // String table index\n  194    struct {         // MS COFF uses multiple aux records rather than a string table entry!\n  195:     uint32 zeroes; // zeroes if name file name longer than 18\n  196:     uint32 offset; // string table entry\n  197    } stringindex;\n  198  \n  199    // Section definition\n  200    struct __unaligned {\n  201:     uint32 length;\n  202      uint16 number_of_relocations; // Line number in source file\n  203      uint16 number_of_line_numbers;\n  204:     uint32 check_sum; // Pointer to line number entry\n  205      uint16 number;    // Symbol table index of next function\n  206      uint8 selection;  // Unused\n  ...\n  218      char name[COFF_SSYMBOL_NAME_MAX]; /* symbol name if less than 8 characters */\n  219      struct __unaligned {\n  220:       uint32 zeroes; /* first four characters are 0 */\n  221:       uint32 offset; /* pointer to the string table */\n  222      };\n  223    };\n  224  \n  225:   uint32 value; /* symbol value */\n  226    int16 scnum;  /* section number */\n  227:   uint32 type;  /* type */\n  228    int8 sclass;  /* storage class */\n  229    uint8 numaux; /* number of auxiliary symbols */\n  ...\n  282  \n  283  coff_section_header* coff_get_section(void*, uint16 index);\n  284: const char* coff_get_strtab(void*, uint32* szptr);\n  285: coff_symtab_entry* coff_get_symtab(void*, uint32* num);\n  286  coff_file_header* coff_header_file(void*);\n  287  coff_opt_header* coff_header_opt(void*);\n\n/home/roman/Sources/c-utils/lib/coff/coff_get_strtab.c:\n    2  \n    3  const char*\n    4: coff_get_strtab(void* coff, uint32* szptr) {\n    5    range syms = coff_symbol_table(coff);\n    6:   uint32 size = uint32_get(syms.end);\n    7    if(szptr)\n    8      *szptr = size;\n\n/home/roman/Sources/c-utils/lib/coff/coff_get_symtab.c:\n    2  \n    3  coff_symtab_entry*\n    4: coff_get_symtab(void* coff, uint32* num) {\n    5    coff_file_header* fhdr = coff_header_file(coff);\n    6  \n    7    if(num) {\n    8:     *num = uint32_get(&fhdr->number_of_symbols);\n    9    }\n   10:   return (coff_symtab_entry*)((char*)coff + uint32_get(&fhdr->pointer_to_symbol_table));\n   11  }\n   12  \n\n/home/roman/Sources/c-utils/lib/coff/coff_line_numbers.c:\n    5    range r;\n    6  \n    7:   r.start = (char*)coff + uint32_get(&shdr->pointer_to_linenumbers);\n    8    r.elem_size = 6;\n    9    r.end = r.start + r.elem_size * uint16_get(&shdr->number_of_linenumbers);\n\n/home/roman/Sources/c-utils/lib/coff/coff_symbol_table.c:\n    7    range r;\n    8  \n    9:   r.start = (char*)coff + uint32_get(&fhdr->pointer_to_symbol_table);\n   10    r.elem_size = fhdr->machine == COFF_FILE_MACHINE_MICROCHIP_V2 ? 20 : 18;\n   11:   r.end = r.start + r.elem_size * uint32_get(&fhdr->number_of_symbols);\n   12  \n   13    return r;\n\n/home/roman/Sources/c-utils/lib/dns/dns_random.c:\n    3  #include \"../dns.h\"\n    4  #include \"../taia.h\"\n    5: #include \"../uint32.h\"\n    6  \n    7  #if WINDOWS_NATIVE\n    .\n   13  #endif\n   14  \n   15: static uint32 seed[32];\n   16: static uint32 in[12];\n   17: static uint32 out[8];\n   18  static int outleft = 0;\n   19  \n   ..\n   23  static void\n   24  surf(void) {\n   25:   uint32 t[12];\n   26:   uint32 x;\n   27:   uint32 sum = 0;\n   28    int r;\n   29    int i;\n   ..\n   50    char tpack[16];\n   51  \n   52:   for(i = 0; i < 32; ++i) uint32_unpack(data + 4 * i, seed + i);\n   53  \n   54    taia_now(&t);\n   55    taia_pack(tpack, &t);\n   56:   for(i = 0; i < 4; ++i) uint32_unpack(tpack + 4 * i, in + 4 + i);\n   57  \n   58  #if WINDOWS_NATIVE\n\n/home/roman/Sources/c-utils/lib/elf.h:\n    4  #include \"uint8.h\"\n    5  #include \"uint16.h\"\n    6: #include \"uint32.h\"\n    7  #include \"uint64.h\"\n    8  #include \"range.h\"\n    .\n   24    uint16 e_type;                /* Object file type */\n   25    uint16 e_machine;             /* Architecture */\n   26:   uint32 e_version;             /* Object file version */\n   27:   uint32 e_entry;               /* Entry point virtual address */\n   28:   uint32 e_phoff;               /* Program header table file offset */\n   29:   uint32 e_shoff;               /* Section header table file offset */\n   30:   uint32 e_flags;               /* Processor-specific flags */\n   31    uint16 e_ehsize;              /* ELF header size in bytes */\n   32    uint16 e_phentsize;           /* Program header table entry size */\n   ..\n   42    uint16 e_type;                /* Object file type */\n   43    uint16 e_machine;             /* Architecture */\n   44:   uint32 e_version;             /* Object file version */\n   45    uint64 e_entry;               /* Entry point virtual address */\n   46    uint64 e_phoff;               /* Program header table file offset */\n   47    uint64 e_shoff;               /* Section header table file offset */\n   48:   uint32 e_flags;               /* Processor-specific flags */\n   49    uint16 e_ehsize;              /* ELF header size in bytes */\n   50    uint16 e_phentsize;           /* Program header table entry size */\n   ..\n  218  \n  219  typedef struct {\n  220:   uint32 sh_name;      /* Section name (string tbl index) */\n  221:   uint32 sh_type;      /* Section type */\n  222:   uint32 sh_flags;     /* Section flags */\n  223:   uint32 sh_addr;      /* Section virtual addr at execution */\n  224:   uint32 sh_offset;    /* Section file offset */\n  225:   uint32 sh_size;      /* Section size in bytes */\n  226:   uint32 sh_link;      /* Link to another section */\n  227:   uint32 sh_info;      /* Additional section information */\n  228:   uint32 sh_addralign; /* Section alignment */\n  229:   uint32 sh_entsize;   /* Entry size if section holds table */\n  230  } elf32_shdr;\n  231  \n  232  typedef struct {\n  233:   uint32 sh_name;      /* Section name (string tbl index) */\n  234:   uint32 sh_type;      /* Section type */\n  235    uint64 sh_flags;     /* Section flags */\n  236    uint64 sh_addr;      /* Section virtual addr at execution */\n  237    uint64 sh_offset;    /* Section file offset */\n  238    uint64 sh_size;      /* Section size in bytes */\n  239:   uint32 sh_link;      /* Link to another section */\n  240:   uint32 sh_info;      /* Additional section information */\n  241    uint64 sh_addralign; /* Section alignment */\n  242    uint64 sh_entsize;   /* Entry size if section holds table */\n  ...\n  314  \n  315  typedef struct __unaligned {\n  316:   uint32 st_name;  /* Symbol name (string tbl index) */\n  317:   uint32 st_value; /* Symbol value */\n  318:   uint32 st_size;  /* Symbol size */\n  319    uint8 st_info;   /* Symbol type and binding */\n  320    uint8 st_other;  /* Symbol visibility */\n  ...\n  324  \n  325  typedef struct __unaligned {\n  326:   uint32 st_name;  /* Symbol name (string tbl index) */\n  327    uint8 st_info;   /* Symbol type and binding */\n  328    uint8 st_other;  /* Symbol visibility */\n  ...\n  422  \n  423  typedef struct {\n  424:   uint32 r_offset; /* Address */\n  425:   uint32 r_info;   /* Relocation type and symbol index */\n  426  } elf32_rel;\n  427  \n  ...\n  439  \n  440  typedef struct {\n  441:   uint32 r_offset; /* Address */\n  442:   uint32 r_info;   /* Relocation type and symbol index */\n  443:   int32 r_addend;  /* Addend */\n  444  } elf32_rela;\n  445  \n  ...\n  463  \n  464  typedef struct {\n  465:   uint32 p_type;   /* Segment type */\n  466:   uint32 p_offset; /* Segment file offset */\n  467:   uint32 p_vaddr;  /* Segment virtual address */\n  468:   uint32 p_paddr;  /* Segment physical address */\n  469:   uint32 p_filesz; /* Segment size in file */\n  470:   uint32 p_memsz;  /* Segment size in memory */\n  471:   uint32 p_flags;  /* Segment flags */\n  472:   uint32 p_align;  /* Segment alignment */\n  473  } elf32_phdr;\n  474  \n  475  typedef struct {\n  476:   uint32 p_type;   /* Segment type */\n  477:   uint32 p_flags;  /* Segment flags */\n  478    uint64 p_offset; /* Segment file offset */\n  479    uint64 p_vaddr;  /* Segment virtual address */\n  ...\n  562  \n  563  typedef struct {\n  564:   int32 d_tag; /* Dynamic entry type */\n  565    union {\n  566:     uint32 d_val; /* Integer value */\n  567:     uint32 d_ptr; /* Address value */\n  568    } d_un;\n  569  } elf32_dyn;\n  ...\n  679  #define ELF_DT_AUXILIARY 0x7ffffffd /* Shared object to load before self */\n  680  #define ELF_DT_FILTER 0x7fffffff    /* Shared object to get values from */\n  681: #define ELF_DT_EXTRATAGIDX(tag) ((uint32) - ((int32)(tag) << 1 >> 1) - 1)\n  682  #define ELF_DT_EXTRANUM 3\n  683  \n  ...\n  724    uint16 vd_ndx;     /* Version Index */\n  725    uint16 vd_cnt;     /* Number of associated aux entries */\n  726:   uint32 vd_hash;    /* Version name hash value */\n  727:   uint32 vd_aux;     /* Offset in bytes to verdaux array */\n  728:   uint32 vd_next;    /* Offset in bytes to next verdef\n  729                  entry */\n  730  }\n  ...\n  736    uint16 vd_ndx;     /* Version Index */\n  737    uint16 vd_cnt;     /* Number of associated aux entries */\n  738:   uint32 vd_hash;    /* Version name hash value */\n  739:   uint32 vd_aux;     /* Offset in bytes to verdaux array */\n  740:   uint32 vd_next;    /* Offset in bytes to next verdef\n  741                  entry */\n  742  }\n  ...\n  761  \n  762  typedef struct {\n  763:   uint32 vda_name; /* Version or dependency names */\n  764:   uint32 vda_next; /* Offset in bytes to next verdaux\n  765                entry */\n  766  } elf32_verdaux;\n  767  \n  768  typedef struct {\n  769:   uint32 vda_name; /* Version or dependency names */\n  770:   uint32 vda_next; /* Offset in bytes to next verdaux\n  771                entry */\n  772  } elf64_verdaux;\n  ...\n  777    uint16 vn_version; /* Version of structure */\n  778    uint16 vn_cnt;     /* Number of associated aux entries */\n  779:   uint32 vn_file;    /* Offset of filename for this\n  780                  dependency */\n  781:   uint32 vn_aux;     /* Offset in bytes to vernaux array */\n  782:   uint32 vn_next;    /* Offset in bytes to next verneed\n  783                  entry */\n  784  }\n  ...\n  788    uint16 vn_version; /* Version of structure */\n  789    uint16 vn_cnt;     /* Number of associated aux entries */\n  790:   uint32 vn_file;    /* Offset of filename for this\n  791                  dependency */\n  792:   uint32 vn_aux;     /* Offset in bytes to vernaux array */\n  793:   uint32 vn_next;    /* Offset in bytes to next verneed\n  794                  entry */\n  795  }\n  ...\n  804  \n  805  typedef struct __unaligned {\n  806:   uint32 vna_hash;  /* Hash value of dependency name */\n  807    uint16 vna_flags; /* Dependency specific information */\n  808    uint16 vna_other; /* Unused */\n  809:   uint32 vna_name;  /* Dependency name string offset */\n  810:   uint32 vna_next;  /* Offset in bytes to next vernaux\n  811                 entry */\n  812  }\n  ...\n  814  \n  815  typedef struct __unaligned {\n  816:   uint32 vna_hash;  /* Hash value of dependency name */\n  817    uint16 vna_flags; /* Dependency specific information */\n  818    uint16 vna_other; /* Unused */\n  819:   uint32 vna_name;  /* Dependency name string offset */\n  820:   uint32 vna_next;  /* Offset in bytes to next vernaux\n  821                 entry */\n  822  }\n  ...\n  836  \n  837  typedef struct {\n  838:   int32 a_type; /* Entry type */\n  839    union {\n  840      long int a_val;      /* Integer value */\n  ...\n  908  \n  909  typedef struct {\n  910:   uint32 n_namesz; /* Length of the note's name.  */\n  911:   uint32 n_descsz; /* Length of the note's descriptor.  */\n  912:   uint32 n_type;   /* Type of the note.  */\n  913  } elf32_nhdr;\n  914  \n  915  typedef struct {\n  916:   uint32 n_namesz; /* Length of the note's name.  */\n  917:   uint32 n_descsz; /* Length of the note's descriptor.  */\n  918:   uint32 n_type;   /* Type of the note.  */\n  919  } elf64_nhdr;\n  920  \n  ...\n  952  typedef struct __unaligned {\n  953    uint64 m_value;   /* Symbol value.  */\n  954:   uint32 m_info;    /* Size and index.  */\n  955:   uint32 m_poffset; /* Symbol offset.  */\n  956    uint16 m_repeat;  /* Repeat count.  */\n  957    uint16 m_stride;  /* Stride info.  */\n  ...\n 1033  typedef union {\n 1034    struct {\n 1035:     uint32 gt_current_g_value; /* -G value used for compilation */\n 1036:     uint32 gt_unused;          /* Not used */\n 1037    } gt_header;                 /* First entry in section */\n 1038    struct {\n 1039:     uint32 gt_g_value; /* If this value were used for -G */\n 1040:     uint32 gt_bytes;   /* This many bytes would be used */\n 1041    } gt_entry;          /* Subsequent entries in section */\n 1042  } elf32_gptab;\n ....\n 1045  \n 1046  typedef struct {\n 1047:   uint32 ri_gprmask;    /* General registers used */\n 1048:   uint32 ri_cprmask[4]; /* Coprocessor registers used */\n 1049:   int32 ri_gp_value;    /* $gp register value */\n 1050  } elf32_reg_info;\n 1051  \n ....\n 1058    uint16 section; /* Section header index of section affected,\n 1059                0 for global options.  */\n 1060:   uint32 info;    /* Kind-specific information.  */\n 1061  }\n 1062  elf_options;\n ....\n 1104  \n 1105  typedef struct {\n 1106:   uint32 hwp_flags1; /* Extra flags.  */\n 1107:   uint32 hwp_flags2; /* Extra flags.  */\n 1108  } elf_options_hw;\n 1109  \n ....\n 1116  \n 1117  typedef struct {\n 1118:   uint32 l_name;       /* Name (string table index) */\n 1119:   uint32 l_time_stamp; /* Timestamp */\n 1120:   uint32 l_checksum;   /* Checksum */\n 1121:   uint32 l_version;    /* Interface version */\n 1122:   uint32 l_flags;      /* Flags */\n 1123  } elf32_lib;\n 1124  \n 1125  typedef struct {\n 1126:   uint32 l_name;       /* Name (string table index) */\n 1127:   uint32 l_time_stamp; /* Timestamp */\n 1128:   uint32 l_checksum;   /* Checksum */\n 1129:   uint32 l_version;    /* Interface version */\n 1130:   uint32 l_flags;      /* Flags */\n 1131  } elf64_lib;\n 1132  \n ....\n 1143  /* Entries found in sections of type ELF_SHT_MIPS_CONFLICT.  */\n 1144  \n 1145: typedef uint32 elf32_conflict;\n 1146  \n 1147  /* ARM specific declarations */\n ....\n 1268  int elf_section_find(void*, const char* sname);\n 1269  range elf_section_headers(void*);\n 1270: int elf_section_index(void*, uint32 sh_type);\n 1271  const char* elf_section_name(void*, int sn);\n 1272  void* elf_section_offset(void*, int sn);\n 1273  size_t elf_section_size(void*, int sn);\n 1274: const char* elf_section_typename(uint32);\n 1275  range elf_section(void*, void* shdr);\n 1276  const char* elf_shstrtab(void*);\n\n/home/roman/Sources/c-utils/lib/elf/elf_get_value.c:\n   17    switch(size) {\n   18      case 8: ret = uint64_read((const char*)&p[off]); break;\n   19:     case 4: ret = uint32_read((const char*)&p[off]); break;\n   20      case 2: ret = uint16_read((const char*)&p[off]); break;\n   21      case 1: ret = p[off]; break;\n\n/home/roman/Sources/c-utils/lib/elf/elf_section_find.c:\n    7    range r = elf_section_headers(elf);\n    8    void* section;\n    9:   uint32 i = 0;\n   10  \n   11    range_foreach(&r, section) {\n   12:     uint32 name = ELF_GET(elf, section, shdr, sh_name);\n   13  \n   14      if(str_equal(sname, &(elf_shstrtab(elf)[name])))\n\n/home/roman/Sources/c-utils/lib/elf/elf_section_index.c:\n    3  \n    4  int\n    5: elf_section_index(void* elf, uint32 sh_type) {\n    6    range r = elf_section_headers(elf);\n    7    void* section;\n    8:   uint32 i = 0;\n    9  \n   10    range_foreach(&r, section) {\n   11:     uint32 type = uint32_get(ELF_ADDR(elf, section, shdr, sh_type));\n   12  \n   13      if(type == sh_type)\n\n/home/roman/Sources/c-utils/lib/elf/elf_section_name.c:\n    4  elf_section_name(void* elf, int sn) {\n    5    range r = elf_section_headers(elf);\n    6:   uint32 idx = ELF_GET(elf, range_index(&r, sn), shdr, sh_name);\n    7    const char* name = &(elf_shstrtab(elf)[idx]);\n    8    return name;\n\n/home/roman/Sources/c-utils/lib/elf/elf_section_typename.c:\n    2  \n    3  const char*\n    4: elf_section_typename(uint32 sh_type) {\n    5    static const char* const types[] = {\"<0>\",\n    6                                        \"PROGBITS\",\n\n/home/roman/Sources/c-utils/lib/entities.h:\n    1: #include \"uint32.h\"\n    2  #include \"uint8.h\"\n    3  \n    4  const struct {\n    5:   uint32 tab[9854];\n    6    uint8 data[8115];\n    7  } entities = {\n\n/home/roman/Sources/c-utils/lib/fmt.h:\n    4  \n    5  #include \"typedefs.h\"\n    6: #include \"uint32.h\"\n    7  #include \"uint64.h\"\n    8  \n    .\n   93  #define FMT_ASN1TAG 19    /* enough space to hold 2^128 - 1 */\n   94  /* some variable length encodings for integers */\n   95: size_t fmt_utf8(char* dest, uint32 n);          /* can store 0 - 0x7fffffff */\n   96  size_t fmt_asn1derlength(char* dest, uint64 l); /* 0 - 0x7f: 1 byte, above that 1 + bytes_needed bytes */\n   97  size_t fmt_asn1dertag(char* dest, uint64 l);    /* 1 byte for each 7 bits; upper bit = more bytes coming */\n   ..\n  144  \n  145  #ifdef UINT32_H\n  146: size_t fmt_escapecharc(char* dest, uint32 ch);\n  147  \n  148: size_t fmt_escapecharshell(char* dest, uint32 ch);\n  149: size_t fmt_escapecharquotedshell(char*, uint32 ch);\n  150: size_t fmt_escapecharjson(char* dest, uint32 ch, char quote);\n  151  #endif\n  152  \n\n/home/roman/Sources/c-utils/lib/fmt/fmt_escapecharc.c:\n    1  #include \"../fmt.h\"\n    2: #include \"../uint32.h\"\n    3  #include <sys/types.h>\n    4  \n    .\n   13  \n   14  size_t\n   15: fmt_escapecharc(char* dest, uint32 ch) {\n   16    char c;\n   17    if(ch > 0xff)\n\n/home/roman/Sources/c-utils/lib/fmt/fmt_escapecharjson.c:\n    1  #include \"../fmt.h\"\n    2  #include \"../uint16.h\"\n    3: #include \"../uint32.h\"\n    4  \n    5  static void\n    .\n   15  \n   16  size_t\n   17: fmt_escapecharjson(char* dest, uint32 ch, char quote) {\n   18    size_t n;\n   19  \n   ..\n   21      quote = '\"';\n   22  \n   23:   if(ch != (uint32)(unsigned)quote) {\n   24      if(ch == '\\'' || ch == '\"') {\n   25        dest[0] = ch;\n\n/home/roman/Sources/c-utils/lib/fmt/fmt_escapecharquotedshell.c:\n    1  #include \"../fmt.h\"\n    2: #include \"../uint32.h\"\n    3  #include <sys/types.h>\n    4  \n    5  size_t\n    6: fmt_escapecharquotedshell(char* dest, uint32 ch) {\n    7    char c;\n    8    switch(ch) {\n\n/home/roman/Sources/c-utils/lib/fmt/fmt_escapecharshell.c:\n    1  #include \"../fmt.h\"\n    2: #include \"../uint32.h\"\n    3  #include <sys/types.h>\n    4  \n    .\n    6  \n    7  size_t\n    8: fmt_escapecharshell(char* dest, uint32 ch) {\n    9    char c;\n   10    if(ch > 0xff)\n\n/home/roman/Sources/c-utils/lib/fmt/fmt_utf8.c:\n    2  \n    3  size_t\n    4: fmt_utf8(char* dest, uint32 n) {\n    5    size_t i, j;\n    6    if(n <= 0x7f) {\n\n/home/roman/Sources/c-utils/lib/http.h:\n    3  \n    4  #include \"uint16.h\"\n    5: #include \"uint32.h\"\n    6  #include \"uint64.h\"\n    7  #include \"stralloc.h\"\n    .\n   19  \n   20  typedef struct http_request_s {\n   21:   uint32 serial;\n   22    http_req_t type;\n   23    stralloc location;\n\n/home/roman/Sources/c-utils/lib/http/http_get.c:\n   23    char ip[FMT_IP4];\n   24    stralloc dns;\n   25:   uint32 serial = 0;\n   26    size_t len = str_len(location);\n   27    h->tls = len >= 5 && !byte_diff(location, 5, \"https\");\n\n/home/roman/Sources/c-utils/lib/ihex.h:\n    4  #include \"uint8.h\"\n    5  #include \"uint16.h\"\n    6: #include \"uint32.h\"\n    7  #include \"slist.h\"\n    8  \n    .\n   26  ssize_t ihex_load_buf(ihex_file* ihf, const char* in, size_t n);\n   27  ssize_t ihex_load_record(ihex_record** pihr, const char* in, size_t n);\n   28: size_t ihex_read_at(ihex_file* ihf, uint32 at, char* x, size_t n);\n   29  ssize_t ihex_read_record(ihex_record** pihr, const char* in, size_t n);\n   30: ihex_record* ihex_record_at(ihex_file* ihf, uint32 at, uint32* roffs);\n   31  \n   32  #endif /* IHEX_H_ */\n\n/home/roman/Sources/c-utils/lib/ihex/ihex_read_at.c:\n    1  #include \"../ihex.h\"\n    2  #include \"../slist.h\"\n    3: #include \"../uint32.h\"\n    4  #include \"../byte.h\"\n    5  \n    6  size_t\n    7: ihex_read_at(ihex_file* ihf, uint32 at, char* x, size_t n) {\n    8    ihex_record* rec;\n    9    char* start = x;\n   10    union {\n   11:     uint32 off32;\n   12      struct {\n   13        uint16 lo16;\n   ..\n   17  \n   18    if((rec = ihex_record_at(ihf, at, &o.off32))) {\n   19:     uint32 p = at - o.off32;\n   20:     uint32 end;\n   21  \n   22      while(rec && n > 0) {\n\n/home/roman/Sources/c-utils/lib/ihex/ihex_record_at.c:\n    1  #include \"../ihex.h\"\n    2  #include \"../slist.h\"\n    3: #include \"../uint32.h\"\n    4  \n    5  ihex_record*\n    6: ihex_record_at(ihex_file* ihf, uint32 at, uint32* roffs) {\n    7    union {\n    8      ihex_record* rec;\n    .\n   10    } it;\n   11    union {\n   12:     uint32 off32;\n   13      struct {\n   14        uint16 lo16;\n\n/home/roman/Sources/c-utils/lib/io/io_passfd.c:\n   43  struct cmsghdr {\n   44    size_t cmsg_len;    /* data byte count, including hdr */\n   45:   int32_t cmsg_level; /* originating protocol */\n   46:   int32_t cmsg_type;  /* protocol-specific type */\n   47  };\n   48  #endif\n\n/home/roman/Sources/c-utils/lib/ip4.h:\n    7  #include \"uint8.h\"\n    8  #include \"uint16.h\"\n    9: #include \"uint32.h\"\n   10  \n   11  #ifdef __cplusplus\n   ..\n   17    /** 32-bit IPv4 address, represented as 4 8-bit \\c unsigned \\c chars. */\n   18    uint8 addr[4];\n   19:   uint32 iaddr;\n   20  } ipv4addr;\n   21  /** IPv4 port number. */\n\n/home/roman/Sources/c-utils/lib/ip6.h:\n    4  \n    5  #include \"byte.h\"\n    6: #include \"uint32.h\"\n    7  \n    8  #ifdef __cplusplus\n    .\n   14  size_t fmt_ip6c(char* dest, const char* ip);\n   15  \n   16: size_t scan_ip6if(const char* src, char* ip, uint32* scope_id);\n   17: size_t fmt_ip6if(char* dest, const char* ip, uint32 scope_id);\n   18: size_t fmt_ip6ifc(char* dest, const char* ip, uint32 scope_id);\n   19  \n   20  size_t scan_ip6_flat(const char* src, char*);\n\n/home/roman/Sources/c-utils/lib/macho.h:\n    4  #include \"uint8.h\"\n    5  #include \"uint16.h\"\n    6: #include \"uint32.h\"\n    7  #include \"uint64.h\"\n    8  \n    .\n  356  \n  357  typedef struct macho_fat_header {\n  358:   uint32 magic;\n  359:   uint32 nfat_arch;\n  360  } macho_fat_header;\n  361  \n  ...\n  363    cpu_type_t cputype;\n  364    cpu_subtype_t cpusubtype;\n  365:   uint32 offset;\n  366:   uint32 size;\n  367:   uint32 align;\n  368  } macho_fat_arch;\n  369  \n  370  typedef struct macho_mach_header_magic {\n  371:   uint32 magic;\n  372  } macho_mach_header_magic;\n  373  \n  374  typedef struct macho_mach_header {\n  375:   uint32 magic;\n  376    cpu_type_t cputype;\n  377    cpu_subtype_t cpusubtype;\n  378:   uint32 filetype;\n  379:   uint32 ncmds;\n  380:   uint32 sizeofcmds;\n  381:   uint32 flags;\n  382  } macho_mach_header;\n  383  \n  384  typedef struct macho_mach_header_64 {\n  385:   uint32 magic;             /* mach magic number identifier */\n  386    cpu_type_t cputype;       /* cpu specifier */\n  387    cpu_subtype_t cpusubtype; /* machine specifier */\n  388:   uint32 filetype;          /* type of file */\n  389:   uint32 ncmds;             /* number of load commands */\n  390:   uint32 sizeofcmds;        /* the size of all the load commands */\n  391:   uint32 flags;             /* flags */\n  392:   uint32 reserved;          /* reserved */\n  393  } macho_mach_header_64;\n  394  \n  395  typedef struct macho_load_command {\n  396:   uint32 cmd;\n  397:   uint32 cmdsize;\n  398  } macho_load_command;\n  399  \n  400  typedef struct macho_segment_command {\n  401:   uint32 cmd;\n  402:   uint32 cmdsize;\n  403    char segname[16];\n  404:   uint32 vmaddr;\n  405:   uint32 vmsize;\n  406:   uint32 fileoff;\n  407:   uint32 filesize;\n  408    vm_prot_t maxprot;\n  409    vm_prot_t initprot;\n  410:   uint32 nsects;\n  411:   uint32 flags;\n  412  } macho_segment_command;\n  413  \n  414  typedef struct macho_segment_command_64 { /* for 64-bit architectures */\n  415:   uint32 cmd;                             /* LC_SEGMENT_64 */\n  416:   uint32 cmdsize;                         /* includes sizeof macho_section_64 structs */\n  417    char segname[16];                       /* segment name */\n  418    uint64 vmaddr;                          /* memory address of this segment */\n  ...\n  422    vm_prot_t maxprot;                      /* maximum VM protection */\n  423    vm_prot_t initprot;                     /* initial VM protection */\n  424:   uint32 nsects;                          /* number of sections in segment */\n  425:   uint32 flags;                           /* flags */\n  426  } macho_segment_command_64;\n  427  \n  ...\n  429    char sectname[16];\n  430    char segname[16];\n  431:   uint32 addr;\n  432:   uint32 size;\n  433:   uint32 offset;\n  434:   uint32 align;\n  435:   uint32 reloff;\n  436:   uint32 nreloc;\n  437:   uint32 flags;\n  438:   uint32 reserved1;\n  439:   uint32 reserved2;\n  440  } macho_section;\n  441  \n  ...\n  445    uint64 addr;                    /* memory address of this macho_section */\n  446    uint64 size;                    /* size in bytes of this macho_section */\n  447:   uint32 offset;                  /* file offset of this macho_section */\n  448:   uint32 align;                   /* macho_section alignment (power of 2) */\n  449:   uint32 reloff;                  /* file offset of relocation entries */\n  450:   uint32 nreloc;                  /* number of relocation entries */\n  451:   uint32 flags;                   /* flags (macho_section type and attributes)*/\n  452:   uint32 reserved1;               /* reserved (for offset or index) */\n  453:   uint32 reserved2;               /* reserved (for count or sizeof) */\n  454:   uint32 reserved3;               /* reserved */\n  455  } macho_section_64;\n  456  \n  457  union lc_str {\n  458:   uint32 offset;\n  459  #ifndef __LP64__\n  460    char* ptr;\n  ...\n  463  \n  464  typedef struct macho_symtab_command {\n  465:   uint32 cmd;\n  466:   uint32 cmdsize;\n  467:   uint32 symoff;\n  468:   uint32 nsyms;\n  469:   uint32 stroff;\n  470:   uint32 strsize;\n  471  } macho_symtab_command;\n  472  \n  473  typedef struct macho_dylib {\n  474    union lc_str name;\n  475:   uint32 timestamp;\n  476:   uint32 current_version;\n  477:   uint32 compatibility_version;\n  478  } macho_dylib;\n  479  \n  480  typedef struct macho_dylib_command {\n  481:   uint32 cmd;\n  482:   uint32 cmdsize;\n  483    macho_dylib dylib;\n  484  } macho_dylib_command;\n  485  \n  486  typedef struct macho_dylinker_command {\n  487:   uint32 cmd;\n  488:   uint32 cmdsize;\n  489    union lc_str name;\n  490  } macho_dylinker_command;\n  491  \n  492  typedef struct macho_dysymtab_command {\n  493:   uint32 cmd;\n  494:   uint32 cmdsize;\n  495:   uint32 ilocalsym;\n  496:   uint32 nlocalsym;\n  497:   uint32 iextdefsym;\n  498:   uint32 nextdefsym;\n  499:   uint32 iundefsym;\n  500:   uint32 nundefsym;\n  501:   uint32 tocoff;\n  502:   uint32 ntoc;\n  503:   uint32 modtaboff;\n  504:   uint32 nmodtab;\n  505:   uint32 extrefsymoff;\n  506:   uint32 nextrefsyms;\n  507:   uint32 indirectsymoff;\n  508:   uint32 nindirectsyms;\n  509:   uint32 extreloff;\n  510:   uint32 nextrel;\n  511:   uint32 locreloff;\n  512:   uint32 nlocrel;\n  513  } macho_dysymtab_command;\n  514  \n  515  typedef struct macho_dylib_table_of_contents {\n  516:   uint32 symbol_index;\n  517:   uint32 module_index;\n  518  } macho_dylib_table_of_contents;\n  519  \n  520  typedef struct macho_dylib_module {\n  521:   uint32 module_name;\n  522:   uint32 iextdefsym;\n  523:   uint32 nextdefsym;\n  524:   uint32 irefsym;\n  525:   uint32 nrefsym;\n  526:   uint32 ilocalsym;\n  527:   uint32 nlocalsym;\n  528:   uint32 iextrel;\n  529:   uint32 nextrel;\n  530:   uint32 iinit_iterm;\n  531:   uint32 ninit_nterm;\n  532:   uint32 objc_module_info_addr;\n  533:   uint32 objc_module_info_size;\n  534  } macho_dylib_module;\n  535  \n  536  typedef struct macho_twolevel_hints_command {\n  537:   uint32 cmd;\n  538:   uint32 cmdsize;\n  539:   uint32 offset;\n  540:   uint32 nhints;\n  541  } macho_twolevel_hints_command;\n  542  \n  543  typedef struct macho_nlist {\n  544:   uint32 n_strx;\n  545    uint8 n_type;\n  546    uint8 n_sect;\n\n/home/roman/Sources/c-utils/lib/open/open_temp.c:\n    4  #include \"../open.h\"\n    5  #include \"../str.h\"\n    6: #include \"../uint32.h\"\n    7  \n    8  #if WINDOWS_NATIVE\n    .\n   68  \n   69    for(;;) {\n   70:     random = uint32_random();\n   71  \n   72      for(i = 0; i < 6; ++i) {\n\n/home/roman/Sources/c-utils/lib/pe.h:\n    4  #include \"typedefs.h\"\n    5  #include \"uint64.h\"\n    6: #include \"uint32.h\"\n    7  #include \"uint16.h\"\n    8  #include \"uint8.h\"\n    .\n   13  \n   14  typedef struct {\n   15:   uint32 virtual_address;\n   16:   uint32 size;\n   17  } pe_data_directory;\n   18  \n   19  typedef struct __unaligned {\n   20:   uint32 characteristics;     /**< 0x00 */\n   21:   uint32 time_date_stamp;     /**< 0x04 */\n   22    uint16 major_version;       /**< 0x08 */\n   23    uint16 minor_version;       /**< 0x0a */\n   24:   uint32 name;                /**< 0x0c */\n   25:   uint32 base;                /**< 0x10 */\n   26:   uint32 number_of_functions; /**< 0x14 */\n   27:   uint32 number_of_names;     /**< 0x18 */\n   28:   uint32 address_of_functions;\n   29:   uint32 address_of_names;\n   30:   uint32 address_of_name_ordinals;\n   31  }\n   32  pe_export_directory;\n   33  \n   34  typedef struct __unaligned {\n   35:   uint32 characteristics;\n   36:   uint32 time_date_stamp;\n   37    uint16 major_version;\n   38    uint16 minor_version;\n   ..\n   44    union {\n   45      struct {\n   46:       uint32 name_offset : 31;\n   47:       uint32 name_is_string : 1;\n   48      };\n   49:     uint32 name;\n   50      uint16 id;\n   51    };\n   52    union {\n   53:     uint32 offset_to_data;\n   54      struct {\n   55:       uint32 offset_to_directory : 31;\n   56:       uint32 data_is_directory : 1;\n   57      };\n   58    };\n   ..\n   73  \n   74  typedef struct __unaligned {\n   75:   uint32 offset_to_data;\n   76:   uint32 size;\n   77:   uint32 code_page;\n   78:   uint32 reserved;\n   79  }\n   80  pe_resource_data_entry;\n   81  \n   82  typedef struct __unaligned {\n   83:   uint32 size;\n   84:   uint32 time_date_stamp;\n   85    uint16 major_version;\n   86    uint16 minor_version;\n   87:   uint32 global_flags_clear;\n   88:   uint32 global_flags_set;\n   89:   uint32 critical_section_default_timeout;\n   90:   uint32 de_commit_free_block_threshold;\n   91:   uint32 de_commit_total_free_threshold;\n   92:   uint32 lock_prefix_table;\n   93:   uint32 maximum_allocation_size;\n   94:   uint32 virtual_memory_threshold;\n   95:   uint32 process_heap_flags;\n   96:   uint32 process_affinity_mask;\n   97    uint16 csd_version;\n   98    uint16 reserved1;\n   99:   uint32 edit_list;\n  100:   uint32 security_cookie;\n  101:   uint32 se_handler_table;\n  102:   uint32 se_handler_count;\n  103  }\n  104  pe32_load_config_directory;\n  105  \n  106  typedef struct __unaligned {\n  107:   uint32 size;\n  108:   uint32 time_date_stamp;\n  109    uint16 major_version;\n  110    uint16 minor_version;\n  111:   uint32 global_flags_clear;\n  112:   uint32 global_flags_set;\n  113:   uint32 critical_section_default_timeout;\n  114    uint64 de_commit_free_block_threshold;\n  115    uint64 de_commit_total_free_threshold;\n  ...\n  118    uint64 virtual_memory_threshold;\n  119    uint64 process_affinity_mask;\n  120:   uint32 process_heap_flags;\n  121    uint16 csd_version;\n  122    uint16 reserved1;\n  ...\n  129  \n  130  typedef struct __unaligned {\n  131:   uint32 characteristics;\n  132:   uint32 time_date_stamp;\n  133    uint16 major_version;\n  134    uint16 minor_version;\n  ...\n  139  \n  140  typedef struct __unaligned {\n  141:   uint32 characteristics;\n  142:   uint32 time_date_stamp;\n  143    uint16 major_version;\n  144    uint16 minor_version;\n  145:   uint32 type;\n  146:   uint32 size_of_data;\n  147:   uint32 address_of_raw_data;\n  148:   uint32 pointer_to_raw_data;\n  149  }\n  150  pe_debug_directory;\n  ...\n  155    uint64 address_of_index;\n  156    uint64 address_of_call_backs;\n  157:   uint32 size_of_zero_fill;\n  158:   uint32 characteristics;\n  159  }\n  160  pe64_tls_directory;\n  161  \n  162  typedef struct __unaligned {\n  163:   uint32 start_address_of_raw_data;\n  164:   uint32 end_address_of_raw_data;\n  165:   uint32 address_of_index;\n  166:   uint32 address_of_call_backs;\n  167:   uint32 size_of_zero_fill;\n  168:   uint32 characteristics;\n  169  }\n  170  pe32_tls_directory;\n  ...\n  172  typedef struct {\n  173    union {\n  174:     uint32 characteristics;\n  175:     uint32 original_first_thunk;\n  176    };\n  177:   uint32 time_date_stamp;\n  178:   uint32 forwarder_chain;\n  179:   uint32 name;\n  180:   uint32 first_thunk;\n  181  } pe_import_descriptor;\n  182  \n  ...\n  188  typedef struct {\n  189    union {\n  190:     uint32 all_attributes;\n  191      struct {\n  192        int rva_based : 1;\n  ...\n  194      };\n  195    } attributes;\n  196:   uint32 dll_name_rva;\n  197:   uint32 module_handle_rva;\n  198:   uint32 import_address_table_rva;\n  199:   uint32 import_name_table_rva;\n  200:   uint32 bound_import_address_table_rva;\n  201:   uint32 unload_information_table_rva;\n  202:   uint32 time_date_stamp;\n  203  } pe_delayload_descriptor;\n  204  \n  ...\n  222    uint16 e_oeminfo;\n  223    uint16 e_res2[10];\n  224:   uint32 e_lfanew; /* sizeof(image_dos_h_eader) + size of MS-DOS stub */\n  225  }\n  226  pe_dos_header;\n  ...\n  229    uint16 machine; /* machine_type */\n  230    uint16 number_of_sections;\n  231:   uint32 time_date_stamp;\n  232:   uint32 pointer_to_symbol_table;\n  233:   uint32 number_of_symbols;\n  234    uint16 size_of_optional_header;\n  235    uint16 characteristics; /* image_characteristics */\n  ...\n  242    char name[PE_SECTION_NAME_SIZE]; /* TODO: Should we use char instead? */\n  243    union {\n  244:     uint32 physical_address; /* same value as next field */\n  245:     uint32 virtual_size;\n  246    };\n  247:   uint32 virtual_address;\n  248:   uint32 size_of_raw_data;\n  249:   uint32 pointer_to_raw_data;\n  250:   uint32 pointer_to_relocations; /* always zero in executables */\n  251:   uint32 pointer_to_linenumbers; /* deprecated */\n  252    uint16 number_of_relocations;\n  253    uint16 number_of_linenumbers; /* deprecated */\n  254:   uint32 characteristics;       /* section_characteristics */\n  255  }\n  256  pe_section_header;\n  ...\n  294    unsigned char major_linker_version;\n  295    unsigned char minor_linker_version;\n  296:   uint32 size_of_code;\n  297:   uint32 size_of_initialized_data;\n  298:   uint32 size_of_uninitialized_data;\n  299:   uint32 address_of_entry_point;\n  300:   uint32 base_of_code;\n  301:   uint32 base_of_data; /* only in PE32 */\n  302:   uint32 image_base;\n  303:   uint32 section_alignment;\n  304:   uint32 file_alignment;\n  305    uint16 major_operating_system_version;\n  306    uint16 minor_operating_system_version;\n  ...\n  309    uint16 major_subsystem_version;\n  310    uint16 minor_subsystem_version;\n  311:   uint32 reserved1;\n  312:   uint32 size_of_image;\n  313:   uint32 size_of_headers;\n  314:   uint32 checksum;\n  315    uint16 subsystem; /* windows_subsystem */\n  316    uint16 dll_characteristics;\n  317:   uint32 size_of_stack_reserve;\n  318:   uint32 size_of_stack_commit;\n  319:   uint32 size_of_heap_reserve;\n  320:   uint32 size_of_heap_commit;\n  321:   uint32 loader_flags;\n  322:   uint32 number_of_rva_and_sizes;\n  323    pe_data_directory data_directory[PE_NUMBEROF_DIRECTORY_ENTRIES];\n  324  }\n  ...\n  329    unsigned char major_linker_version;\n  330    unsigned char minor_linker_version;\n  331:   uint32 size_of_code;\n  332:   uint32 size_of_initialized_data;\n  333:   uint32 size_of_uninitialized_data;\n  334:   uint32 address_of_entry_point;\n  335:   uint32 base_of_code;\n  336    uint64 image_base;\n  337:   uint32 section_alignment;\n  338:   uint32 file_alignment;\n  339    uint16 major_operating_system_version;\n  340    uint16 minor_operating_system_version;\n  ...\n  343    uint16 major_subsystem_version;\n  344    uint16 minor_subsystem_version;\n  345:   uint32 reserved1;\n  346:   uint32 size_of_image;\n  347:   uint32 size_of_headers;\n  348:   uint32 checksum;\n  349    uint16 subsystem; /* windows_subsystem */\n  350    uint16 dll_characteristics;\n  ...\n  353    uint64 size_of_heap_reserve;\n  354    uint64 size_of_heap_commit;\n  355:   uint32 loader_flags; /* must be zero */\n  356:   uint32 number_of_rva_and_sizes;\n  357    pe_data_directory data_directory[PE_NUMBEROF_DIRECTORY_ENTRIES];\n  358  }\n  ...\n  361  typedef struct __unaligned {\n  362    pe_dos_header dos_hdr;\n  363:   uint32 signature;\n  364    pe_coff_header* coff_hdr;\n  365    void* optional_hdr_ptr;\n  366:   uint32 num_directories;\n  367    void* directories_ptr;\n  368    uint16 num_sections;\n  ...\n  417    char name[PE_SIZEOF_SHORT_NAME];\n  418    union {\n  419:     uint32 physical_address;\n  420:     uint32 virtual_size;\n  421    } misc;\n  422:   uint32 virtual_address;\n  423:   uint32 size_of_raw_data;\n  424:   uint32 pointer_to_raw_data;\n  425:   uint32 pointer_to_relocations;\n  426:   uint32 pointer_to_linenumbers;\n  427    uint16 number_of_relocations;\n  428    uint16 number_of_linenumbers;\n  429:   uint32 characteristics;\n  430  }\n  431  section_header;\n  ...\n  442  typedef struct {\n  443    union {\n  444:     uint32 forwarder_string;\n  445:     uint32 function;\n  446:     uint32 ordinal;\n  447:     uint32 address_of_data;\n  448    } u1;\n  449  } pe_thunk_data32;\n  ...\n  451  // typedef struct {\n  452  //  union {\n  453: //    uint32 characteristics;\n  454: //    uint32 original_first_thunk;\n  455  //  };\n  456: //  uint32 time_date_stamp;\n  457  //\n  458: //  uint32 forwarder_chain;\n  459: //  uint32 name;\n  460: //  uint32 first_thunk;\n  461  //} pe_import_descriptor;\n  462  \n  463  typedef struct __unaligned {\n  464:   uint32 signature;\n  465    pe_coff_header coff_header;\n  466    pe64_opt_header optional_header;\n  ...\n  469  \n  470  typedef struct {\n  471:   uint32 signature;\n  472    pe_coff_header coff_header;\n  473    pe32_opt_header optional_header;\n  ...\n  482    uint16 number_of_sections;    /* 0x28 (ULONG) */\n  483    pe_section_header* sections;  /* 0x30 (pe_section_header) */\n  484:   uint32 characteristics;       /* 0x38 (ULONG) */\n  485    char f_system_image;          /* 0x3c (BOOLEAN) */\n  486    char fdos_image;              /* 0x3d (BOOLEAN) */\n  ...\n  558  void* pe_header_nt(void*);\n  559  void* pe_header_opt(void*);\n  560: int pe_rva2section(void* base, uint32 rva);\n  561: int64 pe_rva2offset(void*, uint32 rva);\n  562: void* pe_rva2ptr(void*, uint32 rva);\n  563: uint32 pe_header_sig(void*);\n  564: uint32 pe_offset2rva(uint8*, int64 off);\n  565  uint64 pe_thunk(void*, void* ptr, int64 index);\n  566  pe_coff_header* pe_header_coff(void*);\n  ...\n  572  pe_data_directory* pe_header_datadir(void*);\n  573  pe_section_header* pe_header_sections(void*, uint16* nsections);\n  574: pe_data_directory* pe_get_datadir(void*, uint32* num);\n  575  const char* pe_datadir_name(int);\n  576  char* pe_dllname(uint8*);\n\n/home/roman/Sources/c-utils/lib/pe/pe_dllname.c:\n    7      pe_data_directory* data_dir = &pe_header_datadir(base)[PE_DIRECTORY_ENTRY_EXPORT];\n    8      pe_export_directory* export_dir = pe_rva2ptr(base, data_dir->virtual_address);\n    9:     return pe_rva2ptr(base, uint32_get(&export_dir->name));\n   10    }\n   11    return NULL;\n\n/home/roman/Sources/c-utils/lib/pe/pe_get_datadir.c:\n    2  \n    3  pe_data_directory*\n    4: pe_get_datadir(void* pe, uint32* num) {\n    5    char* opthdr = (char*)pe_header_opt(pe);\n    6  \n    7    if(num)\n    8:     *num = uint32_get(PE_ADDR(pe, opthdr, opt_header, number_of_rva_and_sizes));\n    9  \n   10    return (pe_data_directory*)(opthdr + PE_OFFSET(pe, opt_header, data_directory));\n\n/home/roman/Sources/c-utils/lib/pe/pe_get_value.c:\n   17    switch(size) {\n   18      case 8: ret = uint64_get(&p[off]); break;\n   19:     case 4: ret = uint32_get(&p[off]); break;\n   20      case 2: ret = uint16_get(&p[off]); break;\n   21      case 1: ret = p[off]; break;\n\n/home/roman/Sources/c-utils/lib/pe/pe_header.c:\n    6  pe_header_nt(void* pe) {\n    7    pe_dos_header* dos = (pe_dos_header*)pe;\n    8:   uint32 lfanew;\n    9:   lfanew = uint32_get(&dos->e_lfanew);\n   10    return (unsigned char*)dos + lfanew;\n   11  }\n   12  \n   13: uint32\n   14  pe_header_sig(void* pe) {\n   15:   return *(uint32*)pe_header_nt(pe);\n   16  }\n   17  \n   ..\n   28  pe_coff_header*\n   29  pe_header_coff(void* pe) {\n   30:   uint32* sign = (uint32*)pe_header_nt(pe);\n   31    return (pe_coff_header*)&sign[1];\n   32  }\n\n/home/roman/Sources/c-utils/lib/pe/pe_offset2rva.c:\n    1  #include \"../pe.h\"\n    2: #include \"../uint32.h\"\n    3  \n    4: uint32\n    5  pe_offset2rva(uint8* base, int64 off) {\n    6    uint16 i, n;\n    7    pe_section_header* sections = pe_header_sections(base, &n);\n    8  \n    9:   if((uint32)off < sections[0].pointer_to_raw_data)\n   10      return off;\n   11  \n   12    for(i = 0; i < n; i++) {\n   13:     uint32 start, size;\n   14:     start = uint32_get(&sections[i].pointer_to_raw_data);\n   15:     size = uint32_get(&sections[i].size_of_raw_data);\n   16  \n   17:     if((uint32)off >= start && (uint32)off < start + size)\n   18:       return (uint32)off - start + sections[i].virtual_address;\n   19    }\n   20    return 0;\n\n/home/roman/Sources/c-utils/lib/pe/pe_rva2offset.c:\n    2  \n    3  int64\n    4: pe_rva2offset(void* base, uint32 rva) {\n    5    int i;\n    6    pe_section_header* sections;\n\n/home/roman/Sources/c-utils/lib/pe/pe_rva2ptr.c:\n    2  \n    3  void*\n    4: pe_rva2ptr(void* base, uint32 rva) {\n    5    int64 off = pe_rva2offset(base, rva);\n    6    if(off == -1)\n\n/home/roman/Sources/c-utils/lib/pe/pe_rva2section.c:\n    2  \n    3  int\n    4: pe_rva2section(void* base, uint32 rva) {\n    5    uint16 i, n;\n    6    pe_section_header* sections = pe_header_sections(base, &n);\n    .\n   10  \n   11    for(i = 0; i < n; i++) {\n   12:     uint32 start = sections[i].virtual_address;\n   13:     uint32 end = start + sections[i].size_of_raw_data;\n   14  \n   15      if(rva >= start && rva < end)\n\n/home/roman/Sources/c-utils/lib/pe/pe_thunk.c:\n    6    switch(PE_TYPE(pe)) {\n    7      case PE_MAGIC_PE32: {\n    8:       uint32 u = uint32_get(((uint32*)ptr + index));\n    9        ret = ((uint64)(u & 0x80000000) << 32) | (u & 0x7fffffff);\n   10        break;\n\n/home/roman/Sources/c-utils/lib/playlist.h:\n    6  \n    7  #include \"stralloc.h\"\n    8: #include \"uint32.h\"\n    9  #include \"buffer.h\"\n   10  \n   ..\n   15  struct playlist;\n   16  \n   17: typedef void(playlist_callback)(struct playlist*, stralloc* title, stralloc* path, uint32 len);\n   18  typedef playlist_callback* playlist_callback_ptr;\n   19  \n   ..\n   28    stralloc title;\n   29    stralloc path;\n   30:   uint32 length;\n   31  } playlist_entry;\n   32  \n\n/home/roman/Sources/c-utils/lib/playlist/playlist_pls.c:\n   39        }\n   40        /*\n   41:       uint32 index = 8;\n   42        index += scan_ulong(&line.s[index], &len);\n   43        entry.length = len;\n\n/home/roman/Sources/c-utils/lib/playlist/playlist_xspf.c:\n   12    stralloc tag;\n   13    stralloc title, location;\n   14:   uint32 length;\n   15    playlist* pl;\n   16  } track;\n\n/home/roman/Sources/c-utils/lib/process/process_create.c:\n    8  #include \"../wait.h\"\n    9  #include \"../str.h\"\n   10: #include \"../uint32.h\"\n   11  \n   12  #if WINDOWS_NATIVE\n   ..\n   58  process_create(const char* filename, const char* argv[], fd_t std[3], const char* cwd) {\n   59    fd_t fds[3];\n   60:   int32 pid;\n   61    int status = 0;\n   62  \n\n/home/roman/Sources/c-utils/lib/rangecheck.h:\n    4  \n    5  #include \"typedefs.h\"\n    6: #include \"uint32.h\"\n    7  \n    8  #ifdef __cplusplus\n\n/home/roman/Sources/c-utils/lib/safemult.h:\n    4  \n    5  #include \"uint16.h\"\n    6: #include \"uint32.h\"\n    7  #include \"uint64.h\"\n    8  \n    .\n   32  \n   33  static inline int\n   34: umult32(uint32 a, uint32 b, uint32* c) {\n   35    return !__builtin_mul_overflow(a, b, c);\n   36  }\n   37  static inline int\n   38: imult32(int32 a, int32 b, int32* c) {\n   39    return !__builtin_mul_overflow(a, b, c);\n   40  }\n   ..\n   55  int imult16(int16 a, int16 b, int16* c);\n   56  \n   57: int umult32(uint32 a, uint32 b, uint32* c);\n   58: int imult32(int32 a, int32 b, int32* c);\n   59  \n   60  int umult64(uint64 a, uint64 b, uint64* c);\n\n/home/roman/Sources/c-utils/lib/safemult/imult16.c:\n   15  int\n   16  imult16(int16 a, int16 b, int16* c) {\n   17:   int32 x = (int32)a * b;\n   18    if((int16)x != x)\n   19      return 0;\n\n/home/roman/Sources/c-utils/lib/safemult/imult32.c:\n    4  #if defined(__GNUC__) && (__GNUC__ >= 5)\n    5  \n    6: #include \"../uint32.h\"\n    7  \n    8  int\n    9: imult32(int32 a, int32 b, int32* c) {\n   10    return !__builtin_mul_overflow(a, b, c);\n   11  }\n   ..\n   14  \n   15  int\n   16: imult32(int32 a, int32 b, int32* c) {\n   17    int64 x = (int64)a * b;\n   18:   if((int32)x != x)\n   19      return 0;\n   20    *c = x;\n\n/home/roman/Sources/c-utils/lib/safemult/range_str4inbuf.c:\n    6  int\n    7  range_str4inbuf(const void* buf, size_t len, const void* stringstart) {\n    8:   const uint32* x;\n    9:   const uint32* y;\n   10:   if(!range_ptrinbuf(buf, len, x = (const uint32*)stringstart))\n   11      return 0;\n   12:   y = (const uint32*)((char*)x + len);\n   13    for(; x + 1 <= y && *x; ++x)\n   14      ;\n\n/home/roman/Sources/c-utils/lib/safemult/umult32.c:\n    4  #if defined(__GNUC__) && (__GNUC__ >= 5)\n    5  \n    6: #include \"../uint32.h\"\n    7  #include \"../uint64.h\"\n    8  \n    9  int\n   10: umult32(uint32 a, uint32 b, uint32* c) {\n   11    return !__builtin_mul_overflow(a, b, c);\n   12  }\n   ..\n   15  \n   16  int\n   17: umult32(uint32 a, uint32 b, uint32* c) {\n   18    uint64 x = (uint64)a * b;\n   19    if(x > 0xffffffff)\n\n/home/roman/Sources/c-utils/lib/safemult/umult64.c:\n   51  int\n   52  umult64(uint64 a, uint64 b, uint64* c) {\n   53:   uint32 ahi = a >> 32;\n   54:   uint32 alo = (a & 0xffffffff);\n   55:   uint32 bhi = b >> 32;\n   56:   uint32 blo = (b & 0xffffffff);\n   57  \n   58    // a=ahi*x+alo, b=bhi*x+blo\n\n/home/roman/Sources/c-utils/lib/scan.h:\n    6  #include \"typedefs.h\"\n    7  \n    8: #include \"uint32.h\"\n    9  #include \"uint64.h\"\n   10  \n   ..\n   86  \n   87  /* some variable length encodings for integers */\n   88: size_t scan_utf8(const char* in, size_t len, uint32* n) __pure__;\n   89  size_t scan_asn1derlength(const char* in, size_t len, uint64* n) __pure__;\n   90  size_t scan_asn1dertag(const char* in, size_t len, uint64* n) __pure__;\n   ..\n  108  size_t scan_xmlescape(const char* src, char* dest);\n  109  \n  110: size_t scan_utf8_sem(const char* in, size_t len, uint32* num);\n  111  \n  112  size_t scan_eolskip(const char* s, size_t limit);\n\n/home/roman/Sources/c-utils/lib/scan/scan_pb_type5_fixed32.c:\n    1  #include \"../scan.h\"\n    2: #include \"../uint32.h\"\n    3  \n    4  size_t\n    5: scan_pb_type5_fixed32(const char* in, size_t len, uint32* d) {\n    6    if(len < 4)\n    7      return 0;\n    8:   uint32_unpack(in, d);\n    9    return 4;\n   10  }\n\n/home/roman/Sources/c-utils/lib/scan/scan_utf8_sem.c:\n    2  \n    3  size_t\n    4: scan_utf8_sem(const char* in, size_t len, uint32* num) {\n    5    size_t r = scan_utf8(in, len, num);\n    6    if(r > 0) {\n\n/home/roman/Sources/c-utils/lib/set.h:\n    2  #define SET_H\n    3  \n    4: #include \"uint32.h\"\n    5  \n    6  typedef struct bucket {\n    .\n    8    void* value;\n    9    size_t size;\n   10:   uint32 hash;\n   11  } bucket_t;\n   12  \n   13  typedef struct set {\n   14:   uint32 entries;\n   15:   uint32 overflow;\n   16:   uint32 len;\n   17:   uint32 (*hash_fp)(const void*, size_t);\n   18    bucket_t* array;\n   19  } set_t;\n   ..\n   21  // Iterator Definition\n   22  typedef struct set_iterator {\n   23:   uint32 index;\n   24    const bucket_t* current;\n   25    const set_t* set;\n   ..\n   35  void set_free(set_t*);\n   36  int set_has(const set_t*, const void*, const size_t);\n   37: uint32 set_hashfunc(const void*, size_t);\n   38: void set_init(set_t*, uint32 (*const)(const void*, size_t));\n   39  int set_cat(set_t*, const set_t*);\n   40  \n   ..\n   50  #define set_hash(s, x, len) ((s)->hash_fp((x), (len)))\n   51  \n   52: static inline uint32\n   53  set_size(const set_t* s) {\n   54    return s->entries;\n\n/home/roman/Sources/c-utils/lib/set/set_add.c:\n   45  int\n   46  set_add(set_t* set, const void* val, const size_t size) {\n   47:   uint32 hash, index;\n   48    bucket_t* b;\n   49  \n\n/home/roman/Sources/c-utils/lib/set/set_find.c:\n    5  bucket_t* set_bucket(const set_t* set, const void* val, const size_t size);\n    6  \n    7: uint32 set_index(const set_t* set, const void* val, const size_t size);\n    8  \n    9  bucket_t**\n   10: set_find_bucket(bucket_t** ptr, const void* val, const size_t size, uint32 hash) {\n   11    bucket_t* b;\n   12    while((b = *ptr)) {\n   ..\n   22  set_find(const set_t* set, const void* val, const size_t size) {\n   23    bucket_t** ptr;\n   24:   uint32 hash = set_hash(set, val, size);\n   25    set_iterator_t it;\n   26    it.set = set;\n\n/home/roman/Sources/c-utils/lib/set/set_has.c:\n    2  #include <string.h>\n    3  \n    4: uint32\n    5  set_index(const set_t* set, const void* val, const size_t size) {\n    6:   uint32 hash;\n    7    hash = set_hash(set, val, size);\n    8    return hash & (set->len - 1);\n    .\n   12  set_has(const set_t* set, const void* val, const size_t size) {\n   13    bucket_t* b;\n   14:   uint32 hash, i;\n   15    hash = set_hash(set, val, size);\n   16  \n\n/home/roman/Sources/c-utils/lib/set/set_hashfunc.c:\n    1  #include \"../set.h\"\n    2  \n    3: uint32\n    4  set_hashfunc(const void* x, size_t len) {\n    5    const char* key = x;\n    6    unsigned char c;\n    7    size_t i;\n    8:   uint32 hash = 5381;\n    9  \n   10    for(i = 0; i < len; i++) {\n\n/home/roman/Sources/c-utils/lib/set/set_init.c:\n    6  \n    7  void\n    8: set_init(set_t* set, uint32 (*const hash_fp)(const void*, size_t)) {\n    9  \n   10    assert(set);\n\n/home/roman/Sources/c-utils/lib/set/set_iterator_erase.c:\n    7    set_t* s;\n    8    bucket_t* b;\n    9:   uint32 i;\n   10  \n   11    if(!(b = (bucket_t*)it->current) || !(s = (set_t*)it->set))\n\n/home/roman/Sources/c-utils/lib/set/set_iterator_init.c:\n   11  init_bucket(set_iterator_t* it) {\n   12    bucket_t* b = it->set->array;\n   13:   uint32 index = 0;\n   14    if(!b)\n   15      return 0;\n\n/home/roman/Sources/c-utils/lib/set/set_iterator_next.c:\n    6  set_iterator_next(set_iterator_t* it) {\n    7    const bucket_t* b;\n    8:   uint32 index;\n    9  \n   10    if(!(b = it->current))\n\n/home/roman/Sources/c-utils/lib/socket.h:\n    5  #include \"typedefs.h\"\n    6  #include \"uint16.h\"\n    7: #include \"uint32.h\"\n    8  \n    9  #include <errno.h>\n   ..\n   31  \n   32  int socket_connect4(int s, const char* ip, uint16 port);\n   33: int socket_connect6(int s, const char* ip, uint16 port, uint32 scope_id);\n   34  int socket_connected(int s);\n   35  int socket_bind4(int s, const char* ip, uint16 port);\n   36  int socket_bind4_reuse(int s, const char* ip, uint16 port);\n   37: int socket_bind6(int s, const char* ip, uint16 port, uint32 scope_id);\n   38: int socket_bind6_reuse(int s, const char* ip, uint16 port, uint32 scope_id);\n   39  int socket_listen(int s, unsigned int backlog);\n   40  int socket_accept4(int s, char* ip, uint16* port);\n   41: int socket_accept6(int s, char* ip, uint16* port, uint32* scope_id);\n   42  ssize_t socket_recv4(int s, char* buf, size_t len, char* ip, uint16* port);\n   43: ssize_t socket_recv6(int s, char* buf, size_t len, char* ip, uint16* port, uint32* scope_id);\n   44  ssize_t socket_send4(int s, const char* buf, size_t len, const char* ip, uint16 port);\n   45  ssize_t socket_send4_flag(int s, const char* buf, size_t len, const char* ip, uint16 port, int flags);\n   46: ssize_t socket_send6(int s, const char* buf, size_t len, const char* ip, uint16 port, uint32 scope_id);\n   47: ssize_t socket_send6_flag(int s, const char* buf, size_t len, const char* ip, uint16 port, uint32 scope_id, int flags);\n   48  int socket_local4(int s, char* ip, uint16* port);\n   49: int socket_local6(int s, char* ip, uint16* port, uint32* scope_id);\n   50  int socket_remote4(int s, char* ip, uint16* port);\n   51: int socket_remote6(int s, char* ip, uint16* port, uint32* scope_id);\n   52  \n   53  /* enable sending udp packets to the broadcast address */\n   ..\n   79  void socket_tryreservein(int s, int size);\n   80  \n   81: const char* socket_getifname(uint32 _interface);\n   82: uint32 socket_getifidx(const char* ifname);\n   83  \n   84  extern int noipv6;\n   ..\n   98   * just one step, so we need an API to do it in one step */\n   99  int socket_fastopen_connect4(int s, const char* ip, uint16 port, const char* buf, size_t len);\n  100: int socket_fastopen_connect6(int s, const char* ip, uint16 port, uint32 scope_id, const char* buf, size_t len);\n  101  \n  102  const char* socket_ip6loopback();\n\n/home/roman/Sources/c-utils/lib/socket/fmt_ip6if.c:\n   11  \n   12  size_t\n   13: fmt_ip6if(char* dest, const char* ip, uint32 scope_id) {\n   14    size_t i = fmt_ip6(dest, ip);\n   15    if(scope_id) {\n\n/home/roman/Sources/c-utils/lib/socket/fmt_ip6ifc.c:\n    5  \n    6  size_t\n    7: fmt_ip6ifc(char* s, const char ip[16], uint32 scope_id) {\n    8    if(ip6_isv4mapped(ip))\n    9      return fmt_ip4(s, ip + 12);\n\n/home/roman/Sources/c-utils/lib/socket/scan_ip6if.c:\n   12  \n   13  size_t\n   14: scan_ip6if(const char* src, char* ip, uint32* scope_id) {\n   15    size_t i = scan_ip6(src, ip);\n   16    *scope_id = 0;\n\n/home/roman/Sources/c-utils/lib/socket/socket_accept4.c:\n   75  #endif\n   76    if(ip)\n   77:     *(uint32*)ip = *(uint32*)&si.sin_addr;\n   78    if(port)\n   79      uint16_unpack_big((char*)&si.sin_port, port);\n\n/home/roman/Sources/c-utils/lib/socket/socket_accept6.c:\n    8  \n    9  int\n   10: socket_accept6(int s, char* ip, uint16* port, uint32* scope_id) {\n   11  #ifdef LIBC_HAS_IP6\n   12    struct sockaddr_in6 sa;\n\n/home/roman/Sources/c-utils/lib/socket/socket_bind4.c:\n    8  #include \"../byte.h\"\n    9  #include \"../uint16.h\"\n   10: #include \"../uint32.h\"\n   11  \n   12  int\n   ..\n   17    uint16_pack_big((char*)&si.sin_port, port);\n   18    if(ip)\n   19:     *(uint32*)&si.sin_addr = *(uint32*)ip;\n   20    else\n   21      si.sin_addr.s_addr = INADDR_ANY;\n\n/home/roman/Sources/c-utils/lib/socket/socket_bind6.c:\n   12  \n   13  int\n   14: socket_bind6(int s, const char* ip, uint16 port, uint32 scope_id) {\n   15  #ifdef LIBC_HAS_IP6\n   16    struct sockaddr_in6 sa;\n\n/home/roman/Sources/c-utils/lib/socket/socket_bind6_reuse.c:\n    9  \n   10  int\n   11: socket_bind6_reuse(int s, const char* ip, uint16 port, uint32 scope_id) {\n   12    int one = 1;\n   13    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (void*)&one, sizeof one);\n\n/home/roman/Sources/c-utils/lib/socket/socket_connect4.c:\n    8  #include \"../byte.h\"\n    9  #include \"../uint16.h\"\n   10: #include \"../uint32.h\"\n   11  \n   12  #if !WINDOWS_NATIVE\n   ..\n   20    si.sin_family = AF_INET;\n   21    uint16_pack_big((char*)&si.sin_port, port);\n   22:   *((uint32*)&si.sin_addr) = *((uint32*)ip);\n   23    return winsock2errno(connect(s, (struct sockaddr*)&si, sizeof(si)));\n   24  }\n\n/home/roman/Sources/c-utils/lib/socket/socket_connect6.c:\n   11  #include \"../ip6.h\"\n   12  /*#include \"haveip6.h\"*/\n   13: #include \"../uint32.h\"\n   14  #include \"../ip4.h\"\n   15  /*#include \"havescope.h\"*/\n   16  \n   17  int\n   18: socket_connect6(int s, const char ip[16], uint16 port, uint32 scope_id) {\n   19  #ifdef LIBC_HAS_IP6\n   20    struct sockaddr_in6 sa;\n\n/home/roman/Sources/c-utils/lib/socket/socket_fastopen_connect6.c:\n   10  #include <errno.h>\n   11  #include \"../typedefs.h\"\n   12: #include \"../uint32.h\"\n   13  \n   14  int\n   15: socket_fastopen_connect6(int s, const char* ip, uint16 port, uint32 scope_id, const char* buf, size_t len) {\n   16  #ifndef MSG_FASTOPEN\n   17    int r;\n\n/home/roman/Sources/c-utils/lib/socket/socket_getifidx.c:\n   14  \n   15  #if WINDOWS_NATIVE\n   16: static uint32\n   17  if_nametoindex(const char* name) {\n   18  \n   19:   typedef uint32(WINAPI ifn2idx_fn)(const char*);\n   20    static ifn2idx_fn* ifn2idx;\n   21  \n   ..\n   36  #if !defined(__wasi__)\n   37  \n   38: uint32\n   39  socket_getifidx(const char* ifname) {\n   40  #if defined(HAVE_N2I) && !defined(__EMSCRIPTEN__)\n\n/home/roman/Sources/c-utils/lib/socket/socket_getifname.c:\n   21  #if WINDOWS_NATIVE\n   22  static char*\n   23: if_indextoname(uint32 idx, const char* name) {\n   24  \n   25:   typedef char*(WINAPI idx2ifn_fn)(uint32, const char*);\n   26    static idx2ifn_fn* idx2ifn;\n   27  \n   ..\n   43  \n   44  const char*\n   45: socket_getifname(uint32 _interface) {\n   46    char* tmp = if_indextoname(_interface, ifname);\n   47    if(tmp)\n   ..\n   52  #else\n   53  const char*\n   54: socket_getifname(uint32 _interface) {\n   55    return \"[unknown]\";\n   56  }\n\n/home/roman/Sources/c-utils/lib/socket/socket_local4.c:\n   16      return winsock2errno(-1);\n   17    if(ip)\n   18:     *(uint32*)ip = *(uint32*)&si.sin_addr;\n   19    if(port)\n   20      uint16_unpack_big((char*)&si.sin_port, port);\n\n/home/roman/Sources/c-utils/lib/socket/socket_local6.c:\n   10  #include \"../ip6.h\"\n   11  /*#include \"haveip6.h\"*/\n   12: #include \"../uint32.h\"\n   13  /*#include \"havesl.h\"*/\n   14  /*#include \"havescope.h\"*/\n   15  \n   16  int\n   17: socket_local6(int s, char ip[16], uint16* port, uint32* scope_id) {\n   18  #ifdef LIBC_HAS_IP6\n   19    struct sockaddr_in6 si;\n\n/home/roman/Sources/c-utils/lib/socket/socket_recv4.c:\n   17      return winsock2errno(-1);\n   18    if(ip)\n   19:     *(uint32*)ip = *(uint32*)&si.sin_addr;\n   20    if(port)\n   21      uint16_unpack_big((char*)&si.sin_port, port);\n\n/home/roman/Sources/c-utils/lib/socket/socket_recv6.c:\n   14  \n   15  ssize_t\n   16: socket_recv6(int s, char* buf, size_t len, char ip[16], uint16* port, uint32* scope_id) {\n   17  #ifdef LIBC_HAS_IP6\n   18    struct sockaddr_in6 si;\n\n/home/roman/Sources/c-utils/lib/socket/socket_remote4.c:\n   17      return winsock2errno(-1);\n   18    if(ip)\n   19:     *(uint32*)ip = *(uint32*)&si.sin_addr;\n   20    if(port)\n   21      uint16_unpack_big((char*)&si.sin_port, port);\n\n/home/roman/Sources/c-utils/lib/socket/socket_remote6.c:\n   10  #include \"../ip6.h\"\n   11  /*#include \"haveip6.h\"*/\n   12: #include \"../uint32.h\"\n   13  /*#include \"havesl.h\"*/\n   14  /*#include \"havescope.h\"*/\n   15  \n   16  int\n   17: socket_remote6(int s, char ip[16], uint16* port, uint32* scope_id) {\n   18  #ifdef LIBC_HAS_IP6\n   19    struct sockaddr_in6 si;\n\n/home/roman/Sources/c-utils/lib/socket/socket_send4.c:\n   11    si.sin_family = AF_INET;\n   12    uint16_pack_big((char*)&si.sin_port, port);\n   13:   *((uint32*)&si.sin_addr) = *((uint32*)ip);\n   14    return winsock2errno(sendto(s, buf, len, flag, (void*)&si, sizeof si));\n   15  }\n\n/home/roman/Sources/c-utils/lib/socket/socket_send6.c:\n   15  \n   16  ssize_t\n   17: socket_send6_flag(int s, const char* buf, size_t len, const char ip[16], uint16 port, uint32 scope_id, int flag) {\n   18  #ifdef LIBC_HAS_IP6\n   19    struct sockaddr_in6 si;\n   ..\n   50  \n   51  ssize_t\n   52: socket_send6(int s, const char* buf, size_t len, const char ip[16], uint16 port, uint32 scope_id) {\n   53    return socket_send6_flag(s, buf, len, ip, port, scope_id, 0);\n   54  }\n\n/home/roman/Sources/c-utils/lib/taia.h:\n    6  \n    7  #include \"tai.h\"\n    8: #include \"uint32.h\"\n    9  \n   10  #ifdef __cplusplus\n   ..\n   18  typedef struct taia {\n   19    struct tai sec;\n   20:   uint32 nano; /* 0...999999999 */\n   21:   uint32 atto; /* 0...999999999 */\n   22  } tai6464;\n   23  \n\n/home/roman/Sources/c-utils/lib/taia/taia_add.c:\n    9    t->atto = u->atto + v->atto;\n   10    if(t->atto > 999999999UL) {\n   11:     t->atto -= (uint32)1000000000UL;\n   12      ++t->nano;\n   13    }\n   14    if(t->nano > 999999999UL) {\n   15:     t->nano -= (uint32)1000000000UL;\n   16      ++t->sec.x;\n   17    }\n\n/home/roman/Sources/c-utils/lib/taia/taia_half.c:\n    7    t->atto = u->atto >> 1;\n    8    if(u->nano & 1)\n    9:     t->atto += (uint32)500000000UL;\n   10    t->nano = u->nano >> 1;\n   11    if(u->sec.x & 1)\n   12:     t->nano += (uint32)500000000UL;\n   13    t->sec.x = u->sec.x >> 1;\n   14  }\n\n/home/roman/Sources/c-utils/lib/taia/taia_now.c:\n   37    gettimeofday(&now, (struct timezone*)0);\n   38    tai_unix(&t->sec, now.tv_sec);\n   39:   t->nano = (uint32)(1000 * now.tv_usec + 500);\n   40    t->atto = 0;\n   41  #endif\n\n/home/roman/Sources/c-utils/lib/taia/taia_pack.c:\n    4  void\n    5  taia_pack(char* s, const struct taia* t) {\n    6:   uint32 x;\n    7  \n    8    tai_pack(s, &t->sec);\n\n/home/roman/Sources/c-utils/lib/taia/taia_sub.c:\n    5  void\n    6  taia_sub(struct taia* t, const struct taia* u, const struct taia* v) {\n    7:   uint32 unano = u->nano;\n    8:   uint32 uatto = u->atto;\n    9  \n   10    t->sec.x = u->sec.x - v->sec.x;\n   ..\n   12    t->atto = uatto - v->atto;\n   13    if(t->atto > uatto) {\n   14:     t->atto += (uint32)1000000000UL;\n   15      --t->nano;\n   16    }\n   17    if(t->nano > unano) {\n   18:     t->nano += (uint32)1000000000UL;\n   19      --t->sec.x;\n   20    }\n\n/home/roman/Sources/c-utils/lib/textcode/fmt_jsonescape.c:\n    5  #include \"../str.h\"\n    6  #include \"../scan.h\"\n    7: #include \"../uint32.h\"\n    8  \n    9  /* src is UTF-8 encoded */\n   ..\n   43          } else if(s[i] > 0x7f) {\n   44            /* UTF-8! Convert to surrogate pair if needed. */\n   45:           uint32 u;\n   46            size_t j = scan_utf8_sem((const char*)s + i, len - i, &u);\n   47            if(j == 0) { /* Invalid UTF-8! Try to limp on! */\n\n/home/roman/Sources/c-utils/lib/ucs/scan_latin1_utf8.c:\n    6  size_t\n    7  scan_latin1_utf8(const char* x, size_t n, char* out) {\n    8:   uint32 wc;\n    9    size_t ret;\n   10    if((ret = scan_utf8(x, n, &wc))) {\n\n/home/roman/Sources/c-utils/lib/uint32.h:\n   23  #if defined(__BORLANDC__)\n   24  #elif defined(__UINT32_TYPE__) && defined(__INT32_TYPE__)\n   25: typedef __UINT32_TYPE__ uint32;\n   26: typedef __INT32_TYPE__ int32;\n   27  \n   28: #elif defined(___int32_t_defined) || defined(__BIT_TYPES_DEFINED__)\n   29: typedef u_int32_t uint32;\n   30: typedef int32_t int32;\n   31  \n   32  #elif defined(_MSC_VER)\n   33  #include <windows.h>\n   34: typedef UINT32 uint32;\n   35: typedef INT32 int32;\n   36  \n   37  #elif defined(__MINGW32__) || defined(__MINGW64__)\n   38: typedef uint32_t uint32;\n   39: typedef int32_t int32;\n   40  \n   41  #else\n   42: typedef uint32_t uint32;\n   43  \n   44  #if !(defined(_WINSOCK2API_) && defined(__LCC__))\n   45: typedef int32_t int32;\n   46  #endif\n   47  #endif\n   ..\n   52      defined(__LITTLE_ENDIAN__) || (BYTE_ORDER == _LITTLE_ENDIAN) || defined(_AMD64_) || defined(I_X86_))\n   53  inline static void\n   54: uint32_pack(char* out, uint32 in) {\n   55:   *(uint32*)out = in;\n   56  }\n   57  \n   58  inline static void\n   59: uint32_unpack(const char* in, uint32* out) {\n   60:   *out = *(uint32*)in;\n   61  }\n   62  \n   63: inline static uint32\n   64: uint32_get(const void* ptr) {\n   65    const char* in = (const char*)ptr;\n   66:   return *(uint32*)in;\n   67  }\n   68  \n   69: inline static uint32\n   70: uint32_read(const char* in) {\n   71:   return *(uint32*)in;\n   72  }\n   73  \n   74  #else\n   75  \n   76: inline static uint32\n   77: uint32_get(const void* ptr) {\n   78    const char* in = ptr;\n   79    return (in[0] << 24) | (in[1] << 16) | (in[2] << 8) | (in[3]);\n   80  }\n   81  \n   82: inline static uint32\n   83: uint32_read(const char* in) {\n   84    return (in[0] << 24) | (in[1] << 16) | (in[2] << 8) | (in[3]);\n   85  }\n   86  \n   87: void uint32_pack(char* out, uint32 in);\n   88: void uint32_unpack(const char* in, uint32* out);\n   89  #endif\n   90  #endif\n   91  \n   92: void uint32_pack_big(char* out, uint32 in);\n   93: void uint32_unpack_big(const char* in, uint32* out);\n   94: uint32 uint32_read_big(const char* in);\n   95  \n   96: uint32 uint32_random(void);\n   97: int uint32_seed(const void*, unsigned long n);\n   98: uint32 uint32_prng(uint32, uint32 seed);\n   99  \n  100  /* bit rotating macros */\n  101: #define uint32_ror(v, c) (((uint32)(v) >> (c)) | ((uint32)(v) << (32 - (c))))\n  102: #define uint32_rol(v, c) (((uint32)(v) << (c)) | ((uint32)(v) >> (32 - (c))))\n  103: #define uint32_ror_safe(v, c) (((uint32)(v) >> uint32rc(c)) | ((uint32)(v) << (32 - uint32rc(c))))\n  104: #define uint32_rol_safe(v, c) (((uint32)(v) << uint32rc(c)) | ((uint32)(v) >> (32 - uint32rc(c))))\n  105  \n  106  #ifdef __cplusplus\n\n/home/roman/Sources/c-utils/lib/uint32/uint32_pack.c:\n    1  #define NO_UINT32_MACROS\n    2: #include \"../uint32.h\"\n    3  \n    4  void\n    5: uint32_pack(char* out, uint32 in) {\n    6    *out = (char)in;\n    7    in >>= 8;\n\n/home/roman/Sources/c-utils/lib/uint32/uint32_pack_big.c:\n    1  #define NO_UINT32_MACROS\n    2: #include \"../uint32.h\"\n    3  \n    4  void\n    5: uint32_pack_big(char* out, uint32 in) {\n    6    out[3] = (char)in;\n    7    in >>= 8;\n\n/home/roman/Sources/c-utils/lib/uint32/uint32_prng.c:\n    1: #include \"../uint32.h\"\n    2  \n    3: uint32 uint32_entropy[8] = {\n    4      0xe25e40f8,\n    5      0x2839fba7,\n    .\n   13  \n   14  /* prng */\n   15: uint32\n   16: uint32_prng(uint32 value, uint32 seed) {\n   17    register int i = 27;\n   18    while(i >= 0) {\n   19      /* whatever, try to re-use entropy as many as possible with\n   20         as less as possible instructions */\n   21:     seed ^= uint32_ror(uint32_entropy[((value + seed) >> (i + 2)) & 7], seed & 0x1f);\n   22:     seed += uint32_rol(uint32_entropy[((value - seed) >> (i + 1)) & 7], seed & 0x1f);\n   23:     seed -= uint32_ror(uint32_entropy[((value ^ seed) >> (i)) & 7], seed & 0x1f);\n   24      i--;\n   25    }\n\n/home/roman/Sources/c-utils/lib/uint32/uint32_random.c:\n    1: #include \"../uint32.h\"\n    2  #include \"../taia.h\"\n    3  \n    4  #define UINT32_POOLSIZE 16\n    5  \n    6: uint32 uint32_pool[UINT32_POOLSIZE];\n    7: extern uint32 uint32_bytes_seeded;\n    8  \n    9: uint32\n   10: uint32_random(void) {\n   11    size_t i;\n   12:   uint32 r = 0;\n   13  \n   14    /* seed if not seeded */\n   15:   if(uint32_bytes_seeded == 0) {\n   16      struct taia t;\n   17      taia_now(&t);\n   18:     uint32_seed(&t, sizeof(t));\n   19    }\n   20  \n   21:   for(i = 0; i < sizeof(uint32_pool) / sizeof(uint32); i++) {\n   22:     r += uint32_prng(uint32_pool[i], r);\n   23:     uint32_pool[i] = r;\n   24    }\n   25  \n   26:   if(uint32_bytes_seeded)\n   27:     uint32_bytes_seeded--;\n   28  \n   29    return r;\n\n/home/roman/Sources/c-utils/lib/uint32/uint32_read.c:\n    1  #define NO_UINT32_MACROS\n    2: #include \"../uint32.h\"\n    3  \n    4: uint32\n    5: uint32_read(const char* in) {\n    6:   return (((uint32)(unsigned char)in[3]) << 24) | (((uint32)(unsigned char)in[2]) << 16) |\n    7:          (((uint32)(unsigned char)in[1]) << 8) | (uint32)(unsigned char)in[0];\n    8  }\n    9  \n\n/home/roman/Sources/c-utils/lib/uint32/uint32_read_big.c:\n    1  #define NO_UINT32_MACROS\n    2: #include \"../uint32.h\"\n    3  \n    4: uint32\n    5: uint32_read_big(const char* in) {\n    6:   return (((uint32)(unsigned char)in[0]) << 24) | (((uint32)(unsigned char)in[1]) << 16) |\n    7:          (((uint32)(unsigned char)in[2]) << 8) | (uint32)(unsigned char)in[3];\n    8  }\n    9  \n\n/home/roman/Sources/c-utils/lib/uint32/uint32_seed.c:\n    1  #include \"../windoze.h\"\n    2: #include \"../uint32.h\"\n    3  \n    4  #if WINDOWS_NATIVE\n    .\n   14  int open_read(const char* filename);\n   15  \n   16: uint32 uint32_bytes_seeded;\n   17  \n   18: extern uint32 uint32_pool[UINT32_POOLSIZE];\n   19  \n   20  /* feed data to the prng */\n   21  int\n   22: uint32_seed(const void* p, unsigned long n) {\n   23    int fd = -1;\n   24  \n   ..\n   26      int i;\n   27      if((fd = open(\"/dev/urandom\", O_RDONLY)) != -1) {\n   28:       i = read(fd, uint32_pool, sizeof(uint32_pool));\n   29        if(i > 0)\n   30:         uint32_bytes_seeded += i;\n   31        close(fd);\n   32      }\n   33    } else {\n   34      const char* b = (const char*)p;\n   35:     char* x = (char*)uint32_pool;\n   36  \n   37      while(n) {\n   38:       x[n % sizeof(uint32_pool)] ^= *b;\n   39        n--;\n   40        b++;\n   41:       uint32_bytes_seeded++;\n   42      }\n   43    }\n\n/home/roman/Sources/c-utils/lib/uint32/uint32_unpack.c:\n    1  #define NO_UINT32_MACROS\n    2: #include \"../uint32.h\"\n    3  \n    4  void\n    5: uint32_unpack(const char* in, uint32* out) {\n    6:   *out = (((uint32)(unsigned char)in[3]) << 24) | (((uint32)(unsigned char)in[2]) << 16) |\n    7:          (((uint32)(unsigned char)in[1]) << 8) | (uint32)(unsigned char)in[0];\n    8  }\n    9  \n\n/home/roman/Sources/c-utils/lib/uint32/uint32_unpack_big.c:\n    1  #define NO_UINT32_MACROS\n    2: #include \"../uint32.h\"\n    3  \n    4  void\n    5: uint32_unpack_big(const char* in, uint32* out) {\n    6:   *out = (((uint32)(unsigned char)in[0]) << 24) | (((uint32)(unsigned char)in[1]) << 16) |\n    7:          (((uint32)(unsigned char)in[2]) << 8) | (uint32)(unsigned char)in[3];\n    8  }\n    9  \n\n/home/roman/Sources/c-utils/lib/uint64/uint64_pack.c:\n    1  #define NO_UINT64_MACROS\n    2  #include \"../uint64.h\"\n    3: #include \"../uint32.h\"\n    4  \n    5  void\n    6  uint64_pack(char* out, uint64 in) {\n    7:   uint32_pack(out, in & 0xffffffff);\n    8:   uint32_pack(out + 4, (uint32)(in >> 32));\n    9  }\n   10  \n\n/home/roman/Sources/c-utils/lib/uint64/uint64_pack_big.c:\n    1  #define NO_UINT64_MACROS\n    2  #include \"../uint64.h\"\n    3: #include \"../uint32.h\"\n    4  \n    5  void\n    6  uint64_pack_big(char* out, uint64 in) {\n    7:   uint32_pack_big(out, (uint32)(in >> 32));\n    8:   uint32_pack_big(out + 4, in & 0xffffffff);\n    9  }\n   10  \n\n/home/roman/Sources/c-utils/lib/uint64/uint64_read.c:\n    1  #define NO_UINT64_MACROS\n    2  #include \"../uint64.h\"\n    3: #include \"../uint32.h\"\n    4  \n    5  uint64\n    6  uint64_read(const char* in) {\n    7:   return uint32_read(in) | ((uint64)uint32_read(in + 4) << 32);\n    8  }\n    9  \n\n/home/roman/Sources/c-utils/lib/uint64/uint64_read_big.c:\n    1  #define NO_UINT64_MACROS\n    2  #include \"../uint64.h\"\n    3: #include \"../uint32.h\"\n    4  \n    5  uint64\n    6  uint64_read_big(const char* in) {\n    7:   return ((uint64)uint32_read_big(in) << 32) | uint32_read_big(in + 4);\n    8  }\n    9  \n\n/home/roman/Sources/c-utils/lib/uint64/uint64_unpack_big.c:\n    1  #define NO_UINT64_MACROS\n    2  #include \"../uint64.h\"\n    3: #include \"../uint32.h\"\n    4  \n    5  void\n\n/home/roman/Sources/c-utils/libntldd.h:\n    5  #include \"lib/strlist.h\"\n    6  #include \"lib/uint16.h\"\n    7: #include \"lib/uint32.h\"\n    8  #include \"lib/uint64.h\"\n    9  \n   ..\n   25    struct export_table_item* forward;\n   26    int section_index;\n   27:   uint32 address_offset;\n   28  };\n   29  \n   ..\n   86  \n   87  struct _soff_entry {\n   88:   uint32 start;\n   89:   uint32 end;\n   90    void* off;\n   91  };\n\n/home/roman/Sources/c-utils/list-r.c:\n   91  static int64 opt_minsize = -1;\n   92  static long opt_depth = -1;\n   93: static uint32 opt_types = (uint32)(int32)-1;\n   94  static const char* opt_relative_to = 0;\n   95  static const char* opt_timestyle = \"%b %2e %H:%M\";\n   ..\n  342  static int list_dir_internal(stralloc* dir, char type, long depth);\n  343  \n  344: static uint32\n  345  type_mask(const char* arg) {\n  346    size_t i;\n  347:   uint32 mask = 0;\n  348    int inv = 0;\n  349    for(i = 0; arg[i]; i++) {\n  350:     uint32 bit = 0;\n  351      switch(arg[i]) {\n  352        case 'f': bit = D_FILE; break;\n  ...\n  383        const char* name = x;\n  384        size_t len, namelen = byte_chr(x, n, ':');\n  385:       uint32 uid = 0;\n  386        if(namelen == n)\n  387          break;\n  ...\n  412  \n  413  static char*\n  414: resolve_etc(const strarray* arr, uint32 id) {\n  415    uint64 len = array_length(arr, sizeof(char*));\n  416    if(id >= 0 && id < len)\n  ...\n  420  \n  421  static void\n  422: make_num(stralloc* out, int32 num, uint32 width) {\n  423    char fmt[FMT_ULONG + 1];\n  424    size_t sz = fmt_int(fmt, num);\n  ...\n  429  \n  430  static void\n  431: make_time(stralloc* out, uint64 t, uint32 width) {\n  432    char fmt[21];\n  433    size_t i, sz = fmt_iso8601(fmt, t);\n  ...\n  444  \n  445  static void\n  446: make_str(stralloc* out, const char* s, uint32 width) {\n  447    size_t i, sz = str_len(s);\n  448    stralloc_catb(out, s, sz);\n  ...\n  574  }\n  575  \n  576: uint32\n  577: crc32(uint32 crc, const char* data, size_t size) {\n  578:   uint32 i, r = ~0;\n  579    const char* end = data + size;\n  580  \n  ...\n  583  \n  584      for(i = 0; i < 8; i++) {\n  585:       uint32 t = ~((r & 1) - 1);\n  586        r = (r >> 1) ^ (0xedb88320 & t);\n  587      }\n  ...\n  592  \n  593  static int\n  594: file_crc32(const char* path, size_t size, uint32* crc) {\n  595    size_t n;\n  596    const char* x;\n  ...\n  614    int is_dir, is_symlink;\n  615    size_t len;\n  616:   uint32 crc;\n  617    const char* exclude;\n  618  #if !WINDOWS_NATIVE\n  ...\n  647      dir_type_t dtype;\n  648      uint64 mtime = 0, size = 0;\n  649:     uint32 mode = 0, nlink = 0;\n  650:     uint32 uid = 0, gid = 0;\n  651  \n  652  #if !WINDOWS_NATIVE\n\n/home/roman/Sources/c-utils/log.c:\n    1  #include \"lib/uint64.h\"\n    2: #include \"lib/uint32.h\"\n    3  #include \"lib/uint16.h\"\n    4  #include \"lib/buffer.h\"\n    .\n  498  void\n  499  log_rrsoa(const char server[], const char* q, const char* n1, const char* n2, const char misc[20], unsigned int ttl) {\n  500:   uint32 u;\n  501    int i;\n  502  \n  ...\n  512    log_name(n2);\n  513    for(i = 0; i < 20; i += 4) {\n  514:     uint32_unpack_big(misc + i, &u);\n  515      log_space();\n  516      log_number(u);\n\n/home/roman/Sources/c-utils/macho32list.c:\n    1  /* -*- Mode: C; indent-tabs-mode: nil; c-basic-offset: 4 -*- */\n    2  \n    3: #include \"lib/uint32.h\"\n    4  #include \"lib/macho.h\"\n    5  #include \"lib/mmap.h\"\n    .\n   14    size_t length;\n   15    size_t offset;\n   16:   uint32 i, n_commands;\n   17:   uint32 section_index = 0, text_section_index = 0;\n   18  \n   19    if(argc < 2) {\n   ..\n   78            if(defined_in_section && symbol->n_sect == text_section_index && symbol->n_type & MACHO_N_EXT) {\n   79              char* name;\n   80:             int32 string_offset;\n   81  \n   82              string_offset = symbol->n_strx;\n\n/home/roman/Sources/c-utils/map.h:\n    6  #include \"lib/linked_list.h\"\n    7  #include \"lib/alloc.h\"\n    8: #include \"lib/uint32.h\"\n    9  #include \"lib/uint64.h\"\n   10  #include \"lib/byte.h\"\n   ..\n   71    uint64 hash;\n   72    int rotate;\n   73:   uint32 a = 0;\n   74:   uint32 b = 0;\n   75    const unsigned char* v = (const unsigned char*)str;\n   76    const unsigned char* p = (const unsigned char*)v;\n   77  \n   78:   static uint32 seeds[] = {\n   79        0x2e8b1c8a,\n   80        0xa8fa6d8c,\n\n/home/roman/Sources/c-utils/ntldd.c:\n  153  struct dep_tree_element*\n  154  process_dep(\n  155:     build_tree_config* cfg, uint32 name, struct dep_tree_element* root, struct dep_tree_element* self, int deep) {\n  156    struct dep_tree_element* child = NULL;\n  157    int found;\n  158    int64 i;\n  159:   char* dllname = pe_rva2ptr(self->mapped_address, uint32_get(&name));\n  160    if(dllname == NULL)\n  161      return NULL;\n  ...\n  188  \n  189  /*\n  190: struct export_table_item *find_export_forward (struct dep_tree_element *self, char *dllname, char *export_name, uint32\n  191  export_ordinal)\n  192  {\n  ...\n  219  \n  220  static uint64\n  221: thunk_data_u1_function(void* pe, void* thunk_array, uint32 index, build_tree_config* cfg) {\n  222    if(PE_64(pe))\n  223      return ((uint64*)thunk_array)[index];\n  224    else\n  225:     return ((uint32*)thunk_array)[index];\n  226  }\n  227  /*\n  228  static void*\n  229: opt_header_get_dd_entry(void* opt_header, uint32 entry_type, build_tree_config* cfg) {\n  230    if(cfg->machine_type == PE_FILE_MACHINE_I386)\n  231      return &(((pe32_opt_header*)opt_header)->data_directory[entry_type]);\n  ...\n  245    void *ith, *oith;\n  246    void* opt_header = pe_header_opt(img->base);\n  247:   uint32 i, j;\n  248  \n  249    idata = &pe_get_datadir(img->base, NULL)[PE_DIRECTORY_ENTRY_EXPORT];\n  250    if(idata->size > 0 && idata->virtual_address != 0) {\n  251:     ied = pe_rva2ptr(img->base, uint32_get(&idata->virtual_address));\n  252      if(ied && ied->name != 0) {\n  253:       char* export_module = pe_rva2ptr(img->base, uint32_get(&ied->name));\n  254        if(export_module != NULL) {\n  255          if(self->export_module == NULL)\n  ...\n  258      }\n  259      if(ied && ied->number_of_functions > 0) {\n  260:       uint32 *addrs, *names;\n  261        uint16* ords;\n  262:       self->exports_len = uint32_get(&ied->number_of_functions);\n  263        self->exports = (struct export_table_item*)malloc(sizeof(struct export_table_item) * self->exports_len);\n  264        byte_zero(self->exports, sizeof(struct export_table_item) * self->exports_len);\n  265:       addrs = pe_rva2ptr(img->base, uint32_get(&ied->address_of_functions));\n  266:       ords = pe_rva2ptr(img->base, uint32_get(&ied->address_of_name_ordinals));\n  267:       names = pe_rva2ptr(img->base, uint32_get(&ied->address_of_names));\n  268        for(i = 0; i < ied->number_of_names; i++) {\n  269          self->exports[ords[i]].ordinal = ords[i] + ied->base;\n  270          if(names[i] != 0) {\n  271:           char* s_name = pe_rva2ptr(img->base, uint32_get(&names[i]));\n  272            if(s_name != NULL)\n  273              self->exports[ords[i]].name = str_dup(s_name);\n  ...\n  279            if((idata->virtual_address <= addrs[i]) && (idata->virtual_address + idata->size > addrs[i])) {\n  280              self->exports[i].address = NULL;\n  281:             self->exports[i].forward_str = str_dup(pe_rva2ptr(img->base, uint32_get(&addrs[i])));\n  282            } else\n  283:             self->exports[i].address = pe_rva2ptr(img->base, uint32_get(&addrs[i]));\n  284            self->exports[i].ordinal = i + ied->base;\n  285            self->exports[i].section_index = section_index;\n  ...\n  292    idata = &pe_get_datadir(img->base, NULL)[PE_DIRECTORY_ENTRY_IMPORT];\n  293    if(idata->size > 0 && idata->virtual_address != 0) {\n  294:     iid = pe_rva2ptr(img->base, uint32_get(&idata->virtual_address));\n  295      if(iid)\n  296        for(i = 0; iid[i].characteristics || iid[i].time_date_stamp || iid[i].forwarder_chain || iid[i].name ||\n  ...\n  302          if(dll == NULL)\n  303            continue;\n  304:         ith = pe_rva2ptr(img->base, uint32_get(&iid[i].first_thunk));\n  305:         oith = pe_rva2ptr(img->base, uint32_get(&iid[i].original_first_thunk));\n  306  \n  307          for(j = 0; (impaddress = thunk_data_u1_function(img->base, ith, j, cfg)) != 0; j++) {\n  ...\n  315              imp->address = impaddress;\n  316            }\n  317:           if(oith && imp->orig_address & (1 << (sizeof(uint32) * 8 - 1))) {\n  318:             imp->ordinal = imp->orig_address & ~(1 << (sizeof(uint32) * 8 - 1));\n  319            } else if(oith) {\n  320:             pe_import_by_name* byname = pe_rva2ptr(img->base, uint32_get(&imp->orig_address));\n  321              if(byname != NULL)\n  322                imp->name = str_dup((char*)byname->name);\n  ...\n  328    idata = &pe_get_datadir(img->base, NULL)[PE_DIRECTORY_ENTRY_DELAY_IMPORT];\n  329    if(idata->size > 0 && idata->virtual_address != 0) {\n  330:     idd = pe_rva2ptr(img->base, uint32_get(&idata->virtual_address));\n  331      if(idd)\n  332        for(i = 0; idd[i].attributes.all_attributes || idd[i].dll_name_rva || idd[i].module_handle_rva ||\n  ...\n  340            continue;\n  341          if(idd[i].attributes.all_attributes & 0x00000001) {\n  342:           ith = pe_rva2ptr(img->base, uint32_get(&idd[i].import_address_table_rva));\n  343:           oith = pe_rva2ptr(img->base, uint32_get(&idd[i].import_name_table_rva));\n  344          } else {\n  345            ith = (void*)(uintptr_t)idd[i].import_address_table_rva;\n  ...\n  355              imp->address = impaddress;\n  356            }\n  357:           if(oith && imp->orig_address & (1 << (sizeof(uint32) * 8 - 1))) {\n  358:             imp->ordinal = imp->orig_address & ~(1 << (sizeof(uint32) * 8 - 1));\n  359            } else if(oith) {\n  360:             pe_import_by_name* byname = pe_rva2ptr(img->base, uint32_get(&imp->orig_address));\n  361              if(byname != NULL)\n  362                imp->name = str_dup((char*)byname->name);\n  ...\n  368    idata = &pe_get_datadir(img->base, NULL)[PE_DIRECTORY_ENTRY_IMPORT];\n  369    if(idata->size > 0 && idata->virtual_address != 0) {\n  370:     iid = pe_rva2ptr(img->base, uint32_get(&idata->virtual_address));\n  371      if(iid)\n  372        for(i = 0; iid[i].characteristics || iid[i].time_date_stamp || iid[i].forwarder_chain || iid[i].name ||\n  ...\n  378    idata = &pe_get_datadir(img->base, NULL)[PE_DIRECTORY_ENTRY_DELAY_IMPORT];\n  379    if(idata->size > 0 && idata->virtual_address != 0) {\n  380:     idd = pe_rva2ptr(img->base, uint32_get(&idata->virtual_address));\n  381      if(idd)\n  382        for(i = 0; idd[i].attributes.all_attributes || idd[i].dll_name_rva || idd[i].module_handle_rva ||\n  ...\n  437    char success = 0;\n  438  \n  439:   uint32 i, j;\n  440  \n  441    if(self->flags & DEPTREE_PROCESSED) {\n  ...\n  498      {\n  499        char *forward_str_copy = NULL, *export_name = NULL, *rdot = NULL;\n  500:       uint32 export_ordinal = 0;\n  501        forward_str_copy = str_dup (self->exports[i]->forward_str);\n  502        rdot = strrchr (forward_str_copy, '.');\n\n/home/roman/Sources/c-utils/pelist.c:\n   33    size_t start, length;\n   34  \n   35:   start = uint32_get(&sections[n - 1].pointer_to_raw_data);\n   36:   length = uint32_get(&sections[n - 1].size_of_raw_data);\n   37  \n   38    return start + length;\n   ..\n   46  \n   47    for(i = 0; i < n; i++) {\n   48:     start = uint32_get(&sections[i].pointer_to_raw_data);\n   49:     length = uint32_get(&sections[i].size_of_raw_data);\n   50      j = 0;\n   51  \n   ..\n  113      buffer_putspace(b);\n  114      buffer_putxlong0(b,\n  115:                      pe_rva2offset(base, uint32_get(&data_dirs[i].virtual_address)),\n  116                       sizeof(data_dirs[i].virtual_address) * 2);\n  117      buffer_putspace(b);\n  118:     buffer_putxlong0(b, uint32_get(&data_dirs[i].size), sizeof(data_dirs[i].size) * 2);\n  119      buffer_putnlflush(b);\n  120    }\n  ...\n  123  void\n  124  pe_print_export_directory(buffer* b, uint8* base, pe_export_directory* export_dir) {\n  125:   const char* name = pe_rva2ptr(base, uint32_get(&export_dir->name));\n  126    buffer_puts(b, \"characteristics: \");\n  127    buffer_putxlong0(b, export_dir->characteristics, sizeof(export_dir->characteristics) * 2);\n  ...\n  135    buffer_puts(b, name ? name : \"(null)\");\n  136    buffer_puts(b, \"\\nbase: \");\n  137:   buffer_putulong(b, uint32_get(&export_dir->base));\n  138    buffer_puts(b, \"\\nnumber_of_functions: \");\n  139:   buffer_putulong(b, uint32_get(&export_dir->number_of_functions));\n  140    buffer_puts(b, \"\\nnumber_of_names: \");\n  141:   buffer_putulong(b, uint32_get(&export_dir->number_of_names));\n  142    buffer_puts(b, \"\\naddress_of_functions: \");\n  143    buffer_putxlong0(b,\n  144:                    pe_rva2offset(base, uint32_get(&export_dir->address_of_functions)),\n  145                     sizeof(export_dir->address_of_functions) * 2);\n  146    buffer_puts(b, \"\\naddress_of_names: \");\n  147    buffer_putxlong0(b,\n  148:                    pe_rva2offset(base, uint32_get(&export_dir->address_of_names)),\n  149                     sizeof(export_dir->address_of_names) * 2);\n  150    buffer_puts(b, \"\\naddress_of_name_ordinals: \");\n  151    buffer_putxlong0(b,\n  152:                    pe_rva2offset(base, uint32_get(&export_dir->address_of_name_ordinals)),\n  153                     sizeof(export_dir->address_of_name_ordinals) * 2);\n  154    buffer_putnlflush(b);\n  ...\n  160    pe_data_directory* export_dir = &pe_header_datadir(base)[PE_DIRECTORY_ENTRY_EXPORT];\n  161    pe_section_header* text;\n  162:   uint32 fnaddr, *nameptr, *fnptr, mintextptr, maxtextptr;\n  163    uint16* ordptr;\n  164    char* dllname;\n  165  \n  166:   pe_export_directory* exports = pe_rva2ptr(base, uint32_get(&export_dir->virtual_address));\n  167    // pe_print_export_directory(buffer_1, exports);\n  168  \n  ...\n  172    }\n  173  \n  174:   nameptr = (uint32*)pe_rva2ptr(base, uint32_get(&exports->address_of_names));\n  175:   fnptr = (uint32*)pe_rva2ptr(base, uint32_get(&exports->address_of_functions));\n  176:   ordptr = (uint16*)pe_rva2ptr(base, uint32_get(&exports->address_of_name_ordinals));\n  177  \n  178:   mintextptr = uint32_get(&text->virtual_address);\n  179:   maxtextptr = mintextptr + uint32_get(&text->size_of_raw_data);\n  180    if((dllname = pe_dllname(base)))\n  181      buffer_putm_internal(buffer_1, \"LIBRARY \", dllname, \"\\n\", 0);\n  ...\n  183    buffer_puts(buffer_1, \"EXPORTS\\n\");\n  184  \n  185:   for(i = 0; i < uint32_get(&exports->number_of_names); i++) {\n  186      const char* s;\n  187      uint16 ordinal = uint16_get(&ordptr[i]);\n  ...\n  190  \n  191      /* if(mintextptr < fnaddr && fnaddr < maxtextptr)*/ {\n  192:       s = pe_rva2ptr(base, uint32_get(&nameptr[i])); // pe_rva2ptr(base, pe_thunk(base, nameptr, i));\n  193        buffer_puts(buffer_1, s ? s : \"<null>\");\n  194      }\n  ...\n  204    int i, j, n;\n  205    pe_data_directory* import_dir = &pe_header_datadir(base)[PE_DIRECTORY_ENTRY_IMPORT];\n  206:   pe_import_descriptor* imports = pe_rva2ptr(base, uint32_get(&import_dir->virtual_address));\n  207  \n  208    // n = import_dir->size / sizeof(pe_import_descriptor) - 1;\n  ...\n  221  \n  222    for(i = 0; imports[i].original_first_thunk; ++i) {\n  223:     const char* name = pe_rva2ptr(base, uint32_get(&imports[i].name));\n  224      void* thunk;\n  225      if(name[0] == '\\0')\n  226        break;\n  227  \n  228:     thunk = pe_rva2ptr(base, uint32_get(&imports[i].first_thunk));\n  229  \n  230      for(j = 0;; ++j) {\n  ...\n  462        }\n  463        if(print_data_dir) {\n  464:         uint32 num_dirs;\n  465          pe_data_directory* data_dir = pe_get_datadir(base, &num_dirs);\n  466  \n  ...\n  510      if(!print_range) {\n  511        buffer_puts(buffer_1, \" 0x\");\n  512:       buffer_putxlong0(buffer_1, uint32_get(&sections[i].physical_address), sizeof(sections[i].physical_address) * 2);\n  513      }\n  514      buffer_puts(buffer_1, \" 0x\");\n  515:     buffer_putxlong0(buffer_1, uint32_get(&sections[i].virtual_address), sizeof(sections[i].virtual_address) * 2);\n  516      if(print_range) {\n  517        buffer_puts(buffer_1, \" 0x\");\n  518        buffer_putxlong0(buffer_1,\n  519:                        uint32_get(&sections[i].virtual_address) + uint32_get(&sections[i].physical_address),\n  520                         sizeof(sections[i].physical_address) * 2);\n  521      }\n  522      if(!print_range) {\n  523        buffer_puts(buffer_1, \" 0x\");\n  524:       buffer_putxlong0(buffer_1, uint32_get(&sections[i].size_of_raw_data), sizeof(sections[i].size_of_raw_data) * 2);\n  525      }\n  526      buffer_puts(buffer_1, \" 0x\");\n  527      buffer_putxlong0(buffer_1,\n  528:                      uint32_get(&sections[i].pointer_to_raw_data),\n  529                       sizeof(sections[i].pointer_to_raw_data) * 2);\n  530      if(print_range) {\n  531        buffer_puts(buffer_1, \" 0x\");\n  532        buffer_putxlong0(buffer_1,\n  533:                        uint32_get(&sections[i].pointer_to_raw_data) + uint32_get(&sections[i].size_of_raw_data),\n  534                         sizeof(sections[i].size_of_raw_data) * 2);\n  535      }\n\n/home/roman/Sources/c-utils/piccfg.c:\n    1  #include \"lib/uint8.h\"\n    2  #include \"lib/uint16.h\"\n    3: #include \"lib/uint32.h\"\n    4  #include \"lib/slist.h\"\n    5  #include \"lib/mmap.h\"\n    .\n   37  typedef struct cword {\n   38    struct cword* next;\n   39:   uint32 address;\n   40    uint16 mask;\n   41    uint16 default_value;\n   ..\n   46  static cword* words;\n   47  static ihex_file hex;\n   48: static uint32 baseaddr;\n   49  static stralloc cfg;\n   50  // static map_t(const char*) pragmas;\n   ..\n   53  \n   54  uint16\n   55: config_data_at(uint32 addr) {\n   56    if(baseaddr == 0x0000400e) {\n   57      size_t offs = addr - 0x2007;\n   ..\n  212  \n  213  size_t\n  214: config_bytes(ihex_file* ihf, stralloc* sa, uint32* addr) {\n  215    size_t bytes;\n  216    stralloc_zero(sa);\n\n/home/roman/Sources/c-utils/pipeinfo.c:\n    1: #include \"lib/uint32.h\"\n    2  #include \"lib/uint64.h\"\n    3  #include \"lib/windoze.h\"\n    .\n   34  typedef struct procfd {\n   35    struct procfd* next;\n   36:   int32 pid;\n   37:   int32 fd;\n   38    struct stat st;\n   39    stralloc info;\n   ..\n   98  \n   99  const char*\n  100: type(uint32 bits) {\n  101    switch(bits & S_IFMT) {\n  102      case S_IFSOCK: return \"socket\";\n  ...\n  171  \n  172  void\n  173: proc_fd_root(int32 pid, stralloc* out) {\n  174    stralloc_zero(out);\n  175    stralloc_cats(out, \"/proc/\");\n  ...\n  179  \n  180  const char*\n  181: proc_subdir_path(int32 pid, const char* subdir, stralloc* out) {\n  182    stralloc_zero(out);\n  183    proc_fd_root(pid, out);\n  ...\n  188  \n  189  const char*\n  190: proc_fd_path(int32 pid, fd_t fd, stralloc* out) {\n  191    proc_subdir_path(pid, \"fd\", out);\n  192    if(fd >= 0)\n  ...\n  196  }\n  197  const char*\n  198: proc_fdinfo_path(int32 pid, fd_t fd, stralloc* out) {\n  199    proc_subdir_path(pid, \"fdinfo\", out);\n  200    if(fd >= 0)\n  ...\n  212  read_proc() {\n  213    dir_t procdir, fddir;\n  214:   uint32 pid, fd, pipeId;\n  215    int64 n;\n  216    fd_t tmpfd;\n  ...\n  219    procfd_t* pfd;\n  220    size_t len, i;\n  221:   int32 prev;\n  222    const char *fdPath, targetPath;\n  223    char* x;\n\n/home/roman/Sources/c-utils/plsconv.c:\n   39  \n   40  static void\n   41: playlist_process(playlist* pl, stralloc* title, stralloc* location, uint32 length) {\n   42    playlist_entry e;\n   43    (void)pl;\n\n/home/roman/Sources/c-utils/query.c:\n    6  #include \"lib/dns.h\"\n    7  #include \"lib/uint64.h\"\n    8: #include \"lib/uint32.h\"\n    9  #include \"lib/uint16.h\"\n   10  #include \"lib/ip4.h\"\n   ..\n   84  \n   85  static void\n   86: cachegeneric(const char type[2], const char* d, const char* data, unsigned int datalen, uint32 ttl) {\n   87    unsigned int len;\n   88    char key[257];\n   ..\n  118  \n  119  static void\n  120: save_finish(const char type[2], const char* d, uint32 ttl) {\n  121    if(!save_ok)\n  122      return;\n  ...\n  129  }\n  130  \n  131: static uint32\n  132  ttlget(char buf[4]) {\n  133:   uint32 ttl;\n  134  \n  135:   uint32_unpack_big(buf, &ttl);\n  136    if(ttl > 1000000000)\n  137      return 0;\n  ...\n  231    int i, j, k, p, q;\n  232    uint16 datalen, numanswers, numauthority, numglue;\n  233:   uint32 ttl, soattl, cnamettl;\n  234    unsigned int cachedlen, dlen, len, posauthority, posglue, pos, pos2, rcode, posanswers;\n  235  \n\n/home/roman/Sources/c-utils/query.h:\n    3  \n    4  #include \"lib/dns.h\"\n    5: #include \"lib/uint32.h\"\n    6  #include \"lib/iopause.h\"\n    7  \n    .\n   19    char servers6[QUERY_MAXLEVEL][256];\n   20    char* alias[QUERY_MAXALIAS];\n   21:   uint32 aliasttl[QUERY_MAXALIAS];\n   22    char localip[16];\n   23    char type[2];\n\n/home/roman/Sources/c-utils/response.c:\n   11  struct names {\n   12    char str[NAMES][128];\n   13:   uint32 ptr[NAMES];\n   14:   uint32 num;\n   15  };\n   16  \n   ..\n   72  \n   73  int\n   74: response_rstart(response* resp, const char* d, const char type[2], uint32 ttl) {\n   75    char ttlstr[4];\n   76    if(!response_addname(resp, d))\n   ..\n   80    if(!response_addbytes(resp, DNS_C_IN, 2))\n   81      return 0;\n   82:   uint32_pack_big(ttlstr, response_hidettl ? 0 : ttl);\n   83    if(!response_addbytes(resp, ttlstr, 4))\n   84      return 0;\n   ..\n  100  char*\n  101  response_getdata(response* resp, size_t* size_ptr) {\n  102:   uint32 pos;\n  103    char* x;\n  104  \n  ...\n  114  \n  115  int\n  116: response_cname(response* resp, const char* c, const char* d, uint32 ttl) {\n  117    if(!response_rstart(resp, c, DNS_T_CNAME, ttl))\n  118      return 0;\n\n/home/roman/Sources/c-utils/response.h:\n    2  #define DNSCACHE_RESPONSE_H\n    3  \n    4: #include \"lib/uint32.h\"\n    5  #include \"lib/stralloc.h\"\n    6  \n    .\n   24    };\n   25  #endif\n   26:   uint32 dpos, tctarget;\n   27  } response;\n   28  \n   ..\n   30  int response_addname(response*, const char*);\n   31  int response_query(response*, const char*, const char[2], const char[2]);\n   32: int response_rstart(response*, const char*, const char[2], uint32);\n   33  void response_rfinish(response*, int);\n   34  char* response_getdata(response*, size_t*);\n   35  int response_send(response*, int, char[], uint16);\n   36: int response_cname(response*, const char*, const char*, uint32);\n   37  void response_nxdomain(response*);\n   38  void response_servfail(response*);\n\n/home/roman/Sources/c-utils/strarraytest.c:\n   84                                   \"lib/tree.h\",\n   85                                   \"lib/uint16.h\",\n   86:                                  \"lib/uint32.h\",\n   87                                   \"lib/uint64.h\",\n   88                                   \"lib/uint8.h\",\n\n/home/roman/Sources/c-utils/tcping.c:\n   44  #include \"lib/scan.h\"\n   45  #include \"lib/byte.h\"\n   46: #include \"lib/uint32.h\"\n   47  \n   48  #include <stdlib.h>\n   ..\n   68  typedef struct {\n   69    bool ip6;\n   70:   uint32 scope_id;\n   71    char ip[16];\n   72  } address_t;\n\n/home/roman/Sources/c-utils/tests/CMakeLists.txt:\n    6  link_directories(${CMAKE_BINARY_DIR})\n    7  \n    8: link_libraries(iarray strlist errmsg path stralloc mmap str taia tai buffer open uint32)\n    9  \n   10  file(GLOB TESTS test_*.c)\n\n/home/roman/Sources/c-utils/tinyproxy.c:\n   75    uint16 port;\n   76    char addr[16];\n   77:   uint32 scope_id;\n   78    fd_t dump;\n   79    int force_write : 1;\n   ..\n  110  socketbuf_t* socket_other(fd_t);\n  111  ssize_t socket_send(fd_t, void* x, size_t n, void* ptr);\n  112: int socket_getlocal_addr(fd_t, int af, char ip[16], uint16* port, uint32* scope_id);\n  113  int socket_connect(socketbuf_t*);\n  114  void socket_accept(fd_t, char addr[16], uint16 port);\n  ...\n  511  \n  512   int\n  513:  socket_getlocal_addr(fd_t sock, int af, char ip[16], uint16* port, uint32* scope_id) {\n  514     int ret = af == AF_INET6 ? socket_local6(sock, ip, port, scope_id) : socket_local4(sock, ip, port);\n  515     return ret;\n  ...\n  871    const char* base;\n  872    char** v;\n  873:   int32 pid, child_pid;\n  874    int status;\n  875    fd_t out = STDOUT_FILENO;\n\n1957 matches across 264 files\n\n\nSearching 2657 files for \"[^a-z]int3\" (regex, case sensitive)\n\n/home/roman/Sources/c-utils/lib/elf.h:\n  441    uint32 r_offset; /* Address */\n  442    uint32 r_info;   /* Relocation type and symbol index */\n  443:   int32 r_addend;  /* Addend */\n  444  } elf32_rela;\n  445  \n  ...\n  562  \n  563  typedef struct {\n  564:   int32 d_tag; /* Dynamic entry type */\n  565    union {\n  566      uint32 d_val; /* Integer value */\n  ...\n  679  #define ELF_DT_AUXILIARY 0x7ffffffd /* Shared object to load before self */\n  680  #define ELF_DT_FILTER 0x7fffffff    /* Shared object to get values from */\n  681: #define ELF_DT_EXTRATAGIDX(tag) ((uint32) - ((int32)(tag) << 1 >> 1) - 1)\n  682  #define ELF_DT_EXTRANUM 3\n  683  \n  ...\n  836  \n  837  typedef struct {\n  838:   int32 a_type; /* Entry type */\n  839    union {\n  840      long int a_val;      /* Integer value */\n  ...\n 1047    uint32 ri_gprmask;    /* General registers used */\n 1048    uint32 ri_cprmask[4]; /* Coprocessor registers used */\n 1049:   int32 ri_gp_value;    /* $gp register value */\n 1050  } elf32_reg_info;\n 1051  \n\n/home/roman/Sources/c-utils/lib/io/io_passfd.c:\n   43  struct cmsghdr {\n   44    size_t cmsg_len;    /* data byte count, including hdr */\n   45:   int32_t cmsg_level; /* originating protocol */\n   46:   int32_t cmsg_type;  /* protocol-specific type */\n   47  };\n   48  #endif\n\n/home/roman/Sources/c-utils/lib/process/process_create.c:\n   58  process_create(const char* filename, const char* argv[], fd_t std[3], const char* cwd) {\n   59    fd_t fds[3];\n   60:   int32 pid;\n   61    int status = 0;\n   62  \n\n/home/roman/Sources/c-utils/lib/safemult.h:\n   36  }\n   37  static inline int\n   38: imult32(int32 a, int32 b, int32* c) {\n   39    return !__builtin_mul_overflow(a, b, c);\n   40  }\n   ..\n   56  \n   57  int umult32(uint32 a, uint32 b, uint32* c);\n   58: int imult32(int32 a, int32 b, int32* c);\n   59  \n   60  int umult64(uint64 a, uint64 b, uint64* c);\n\n/home/roman/Sources/c-utils/lib/safemult/imult16.c:\n   15  int\n   16  imult16(int16 a, int16 b, int16* c) {\n   17:   int32 x = (int32)a * b;\n   18    if((int16)x != x)\n   19      return 0;\n\n/home/roman/Sources/c-utils/lib/safemult/imult32.c:\n    7  \n    8  int\n    9: imult32(int32 a, int32 b, int32* c) {\n   10    return !__builtin_mul_overflow(a, b, c);\n   11  }\n   ..\n   14  \n   15  int\n   16: imult32(int32 a, int32 b, int32* c) {\n   17    int64 x = (int64)a * b;\n   18:   if((int32)x != x)\n   19      return 0;\n   20    *c = x;\n\n/home/roman/Sources/c-utils/lib/uint32.h:\n   24  #elif defined(__UINT32_TYPE__) && defined(__INT32_TYPE__)\n   25  typedef __UINT32_TYPE__ uint32;\n   26: typedef __INT32_TYPE__ int32;\n   27  \n   28: #elif defined(___int32_t_defined) || defined(__BIT_TYPES_DEFINED__)\n   29: typedef u_int32_t uint32;\n   30: typedef int32_t int32;\n   31  \n   32  #elif defined(_MSC_VER)\n   33  #include <windows.h>\n   34  typedef UINT32 uint32;\n   35: typedef INT32 int32;\n   36  \n   37  #elif defined(__MINGW32__) || defined(__MINGW64__)\n   38  typedef uint32_t uint32;\n   39: typedef int32_t int32;\n   40  \n   41  #else\n   ..\n   43  \n   44  #if !(defined(_WINSOCK2API_) && defined(__LCC__))\n   45: typedef int32_t int32;\n   46  #endif\n   47  #endif\n\n/home/roman/Sources/c-utils/CMakeLists.txt:\n  309  if(NOT CROSS)\n  310    check_type_size(int16_t INT16_T)\n  311:   check_type_size(int32_t INT32_T)\n  312    check_type_size(int64_t INT64_T)\n  313    check_type_size(intmax_t INTMAX_T)\n  ...\n 1070    # __int64, int, long, and long long\\n * that exists and is the right size.\\n */\\n#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)\\ntypedef __int64 int64_t;\\n#define HAVE_INT64_T\\n#endif\\n\\n#if !defined(HAVE_INT64_T) && SIZE_OF_INT == 8\\ntypedef int int64_t;\\n#define HAVE_INT64_T\\n#endif\\n\\n#if\n 1071    # !defined(HAVE_INT64_T) && SIZE_OF_LONG == 8\\ntypedef long int64_t;\\n#define HAVE_INT64_T\\n#endif\\n\\n#if !defined(HAVE_INT64_T) && SIZE_OF_LONG_LONG == 8\\ntypedef long long int64_t;\\n#define HAVE_INT64_T\\n#endif\\n\\n#if !defined(HAVE_INT64_T)\\n#error No 64-bit integer type was\n 1072:   # found.\\n#endif\\n\\n/*\\n * Similarly for int32_t\\n */\\n#if !defined(HAVE_INT32_T) && SIZE_OF_INT == 4\\ntypedef int int32_t;\\n#define HAVE_INT32_T\\n#endif\\n\\n#if !defined(HAVE_INT32_T) && SIZE_OF_LONG == 4\\ntypedef long int32_t;\\n#define HAVE_INT32_T\\n#endif\\n\\n#if !defined(HAVE_INT32_T)\\n#error No\n 1073    # 32-bit integer type was found.\\n#endif\\n\\n/*\\n * Similarly for int16_t\\n */\\n#if !defined(HAVE_INT16_T) && SIZE_OF_INT == 2\\ntypedef int int16_t;\\n#define HAVE_INT16_T\\n#endif\\n\\n#if !defined(HAVE_INT16_T) && SIZE_OF_SHORT == 2\\ntypedef short int16_t;\\n#define HAVE_INT16_T\\n#endif\\n\\n#if\n 1074    # !defined(HAVE_INT16_T)\\n#error No 16-bit integer type was found.\\n#endif\\n\\n/*\\n * Similarly for uint64_t\\n */\\n#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)\\ntypedef unsigned __int64 uint64_t;\\n#define HAVE_UINT64_T\\n#endif\\n\\n#if !defined(HAVE_UINT64_T) && SIZE_OF_UNSIGNED ==\n\n/home/roman/Sources/c-utils/cparser/lex.yy.c:\n   45  typedef int16_t flex_int16_t;\n   46  typedef uint16_t flex_uint16_t;\n   47: typedef int32_t flex_int32_t;\n   48  typedef uint32_t flex_uint32_t;\n   49  #else\n   50  typedef signed char flex_int8_t;\n   51  typedef short int flex_int16_t;\n   52: typedef int flex_int32_t;\n   53  typedef unsigned char flex_uint8_t;\n   54  typedef unsigned short int flex_uint16_t;\n   ..\n  348     but its presence is necessary. */\n  349  struct yy_trans_info {\n  350:   flex_int32_t yy_verify;\n  351:   flex_int32_t yy_nxt;\n  352  };\n  353  static const flex_int16_t yy_accept[385] = {\n\n/home/roman/Sources/c-utils/examples/marshal.c:\n  375    assert(sizeof(uint64) == sizeof(uint64));\n  376    assert(sizeof(int16) == sizeof(int16));\n  377:   assert(sizeof(int32) == sizeof(int32));\n  378    assert(sizeof(int64) == sizeof(int64));\n  379  \n\n/home/roman/Sources/c-utils/examples/mult.c:\n    5  main() {\n    6    int16 a;\n    7:   int32 b;\n    8    int64 c;\n    9    uint64 d;\n\n/home/roman/Sources/c-utils/examples/range.c:\n   35  #endif\n   36  \n   37:   assert(__MIN(int32_t) == (int32_t)0x80000000);\n   38:   assert(__MAX(int32_t) == 0x7fffffff);\n   39    assert(__MIN(uint32) == 0);\n   40    assert(__MAX(uint32) == 0xffffffff);\n\n/home/roman/Sources/c-utils/fns.txt:\n 2108  xdr_int\n 2109  xdr_int16_t\n 2110: xdr_int32_t\n 2111  xdr_int64_t\n 2112  xdr_int8_t\n\n/home/roman/Sources/c-utils/genmakefile.c:\n 1469  \n 1470    if(byte_chr(x, len, '/') == len && byte_ends(x, len, \"strlist_shift.c\"))\n 1471:     asm(\"int3\");\n 1472  \n 1473    if(is_source_b(x, len) || is_include_b(x, len)) {\n ....\n 1694        const char* s = \"strlist_shift.c\";\n 1695        if(stralloc_endsb(&real, s, str_len(s)))\n 1696:         asm(\"int3\");\n 1697      }\n 1698  \n ....\n 1970  #endif\n 1971  \n 1972:     asm(\"int3\");\n 1973    }\n 1974  \n\n/home/roman/Sources/c-utils/lib/elf.h:\n  441    uint32 r_offset; /* Address */\n  442    uint32 r_info;   /* Relocation type and symbol index */\n  443:   int32 r_addend;  /* Addend */\n  444  } elf32_rela;\n  445  \n  ...\n  562  \n  563  typedef struct {\n  564:   int32 d_tag; /* Dynamic entry type */\n  565    union {\n  566      uint32 d_val; /* Integer value */\n  ...\n  679  #define ELF_DT_AUXILIARY 0x7ffffffd /* Shared object to load before self */\n  680  #define ELF_DT_FILTER 0x7fffffff    /* Shared object to get values from */\n  681: #define ELF_DT_EXTRATAGIDX(tag) ((uint32) - ((int32)(tag) << 1 >> 1) - 1)\n  682  #define ELF_DT_EXTRANUM 3\n  683  \n  ...\n  836  \n  837  typedef struct {\n  838:   int32 a_type; /* Entry type */\n  839    union {\n  840      long int a_val;      /* Integer value */\n  ...\n 1047    uint32 ri_gprmask;    /* General registers used */\n 1048    uint32 ri_cprmask[4]; /* Coprocessor registers used */\n 1049:   int32 ri_gp_value;    /* $gp register value */\n 1050  } elf32_reg_info;\n 1051  \n\n/home/roman/Sources/c-utils/lib/io/io_passfd.c:\n   43  struct cmsghdr {\n   44    size_t cmsg_len;    /* data byte count, including hdr */\n   45:   int32_t cmsg_level; /* originating protocol */\n   46:   int32_t cmsg_type;  /* protocol-specific type */\n   47  };\n   48  #endif\n\n/home/roman/Sources/c-utils/lib/process/process_create.c:\n   58  process_create(const char* filename, const char* argv[], fd_t std[3], const char* cwd) {\n   59    fd_t fds[3];\n   60:   int32 pid;\n   61    int status = 0;\n   62  \n\n/home/roman/Sources/c-utils/lib/safemult.h:\n   36  }\n   37  static inline int\n   38: imult32(int32 a, int32 b, int32* c) {\n   39    return !__builtin_mul_overflow(a, b, c);\n   40  }\n   ..\n   56  \n   57  int umult32(uint32 a, uint32 b, uint32* c);\n   58: int imult32(int32 a, int32 b, int32* c);\n   59  \n   60  int umult64(uint64 a, uint64 b, uint64* c);\n\n/home/roman/Sources/c-utils/lib/safemult/imult16.c:\n   15  int\n   16  imult16(int16 a, int16 b, int16* c) {\n   17:   int32 x = (int32)a * b;\n   18    if((int16)x != x)\n   19      return 0;\n\n/home/roman/Sources/c-utils/lib/safemult/imult32.c:\n    7  \n    8  int\n    9: imult32(int32 a, int32 b, int32* c) {\n   10    return !__builtin_mul_overflow(a, b, c);\n   11  }\n   ..\n   14  \n   15  int\n   16: imult32(int32 a, int32 b, int32* c) {\n   17    int64 x = (int64)a * b;\n   18:   if((int32)x != x)\n   19      return 0;\n   20    *c = x;\n\n/home/roman/Sources/c-utils/lib/uint32.h:\n   24  #elif defined(__UINT32_TYPE__) && defined(__INT32_TYPE__)\n   25  typedef __UINT32_TYPE__ uint32;\n   26: typedef __INT32_TYPE__ int32;\n   27  \n   28: #elif defined(___int32_t_defined) || defined(__BIT_TYPES_DEFINED__)\n   29: typedef u_int32_t uint32;\n   30: typedef int32_t int32;\n   31  \n   32  #elif defined(_MSC_VER)\n   33  #include <windows.h>\n   34  typedef UINT32 uint32;\n   35: typedef INT32 int32;\n   36  \n   37  #elif defined(__MINGW32__) || defined(__MINGW64__)\n   38  typedef uint32_t uint32;\n   39: typedef int32_t int32;\n   40  \n   41  #else\n   ..\n   43  \n   44  #if !(defined(_WINSOCK2API_) && defined(__LCC__))\n   45: typedef int32_t int32;\n   46  #endif\n   47  #endif\n\n/home/roman/Sources/c-utils/list-r.c:\n   91  static int64 opt_minsize = -1;\n   92  static long opt_depth = -1;\n   93: static uint32 opt_types = (uint32)(int32)-1;\n   94  static const char* opt_relative_to = 0;\n   95  static const char* opt_timestyle = \"%b %2e %H:%M\";\n   ..\n  420  \n  421  static void\n  422: make_num(stralloc* out, int32 num, uint32 width) {\n  423    char fmt[FMT_ULONG + 1];\n  424    size_t sz = fmt_int(fmt, num);\n\n/home/roman/Sources/c-utils/macho32list.c:\n   78            if(defined_in_section && symbol->n_sect == text_section_index && symbol->n_type & MACHO_N_EXT) {\n   79              char* name;\n   80:             int32 string_offset;\n   81  \n   82              string_offset = symbol->n_strx;\n\n/home/roman/Sources/c-utils/pipeinfo.c:\n   34  typedef struct procfd {\n   35    struct procfd* next;\n   36:   int32 pid;\n   37:   int32 fd;\n   38    struct stat st;\n   39    stralloc info;\n   ..\n  171  \n  172  void\n  173: proc_fd_root(int32 pid, stralloc* out) {\n  174    stralloc_zero(out);\n  175    stralloc_cats(out, \"/proc/\");\n  ...\n  179  \n  180  const char*\n  181: proc_subdir_path(int32 pid, const char* subdir, stralloc* out) {\n  182    stralloc_zero(out);\n  183    proc_fd_root(pid, out);\n  ...\n  188  \n  189  const char*\n  190: proc_fd_path(int32 pid, fd_t fd, stralloc* out) {\n  191    proc_subdir_path(pid, \"fd\", out);\n  192    if(fd >= 0)\n  ...\n  196  }\n  197  const char*\n  198: proc_fdinfo_path(int32 pid, fd_t fd, stralloc* out) {\n  199    proc_subdir_path(pid, \"fdinfo\", out);\n  200    if(fd >= 0)\n  ...\n  219    procfd_t* pfd;\n  220    size_t len, i;\n  221:   int32 prev;\n  222    const char *fdPath, targetPath;\n  223    char* x;\n\n/home/roman/Sources/c-utils/tinyproxy.c:\n  871    const char* base;\n  872    char** v;\n  873:   int32 pid, child_pid;\n  874    int status;\n  875    fd_t out = STDOUT_FILENO;\n\n96 matches across 25 files\n\n\nSearching 2657 files for \"[^a-z]int3[^a-z0-9]\" (regex, case sensitive)\n\n/home/roman/Sources/c-utils/genmakefile.c:\n 1469  \n 1470    if(byte_chr(x, len, '/') == len && byte_ends(x, len, \"strlist_shift.c\"))\n 1471:     asm(\"int3\");\n 1472  \n 1473    if(is_source_b(x, len) || is_include_b(x, len)) {\n ....\n 1694        const char* s = \"strlist_shift.c\";\n 1695        if(stralloc_endsb(&real, s, str_len(s)))\n 1696:         asm(\"int3\");\n 1697      }\n 1698  \n ....\n 1970  #endif\n 1971  \n 1972:     asm(\"int3\");\n 1973    }\n 1974  \n\n3 matches in 1 file\n",
			"settings":
			{
				"buffer_size": 211792,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "/home/roman/Sources/c-utils/genmakefile.c",
			"settings":
			{
				"buffer_size": 144523,
				"line_ending": "Unix"
			}
		},
		{
			"file": "CMakeLists.txt",
			"settings":
			{
				"buffer_size": 64607,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "response.c",
			"settings":
			{
				"buffer_size": 3254,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		},
		{
			"file": "response.h",
			"settings":
			{
				"buffer_size": 1113,
				"line_ending": "Unix"
			}
		},
		{
			"file": "lib/io/io_dump.c",
			"settings":
			{
				"buffer_size": 623,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"install pa",
				"Package Control: Install Package"
			],
			[
				"adva",
				"Package Control: Advanced Install Package"
			],
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"svgo",
				"SVGO: Prettify SVG"
			],
			[
				"ctag",
				"CTags: Rebuild Tags"
			],
			[
				"rebuild",
				"CTags: Rebuild Tags"
			],
			[
				"ctags",
				"CTags: Rebuild Tags"
			],
			[
				"outlin",
				"Browse Mode: Outline (Right)"
			],
			[
				"install p",
				"Package Control: Install Package"
			],
			[
				"tags",
				"CTags: Rebuild Tags"
			],
			[
				"extra",
				"Extract Sublime Package: Extract all packages"
			],
			[
				"extrac",
				"Extract Sublime Package: Extract all packages"
			],
			[
				"add re",
				"Package Control: Add Repository"
			],
			[
				"outline",
				"Browse Mode: Outline (Right)"
			],
			[
				"remove",
				"Package Control: Remove Package"
			]
		],
		"width": 0.0
	},
	"console":
	{
		"height": 205.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/roman/Dokumente/Sources/c-utils"
	],
	"file_history":
	[
		"/home/roman/Dokumente/Sources/c-utils/logserial.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/io/io_waituntil2.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/iarray/iarray_get.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/iarray/iarray_allocate.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/iarray/iarray_free.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/iarray/iarray_length.c",
		"/home/roman/Sources/c-utils/lib/io/io_fd.c",
		"/home/roman/Dokumente/Sources/c-utils/CMakeLists.txt",
		"/home/roman/Dokumente/Sources/c-utils/lib/socket/socket_getifname.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/io/io_wantwrite.c",
		"/home/roman/Sources/c-utils/cc-wrap.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/io/io_dump.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/io.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/io/io_nonblock.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/buffer/buffer_get.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/buffer/buffer_putc.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/io_internal.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/buffer/buffer_stubborn.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/buffer/buffer_flush.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/buffer.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/buffer/buffer_init_free.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/buffer/buffer_write.c",
		"/home/roman/Dokumente/Sources/plot-cv/firmware/connect.sh",
		"/home/roman/Dokumente/Sources/c-utils/lib/socket/socket_getifidx.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/process/process_create.c",
		"/home/roman/Sources/c-utils/lib/socket_internal.h",
		"/home/roman/Dokumente/Sources/c-utils/cofflist.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/coff/coff_line_numbers.c",
		"/home/roman/Dokumente/Sources/c-utils/scripts/gen-pro-template.sh",
		"/home/roman/Dokumente/Sources/c-utils/cfg.sh",
		"/home/roman/Dokumente/Sources/c-utils/tinyproxy.c",
		"/home/roman/Sources/c-utils/ar-wrap.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/wait.h",
		"/home/roman/Dokumente/Sources/c-utils/pkgcfg.c",
		"/home/roman/Downloads/gcode (4).gcode",
		"/home/roman/Dokumente/Sources/c-utils/lib/omf.h",
		"/home/roman/Dokumente/Sources/c-utils/omflist.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/omf/omf_record_next.c",
		"/home/roman/Dokumente/Sources/shish/cfg-cmake.sh",
		"/home/roman/Dokumente/Sources/c-utils/lib/process.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/wait/wait_pid.c",
		"/home/roman/Sources/c-utils/lib/socket/socket_getifidx.c",
		"/home/roman/Dokumente/Sources/c-utils/omf.h",
		"/home/roman/Dokumente/Sources/c-utils/ar-wrap.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/str.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/str/str_find.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/str/str_findb.c",
		"/home/roman/Dokumente/Sources/c-utils/genmakefile.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/unix/wordexp.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/typedefs.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/dir/dir_open.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/dir/dir_type.c",
		"/home/roman/Sources/c-utils/lib/dir_internal.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/dir_internal.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/dir/dir_time.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/process/process_wait.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/unix/glob.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/wait/wait_nohang.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/wait/waitn_reap.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/wait/wait_pid_nohang.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/wait/waitn.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/dir.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/unix/pipe2.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/str/str_chrs.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/str/str_chr.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/stralloc/stralloc_replace.c",
		"/home/roman/Dokumente/Sources/c-utils/build/cmake/config.h.cmake",
		"/home/roman/Dokumente/Sources/c-utils/3rdparty/openssl/external/perl/Text-Template-1.46/t/02-hash.t",
		"/home/roman/Dokumente/Sources/c-utils/lib/path.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/stralloc/stralloc_ends.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/stralloc/stralloc_endb.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/stralloc/stralloc_endsb.c",
		"/home/roman/Dokumente/Sources/c-utils/genmakefile.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/set.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/set/set_adds.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/set/set_add.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/strarray.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/wait/waitpid_nointr.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/stralloc.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/str/str_diff.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/str/str_rchrs.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/byte/byte_chrs.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/byte/byte_rchrs.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/byte.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/byte/byte_findb.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/strarray/strarray_pushb_unique.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/strarray/strarray_pushb.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/strarray/strarray_index_of.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/path/path_exists.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/sig.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/str/str_start.c",
		"/home/roman/Dokumente/Sources/c-utils/eagle-gen-cmds.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/byte/byte_equal.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/byte/byte_starts.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/byte/byte_ends.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/byte/byte_startb.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/byte/byte_endb.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/byte/byte_diff.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/byte/byte_finds.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/str/str_end.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/str/str_endb.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/str/str_startb.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/str/str_rfindb.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/xml.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/xml/xml_has_attribute.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/byte/byte_skip.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/http/http_socket_write.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/http/http_socket_read.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/http/http_read_internal.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/http.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/buffer/buffer_getline.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/stralloc/buffer_getline_sa.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/byte/byte_trimr.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/stralloc/stralloc_trimr.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/byte/byte_count.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/http/http_read_header.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/http/http_read.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/http/http_errstr.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/http/http_ssl_socket.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/http/http_get.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/http/http_ssl_connect.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/ucs/str_utf8_latin.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/stralloc/stralloc_replaces.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/fmt/fmt_escapecharxml.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/fmt.h",
		"/home/roman/Dokumente/Sources/c-utils/lib/fmt/fmt_escapecharquotedshell.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/stralloc/buffer_puts_escaped.c",
		"/home/roman/Dokumente/Sources/c-utils/lib/fmt/fmt_escapecharshell.c"
	],
	"find":
	{
		"height": 40.0
	},
	"find_in_files":
	{
		"height": 142.0,
		"where_history":
		[
			"/home/roman/Sources/c-utils/lib,*.c,*.h,*.txt,/home/roman/Sources/c-utils,*.c,*.h,-*/3rdparty/*,-*/build/*",
			"/home/roman/Sources/c-utils/lib,*.c,*.h,*.txt,/home/roman/Sources/c-utils,*.c,*.h,-*/3rdparty/*",
			"/home/roman/Sources/c-utils/lib,*.c,*.h,*.txt,/home/roman/Sources/c-utils,*.c,*.h",
			"/home/roman/Dokumente/Sources/c-utils/lib,*.c,*.h,*.txt",
			"/home/roman/Dokumente/Sources/c-utils/lib,*.c,*.h",
			"/home/roman/Dokumente/Sources/c-utils,*.c,*.h",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": true,
		"find_history":
		[
			"remove_port",
			"^includes_add",
			"includes",
			"'I'",
			"\"CPPFLAGS",
			"doesn't",
			"[^a-z]int3[^a-z0-9]",
			"[^a-z]int3",
			"int3",
			"sources:",
			"\"toks",
			"toks",
			"toks:",
			"baudrate",
			"57600",
			"io_dump",
			"debugmode",
			"io_dump",
			"#ifdef DEBUG_OUTPUT([^#]*)#endif",
			"DEBUG_OUTPUT",
			"debugmode",
			"rawmode",
			"stralloc",
			"resp",
			"response_addbytes",
			"debug_opt",
			"DEBUG_HTTP",
			"DEBUG",
			"debug_option",
			"DEBUG_OUTPUT",
			"DEBUG_IO",
			"DEBUG_DEBUG",
			"DEBUG_OUTPUT",
			"io_dump",
			"Read ",
			"io_dum",
			"iarray_",
			"iarray",
			"iarray_allocate\\(",
			"iarray_allocate",
			"SUPPORT_\\$",
			"SUPPORT_",
			"entry",
			"for.*get",
			"i <= s",
			"->want",
			"DEBUG_OUT",
			"EPOLL",
			"HAVE_EPOLL",
			"epoll_wait",
			"io_want",
			"charbuf_getc",
			"io_fd",
			"Read ",
			"putlong",
			"send_file, ",
			"send_file",
			"queue =",
			"write_fd",
			"usage",
			"stubborn",
			"ch =",
			"ch;",
			"main",
			"MUX_",
			" EPOLL",
			"HAVE_EPOLL",
			"EPOLL",
			"Aux se",
			"define\\s+USE_SELECT",
			"define.*USE_SELECT",
			"USE_SELE",
			"USE_SEL",
			"ifn2idx",
			"if_nametoindex",
			"VERBOSE_MAK",
			"unistd.h",
			"echo.*host",
			"cfg-msys",
			"^\\s*message\\(",
			"check_type",
			"type_size",
			"check_size",
			"CROSS",
			"CMAKE_CROSS",
			"cfg-msys",
			"IPHLP",
			"HAVE_N2I",
			"TOOLCHAIN",
			"HAVE.*MUX",
			"MUX_METHOD",
			"EPOLL",
			"io_wanted_fds",
			"USE_SELECT",
			"wanted_fd",
			"wanted",
			"MUX_METHOD",
			" POLL\\)",
			"\\(POLL",
			"POLL",
			"HAVE_POLL",
			"HAVE_",
			"tinyprox",
			"process_cr",
			"spawn",
			"fork",
			"spawn",
			"check_functions",
			"check_func",
			"POSIX_SPAWN",
			"wait_pid",
			"process_crea",
			"process_create",
			"vfork",
			"MSWSOCK",
			"closelog",
			"wait.pid",
			"wait-pi",
			"alloc_",
			"server_tar_files",
			"localtime_r",
			"localtime",
			"def.*USE_READDIR",
			"_TYPE",
			"d_TYPE",
			"d_type",
			"HAVE_CONFIG_H",
			"USE_READ"
		],
		"highlight": false,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
			"if(debugmode) {\\1}",
			"idx2ifn",
			"ifn2idx",
			"set_iterator_t",
			"end",
			"isleap",
			"&sa->s",
			"#",
			"http_ssl2errno(h,",
			" errno =",
			"ret =",
			"SSL_get_error(h->ssl, ",
			"SSL_get_error(h->ssl",
			"v.",
			"num_prereqs",
			"buffer_putsflush(buffer_2,  debug_nl);",
			";\\n#endif",
			"#endif",
			"out.",
			"sa",
			"b->",
			"C",
			"uint32",
			"C",
			"to C",
			"C++",
			"n",
			"x",
			"resp->len",
			"og_string(\"udp\");",
			"",
			"errstr()",
			"111, FATAL, \"",
			"",
			"data->",
			"diesys(111, fatal,",
			"die(111, fatal,",
			"die(111, ",
			"diesys(111, ",
			"code",
			"ustar",
			"\\1addr.ip",
			"size_t",
			"",
			"->data.elem_size",
			"dns_cache",
			"sb->",
			"sockbuf_fmt_addr",
			"data_numlines",
			"sock",
			"DEBUG_OUTPUT_",
			" \\\\",
			"iarray",
			"c->proxy.",
			"c->client.",
			"INET",
			"plog",
			"term_buf.fd",
			" ",
			"uint16",
			" ",
			"_1, \", "
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 710,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"color_scheme": "Packages/Outline/outline.hidden-tmTheme",
							"current_file": "/home/roman/Dokumente/Sources/c-utils/logserial.c",
							"outline_rename_mode": false,
							"symkeys":
							[
								[
									8,
									23
								],
								[
									34,
									45
								],
								[
									723,
									727
								],
								[
									752,
									758
								],
								[
									775,
									779
								],
								[
									879,
									885
								],
								[
									1319,
									1330
								],
								[
									1597,
									1606
								],
								[
									1779,
									1790
								],
								[
									1967,
									1978
								],
								[
									2210,
									2219
								],
								[
									3387,
									3399
								],
								[
									5550,
									5561
								],
								[
									5708,
									5717
								],
								[
									7054,
									7066
								],
								[
									7805,
									7819
								],
								[
									8383,
									8386
								],
								[
									8570,
									8582
								],
								[
									11963,
									11968
								],
								[
									12676,
									12690
								],
								[
									12940,
									12944
								]
							],
							"symlist":
							[
								"\tâ“‚â€‚â€ƒ_POSIX_C_SOURCEâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
								"\tâ“‚â€‚â€ƒ_GNU_SOURCEâ€ƒâ€¦â€ƒâ€”â€ƒmacro object",
								"â€”â’¸â€“â€ƒportâ€ƒ{â€‰â€¦â€‰}â€‰;â€ƒâ€”â€ƒtype",
								"\tâ“‰â€‚â€ƒport_tâ€‰;â€ƒâ€”â€ƒtypedef",
								"â€”â’¸â€“â€ƒlinkâ€ƒ{â€‰â€¦â€‰}â€‰;â€ƒâ€”â€ƒtype",
								"\tâ“‰â€‚â€ƒlink_tâ€‰;â€ƒâ€”â€ƒtypedef",
								"â€”â’»â€“â€ƒdir_entriesâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
								"â€”â’»â€“â€ƒfind_portâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
								"â€”â’»â€“â€ƒremove_portâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
								"â€”â’»â€“â€ƒclear_portsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
								"â€”â’»â€“â€ƒget_portsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
								"â€”â’»â€“â€ƒserial_portsâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
								"â€”â’»â€“â€ƒserial_readâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
								"â€”â’»â€“â€ƒterm_initâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
								"â€”â’»â€“â€ƒterm_restoreâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
								"â€”â’»â€“â€ƒprocess_serialâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
								"â€”â“‚â€“â€ƒmaxâ€‰(â€‰)â€ƒâ€¦â€ƒâ€”â€ƒmacro function",
								"â€”â’»â€“â€ƒprocess_loopâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
								"â€”â’»â€“â€ƒusageâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
								"â€”â’»â€“â€ƒsignal_handlerâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction",
								"â€”â’»â€“â€ƒmainâ€‰(â€‰)â€ƒ{â€‰â€¦â€‰}â€ƒâ€”â€ƒfunction"
							],
							"syntax": "Packages/Outline/outline.hidden-tmLanguage",
							"tab_size": 3,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				}
			]
		},
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 1,
					"file": "lib/io/io_wantread.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2936,
						"regions":
						{
						},
						"selection":
						[
							[
								512,
								512
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1566.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "logserial.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16701,
						"regions":
						{
						},
						"selection":
						[
							[
								1958,
								1958
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1236.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "genmakefile.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7835,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C11/C11.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "genmakefile.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 144523,
						"regions":
						{
						},
						"selection":
						[
							[
								17899,
								17899
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 13152.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "lib/path.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2612,
						"regions":
						{
						},
						"selection":
						[
							[
								771,
								771
							]
						],
						"settings":
						{
							"syntax": "Packages/C11/C11.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 6,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 211792,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										172,
										176
									],
									[
										294,
										298
									],
									[
										450,
										454
									],
									[
										589,
										593
									],
									[
										622,
										626
									],
									[
										663,
										667
									],
									[
										909,
										913
									],
									[
										976,
										980
									],
									[
										1018,
										1022
									],
									[
										1051,
										1055
									],
									[
										1085,
										1089
									],
									[
										1122,
										1126
									],
									[
										1195,
										1199
									],
									[
										1347,
										1351
									],
									[
										1533,
										1537
									],
									[
										1563,
										1567
									],
									[
										1605,
										1609
									],
									[
										1649,
										1653
									],
									[
										1689,
										1693
									],
									[
										1719,
										1723
									],
									[
										1847,
										1851
									],
									[
										1911,
										1915
									],
									[
										1938,
										1942
									],
									[
										1970,
										1974
									],
									[
										2106,
										2110
									],
									[
										2181,
										2185
									],
									[
										2428,
										2432
									],
									[
										2478,
										2482
									],
									[
										2583,
										2587
									],
									[
										2806,
										2810
									],
									[
										2872,
										2876
									],
									[
										2941,
										2945
									],
									[
										3017,
										3021
									],
									[
										3225,
										3229
									],
									[
										3347,
										3351
									],
									[
										3423,
										3427
									],
									[
										3633,
										3637
									],
									[
										3713,
										3717
									],
									[
										3751,
										3755
									],
									[
										3778,
										3782
									],
									[
										3987,
										3991
									],
									[
										4056,
										4060
									],
									[
										4197,
										4201
									],
									[
										4336,
										4340
									],
									[
										4633,
										4637
									],
									[
										4695,
										4699
									],
									[
										4787,
										4791
									],
									[
										4873,
										4877
									],
									[
										5121,
										5125
									],
									[
										5186,
										5190
									],
									[
										5417,
										5421
									],
									[
										5490,
										5494
									],
									[
										5504,
										5508
									],
									[
										5697,
										5701
									],
									[
										5815,
										5819
									],
									[
										5915,
										5919
									],
									[
										6095,
										6099
									],
									[
										6365,
										6369
									],
									[
										6532,
										6536
									],
									[
										6723,
										6727
									],
									[
										6809,
										6813
									],
									[
										6840,
										6844
									],
									[
										6869,
										6873
									],
									[
										6977,
										6981
									],
									[
										7000,
										7004
									],
									[
										7019,
										7023
									],
									[
										7139,
										7143
									],
									[
										7272,
										7276
									],
									[
										7458,
										7462
									],
									[
										7656,
										7660
									],
									[
										7721,
										7725
									],
									[
										7794,
										7798
									],
									[
										7872,
										7876
									],
									[
										7950,
										7954
									],
									[
										8293,
										8297
									],
									[
										8587,
										8591
									],
									[
										8842,
										8846
									],
									[
										8910,
										8914
									],
									[
										8959,
										8963
									],
									[
										9009,
										9013
									],
									[
										9079,
										9083
									],
									[
										9135,
										9139
									],
									[
										9193,
										9197
									],
									[
										9253,
										9257
									],
									[
										9320,
										9324
									],
									[
										9374,
										9378
									],
									[
										9497,
										9501
									],
									[
										9565,
										9569
									],
									[
										9848,
										9852
									],
									[
										9908,
										9912
									],
									[
										10149,
										10153
									],
									[
										10212,
										10216
									],
									[
										10257,
										10261
									],
									[
										10457,
										10461
									],
									[
										10664,
										10668
									],
									[
										10704,
										10708
									],
									[
										10835,
										10839
									],
									[
										10875,
										10879
									],
									[
										10939,
										10943
									],
									[
										11046,
										11050
									],
									[
										11091,
										11095
									],
									[
										11143,
										11147
									],
									[
										11199,
										11203
									],
									[
										11256,
										11260
									],
									[
										11309,
										11313
									],
									[
										11364,
										11368
									],
									[
										11410,
										11414
									],
									[
										11513,
										11517
									],
									[
										11558,
										11562
									],
									[
										11749,
										11753
									],
									[
										11816,
										11820
									],
									[
										11861,
										11865
									],
									[
										12144,
										12148
									],
									[
										12155,
										12159
									],
									[
										12355,
										12359
									],
									[
										12413,
										12417
									],
									[
										12480,
										12484
									],
									[
										12704,
										12708
									],
									[
										12762,
										12766
									],
									[
										12829,
										12833
									],
									[
										12970,
										12974
									],
									[
										13030,
										13034
									],
									[
										13177,
										13181
									],
									[
										13237,
										13241
									],
									[
										13480,
										13484
									],
									[
										13576,
										13580
									],
									[
										13643,
										13647
									],
									[
										13875,
										13879
									],
									[
										13971,
										13975
									],
									[
										14038,
										14042
									],
									[
										14192,
										14196
									],
									[
										14360,
										14364
									],
									[
										14423,
										14427
									],
									[
										14575,
										14579
									],
									[
										14743,
										14747
									],
									[
										14806,
										14810
									],
									[
										14945,
										14949
									],
									[
										15093,
										15097
									],
									[
										15153,
										15157
									],
									[
										15219,
										15223
									],
									[
										15323,
										15327
									],
									[
										15383,
										15387
									],
									[
										15449,
										15453
									],
									[
										15619,
										15623
									],
									[
										15669,
										15673
									],
									[
										15862,
										15866
									],
									[
										15936,
										15940
									],
									[
										16074,
										16078
									],
									[
										16141,
										16145
									],
									[
										16331,
										16335
									],
									[
										16391,
										16395
									],
									[
										16454,
										16458
									],
									[
										16667,
										16671
									],
									[
										16793,
										16797
									],
									[
										16841,
										16845
									],
									[
										16960,
										16964
									],
									[
										17022,
										17026
									],
									[
										17068,
										17072
									],
									[
										17113,
										17117
									],
									[
										17167,
										17171
									],
									[
										17261,
										17265
									],
									[
										17323,
										17327
									],
									[
										17369,
										17373
									],
									[
										17414,
										17418
									],
									[
										17468,
										17472
									],
									[
										17629,
										17633
									],
									[
										17837,
										17841
									],
									[
										18041,
										18045
									],
									[
										18305,
										18309
									],
									[
										18589,
										18593
									],
									[
										18660,
										18664
									],
									[
										18893,
										18897
									],
									[
										18989,
										18993
									],
									[
										19060,
										19064
									],
									[
										19074,
										19078
									],
									[
										19320,
										19324
									],
									[
										19576,
										19580
									],
									[
										19765,
										19769
									],
									[
										19840,
										19844
									],
									[
										20001,
										20005
									],
									[
										20214,
										20218
									],
									[
										20572,
										20576
									],
									[
										20638,
										20642
									],
									[
										20697,
										20701
									],
									[
										20754,
										20758
									],
									[
										20903,
										20907
									],
									[
										21014,
										21018
									],
									[
										21203,
										21207
									],
									[
										21306,
										21310
									],
									[
										21415,
										21419
									],
									[
										21622,
										21626
									],
									[
										21729,
										21733
									],
									[
										21888,
										21892
									],
									[
										22003,
										22007
									],
									[
										22155,
										22159
									],
									[
										22307,
										22311
									],
									[
										22435,
										22439
									],
									[
										22613,
										22617
									],
									[
										22848,
										22852
									],
									[
										23092,
										23096
									],
									[
										23253,
										23257
									],
									[
										23264,
										23268
									],
									[
										23447,
										23451
									],
									[
										23543,
										23547
									],
									[
										23656,
										23660
									],
									[
										23798,
										23802
									],
									[
										23834,
										23838
									],
									[
										24020,
										24024
									],
									[
										24096,
										24100
									],
									[
										24107,
										24111
									],
									[
										24219,
										24223
									],
									[
										24426,
										24430
									],
									[
										24482,
										24486
									],
									[
										24666,
										24670
									],
									[
										24831,
										24835
									],
									[
										24986,
										24990
									],
									[
										25148,
										25152
									],
									[
										25219,
										25223
									],
									[
										25290,
										25294
									],
									[
										25481,
										25485
									],
									[
										25590,
										25594
									],
									[
										25613,
										25617
									],
									[
										25745,
										25749
									],
									[
										25769,
										25773
									],
									[
										25791,
										25795
									],
									[
										25895,
										25899
									],
									[
										26002,
										26006
									],
									[
										26089,
										26093
									],
									[
										26115,
										26119
									],
									[
										26138,
										26142
									],
									[
										26166,
										26170
									],
									[
										26270,
										26274
									],
									[
										26454,
										26458
									],
									[
										26508,
										26512
									],
									[
										26573,
										26577
									],
									[
										26648,
										26652
									],
									[
										26695,
										26699
									],
									[
										26827,
										26831
									],
									[
										26848,
										26852
									],
									[
										26956,
										26960
									],
									[
										26977,
										26981
									],
									[
										27029,
										27033
									],
									[
										27053,
										27057
									],
									[
										27077,
										27081
									],
									[
										27102,
										27106
									],
									[
										27185,
										27189
									],
									[
										27209,
										27213
									],
									[
										27352,
										27356
									],
									[
										27421,
										27425
									],
									[
										27831,
										27835
									],
									[
										27916,
										27920
									],
									[
										28081,
										28085
									],
									[
										28103,
										28107
									],
									[
										28125,
										28129
									],
									[
										28149,
										28153
									],
									[
										28172,
										28176
									],
									[
										28196,
										28200
									],
									[
										28220,
										28224
									],
									[
										28243,
										28247
									],
									[
										28270,
										28274
									],
									[
										28502,
										28506
									],
									[
										28583,
										28587
									],
									[
										28667,
										28671
									],
									[
										28748,
										28752
									],
									[
										28824,
										28828
									],
									[
										28912,
										28916
									],
									[
										28990,
										28994
									],
									[
										29068,
										29072
									],
									[
										29181,
										29185
									],
									[
										29308,
										29312
									],
									[
										29329,
										29333
									],
									[
										29354,
										29358
									],
									[
										29378,
										29382
									],
									[
										29401,
										29405
									],
									[
										29425,
										29429
									],
									[
										29553,
										29557
									],
									[
										29580,
										29584
									],
									[
										29613,
										29617
									],
									[
										29726,
										29730
									],
									[
										29747,
										29751
									],
									[
										29885,
										29889
									],
									[
										29906,
										29910
									],
									[
										30047,
										30051
									],
									[
										30068,
										30072
									],
									[
										30093,
										30097
									],
									[
										30120,
										30124
									],
									[
										30147,
										30151
									],
									[
										30175,
										30179
									],
									[
										30203,
										30207
									],
									[
										30230,
										30234
									],
									[
										30257,
										30261
									],
									[
										30281,
										30285
									],
									[
										30303,
										30307
									],
									[
										30330,
										30334
									],
									[
										30355,
										30359
									],
									[
										30385,
										30389
									],
									[
										30414,
										30418
									],
									[
										30446,
										30450
									],
									[
										30477,
										30481
									],
									[
										30504,
										30508
									],
									[
										30529,
										30533
									],
									[
										30556,
										30560
									],
									[
										30676,
										30680
									],
									[
										30706,
										30710
									],
									[
										30827,
										30831
									],
									[
										30856,
										30860
									],
									[
										30884,
										30888
									],
									[
										30912,
										30916
									],
									[
										30937,
										30941
									],
									[
										30962,
										30966
									],
									[
										30989,
										30993
									],
									[
										31016,
										31020
									],
									[
										31041,
										31045
									],
									[
										31066,
										31070
									],
									[
										31095,
										31099
									],
									[
										31124,
										31128
									],
									[
										31163,
										31167
									],
									[
										31292,
										31296
									],
									[
										31313,
										31317
									],
									[
										31338,
										31342
									],
									[
										31362,
										31366
									],
									[
										31469,
										31473
									],
									[
										31656,
										31660
									],
									[
										31753,
										31757
									],
									[
										31926,
										31930
									],
									[
										32036,
										32040
									],
									[
										32069,
										32073
									],
									[
										32163,
										32167
									],
									[
										32213,
										32217
									],
									[
										32363,
										32367
									],
									[
										32413,
										32417
									],
									[
										32463,
										32467
									],
									[
										32513,
										32517
									],
									[
										32563,
										32567
									],
									[
										32601,
										32605
									],
									[
										32635,
										32639
									],
									[
										32758,
										32762
									],
									[
										32791,
										32795
									],
									[
										32933,
										32937
									],
									[
										32971,
										32975
									],
									[
										33023,
										33027
									],
									[
										33098,
										33102
									],
									[
										33154,
										33158
									],
									[
										33200,
										33204
									],
									[
										33315,
										33319
									],
									[
										33347,
										33351
									],
									[
										33369,
										33373
									],
									[
										33396,
										33400
									],
									[
										33506,
										33510
									],
									[
										33528,
										33532
									],
									[
										33623,
										33627
									],
									[
										33659,
										33663
									],
									[
										33693,
										33697
									],
									[
										33743,
										33747
									],
									[
										33791,
										33795
									],
									[
										33839,
										33843
									],
									[
										33874,
										33878
									],
									[
										33915,
										33919
									],
									[
										33957,
										33961
									],
									[
										33993,
										33997
									],
									[
										34088,
										34092
									],
									[
										34115,
										34119
									],
									[
										34148,
										34152
									],
									[
										34182,
										34186
									],
									[
										34304,
										34308
									],
									[
										34326,
										34330
									],
									[
										34421,
										34425
									],
									[
										34457,
										34461
									],
									[
										34491,
										34495
									],
									[
										34724,
										34728
									],
									[
										34866,
										34870
									],
									[
										34899,
										34903
									],
									[
										35044,
										35048
									],
									[
										35077,
										35081
									],
									[
										35172,
										35176
									],
									[
										35194,
										35198
									],
									[
										35224,
										35228
									],
									[
										35261,
										35265
									],
									[
										35413,
										35417
									],
									[
										35448,
										35452
									],
									[
										35561,
										35565
									],
									[
										35604,
										35608
									],
									[
										35645,
										35649
									],
									[
										35679,
										35683
									],
									[
										35718,
										35722
									],
									[
										35753,
										35757
									],
									[
										35871,
										35875
									],
									[
										35906,
										35910
									],
									[
										35956,
										35960
									],
									[
										35989,
										35993
									],
									[
										36022,
										36026
									],
									[
										36044,
										36048
									],
									[
										36161,
										36165
									],
									[
										36288,
										36292
									],
									[
										36318,
										36322
									],
									[
										36353,
										36357
									],
									[
										36395,
										36399
									],
									[
										36434,
										36438
									],
									[
										36482,
										36486
									],
									[
										36528,
										36532
									],
									[
										36664,
										36668
									],
									[
										36861,
										36865
									],
									[
										36894,
										36898
									],
									[
										36935,
										36939
									],
									[
										37179,
										37183
									],
									[
										37246,
										37250
									],
									[
										37288,
										37292
									],
									[
										37321,
										37325
									],
									[
										37355,
										37359
									],
									[
										37392,
										37396
									],
									[
										37465,
										37469
									],
									[
										37617,
										37621
									],
									[
										37817,
										37821
									],
									[
										37847,
										37851
									],
									[
										37889,
										37893
									],
									[
										37933,
										37937
									],
									[
										37973,
										37977
									],
									[
										38003,
										38007
									],
									[
										38052,
										38056
									],
									[
										38080,
										38084
									],
									[
										38115,
										38119
									],
									[
										38331,
										38335
									],
									[
										38358,
										38362
									],
									[
										38389,
										38393
									],
									[
										38422,
										38426
									],
									[
										38536,
										38540
									],
									[
										38575,
										38579
									],
									[
										38613,
										38617
									],
									[
										38651,
										38655
									],
									[
										38688,
										38692
									],
									[
										38718,
										38722
									],
									[
										38938,
										38942
									],
									[
										38968,
										38972
									],
									[
										39010,
										39014
									],
									[
										39054,
										39058
									],
									[
										39094,
										39098
									],
									[
										39152,
										39156
									],
									[
										39187,
										39191
									],
									[
										39403,
										39407
									],
									[
										39430,
										39434
									],
									[
										39461,
										39465
									],
									[
										39494,
										39498
									],
									[
										39689,
										39693
									],
									[
										39738,
										39742
									],
									[
										39936,
										39940
									],
									[
										40031,
										40035
									],
									[
										40193,
										40197
									],
									[
										40229,
										40233
									],
									[
										40276,
										40280
									],
									[
										40309,
										40313
									],
									[
										40343,
										40347
									],
									[
										40380,
										40384
									],
									[
										40420,
										40424
									],
									[
										40538,
										40542
									],
									[
										40652,
										40656
									],
									[
										40688,
										40692
									],
									[
										40716,
										40720
									],
									[
										40743,
										40747
									],
									[
										40873,
										40877
									],
									[
										40910,
										40914
									],
									[
										40964,
										40968
									],
									[
										41009,
										41013
									],
									[
										41044,
										41048
									],
									[
										41068,
										41072
									],
									[
										41174,
										41178
									],
									[
										41318,
										41322
									],
									[
										41558,
										41562
									],
									[
										41840,
										41844
									],
									[
										41887,
										41891
									],
									[
										41931,
										41935
									],
									[
										41951,
										41955
									],
									[
										41987,
										41991
									],
									[
										42307,
										42311
									],
									[
										42664,
										42668
									],
									[
										42849,
										42853
									],
									[
										42957,
										42961
									],
									[
										43279,
										43283
									],
									[
										43540,
										43544
									],
									[
										43573,
										43577
									],
									[
										43671,
										43675
									],
									[
										43729,
										43733
									],
									[
										43844,
										43848
									],
									[
										43860,
										43864
									],
									[
										44037,
										44041
									],
									[
										44062,
										44066
									],
									[
										44228,
										44232
									],
									[
										44350,
										44354
									],
									[
										44389,
										44393
									],
									[
										44453,
										44457
									],
									[
										44519,
										44523
									],
									[
										44543,
										44547
									],
									[
										44591,
										44595
									],
									[
										44778,
										44782
									],
									[
										44947,
										44951
									],
									[
										45138,
										45142
									],
									[
										45302,
										45306
									],
									[
										45357,
										45361
									],
									[
										45582,
										45586
									],
									[
										45593,
										45597
									],
									[
										45606,
										45610
									],
									[
										45820,
										45824
									],
									[
										45993,
										45997
									],
									[
										46135,
										46139
									],
									[
										46285,
										46289
									],
									[
										46518,
										46522
									],
									[
										46706,
										46710
									],
									[
										46882,
										46886
									],
									[
										47028,
										47032
									],
									[
										47169,
										47173
									],
									[
										47268,
										47272
									],
									[
										47278,
										47282
									],
									[
										47288,
										47292
									],
									[
										47399,
										47403
									],
									[
										47408,
										47412
									],
									[
										47417,
										47421
									],
									[
										47570,
										47574
									],
									[
										47580,
										47584
									],
									[
										47590,
										47594
									],
									[
										47620,
										47624
									],
									[
										47629,
										47633
									],
									[
										47638,
										47642
									],
									[
										47826,
										47830
									],
									[
										47837,
										47841
									],
									[
										48028,
										48032
									],
									[
										48071,
										48075
									],
									[
										48080,
										48084
									],
									[
										48089,
										48093
									],
									[
										48200,
										48204
									],
									[
										48209,
										48213
									],
									[
										48218,
										48222
									],
									[
										48276,
										48280
									],
									[
										48495,
										48499
									],
									[
										48521,
										48525
									],
									[
										48581,
										48585
									],
									[
										48644,
										48648
									],
									[
										48850,
										48854
									],
									[
										48924,
										48928
									],
									[
										48934,
										48938
									],
									[
										48944,
										48948
									],
									[
										49056,
										49060
									],
									[
										49066,
										49070
									],
									[
										49076,
										49080
									],
									[
										49273,
										49277
									],
									[
										49304,
										49308
									],
									[
										49344,
										49348
									],
									[
										49375,
										49379
									],
									[
										49546,
										49550
									],
									[
										49714,
										49718
									],
									[
										50025,
										50029
									],
									[
										50215,
										50219
									],
									[
										50304,
										50308
									],
									[
										50368,
										50372
									],
									[
										50544,
										50548
									],
									[
										50711,
										50715
									],
									[
										50819,
										50823
									],
									[
										50896,
										50900
									],
									[
										50921,
										50925
									],
									[
										50947,
										50951
									],
									[
										50968,
										50972
									],
									[
										51132,
										51136
									],
									[
										51311,
										51315
									],
									[
										51382,
										51386
									],
									[
										51568,
										51572
									],
									[
										51770,
										51774
									],
									[
										51967,
										51971
									],
									[
										52140,
										52144
									],
									[
										52318,
										52322
									],
									[
										52499,
										52503
									],
									[
										52588,
										52592
									],
									[
										52790,
										52794
									],
									[
										52951,
										52955
									],
									[
										53091,
										53095
									],
									[
										53252,
										53256
									],
									[
										53439,
										53443
									],
									[
										53673,
										53677
									],
									[
										53870,
										53874
									],
									[
										54040,
										54044
									],
									[
										54225,
										54229
									],
									[
										54467,
										54471
									],
									[
										54551,
										54555
									],
									[
										54739,
										54743
									],
									[
										54923,
										54927
									],
									[
										55239,
										55243
									],
									[
										55355,
										55359
									],
									[
										55497,
										55501
									],
									[
										55631,
										55635
									],
									[
										55823,
										55827
									],
									[
										55850,
										55854
									],
									[
										56175,
										56179
									],
									[
										56391,
										56395
									],
									[
										56595,
										56599
									],
									[
										56806,
										56810
									],
									[
										56990,
										56994
									],
									[
										57005,
										57009
									],
									[
										57232,
										57236
									],
									[
										57446,
										57450
									],
									[
										57563,
										57567
									],
									[
										57588,
										57592
									],
									[
										57789,
										57793
									],
									[
										58011,
										58015
									],
									[
										58264,
										58268
									],
									[
										58414,
										58418
									],
									[
										58441,
										58445
									],
									[
										58679,
										58683
									],
									[
										58831,
										58835
									],
									[
										59056,
										59060
									],
									[
										59153,
										59157
									],
									[
										59352,
										59356
									],
									[
										59426,
										59430
									],
									[
										59562,
										59566
									],
									[
										59799,
										59803
									],
									[
										59881,
										59885
									],
									[
										60005,
										60009
									],
									[
										60162,
										60166
									],
									[
										60344,
										60348
									],
									[
										60359,
										60363
									],
									[
										60592,
										60596
									],
									[
										60741,
										60745
									],
									[
										60943,
										60947
									],
									[
										60958,
										60962
									],
									[
										61211,
										61215
									],
									[
										61415,
										61419
									],
									[
										61430,
										61434
									],
									[
										61664,
										61668
									],
									[
										61814,
										61818
									],
									[
										62049,
										62053
									],
									[
										62076,
										62080
									],
									[
										62351,
										62355
									],
									[
										62557,
										62561
									],
									[
										62746,
										62750
									],
									[
										62859,
										62863
									],
									[
										62901,
										62905
									],
									[
										63108,
										63112
									],
									[
										63222,
										63226
									],
									[
										63409,
										63413
									],
									[
										63511,
										63515
									],
									[
										63735,
										63739
									],
									[
										63928,
										63932
									],
									[
										64126,
										64130
									],
									[
										64159,
										64163
									],
									[
										64328,
										64332
									],
									[
										64436,
										64440
									],
									[
										64626,
										64630
									],
									[
										64808,
										64812
									],
									[
										65103,
										65107
									],
									[
										65351,
										65355
									],
									[
										65388,
										65392
									],
									[
										65427,
										65431
									],
									[
										65495,
										65499
									],
									[
										65504,
										65508
									],
									[
										65526,
										65530
									],
									[
										65534,
										65538
									],
									[
										65631,
										65635
									],
									[
										65659,
										65663
									],
									[
										65748,
										65752
									],
									[
										65757,
										65761
									],
									[
										65779,
										65783
									],
									[
										65787,
										65791
									],
									[
										65831,
										65835
									],
									[
										65840,
										65844
									],
									[
										65927,
										65931
									],
									[
										65935,
										65939
									],
									[
										66122,
										66126
									],
									[
										66145,
										66149
									],
									[
										66169,
										66173
									],
									[
										66237,
										66241
									],
									[
										66267,
										66271
									],
									[
										66300,
										66304
									],
									[
										66350,
										66354
									],
									[
										66364,
										66368
									],
									[
										66456,
										66460
									],
									[
										66506,
										66510
									],
									[
										66520,
										66524
									],
									[
										66568,
										66572
									],
									[
										66639,
										66643
									],
									[
										66653,
										66657
									],
									[
										66824,
										66828
									],
									[
										66838,
										66842
									],
									[
										66969,
										66973
									],
									[
										66992,
										66996
									],
									[
										67016,
										67020
									],
									[
										67046,
										67050
									],
									[
										67108,
										67112
									],
									[
										67135,
										67139
									],
									[
										67159,
										67163
									],
									[
										67193,
										67197
									],
									[
										67214,
										67218
									],
									[
										67221,
										67225
									],
									[
										67269,
										67273
									],
									[
										67276,
										67280
									],
									[
										67308,
										67312
									],
									[
										67358,
										67362
									],
									[
										67365,
										67369
									],
									[
										67377,
										67381
									],
									[
										67385,
										67389
									],
									[
										67455,
										67459
									],
									[
										67475,
										67479
									],
									[
										67498,
										67502
									],
									[
										67540,
										67544
									],
									[
										67560,
										67564
									],
									[
										67583,
										67587
									],
									[
										67625,
										67629
									],
									[
										67650,
										67654
									],
									[
										67664,
										67668
									],
									[
										67681,
										67685
									],
									[
										67701,
										67705
									],
									[
										67731,
										67735
									],
									[
										67756,
										67760
									],
									[
										67770,
										67774
									],
									[
										67787,
										67791
									],
									[
										67807,
										67811
									],
									[
										67963,
										67967
									],
									[
										68000,
										68004
									],
									[
										68023,
										68027
									],
									[
										68192,
										68196
									],
									[
										68229,
										68233
									],
									[
										68256,
										68260
									],
									[
										68391,
										68395
									],
									[
										68416,
										68420
									],
									[
										68423,
										68427
									],
									[
										68530,
										68534
									],
									[
										68544,
										68548
									],
									[
										68556,
										68560
									],
									[
										68570,
										68574
									],
									[
										68780,
										68784
									],
									[
										68791,
										68795
									],
									[
										68873,
										68877
									],
									[
										68884,
										68888
									],
									[
										68966,
										68970
									],
									[
										68977,
										68981
									],
									[
										69140,
										69144
									],
									[
										69235,
										69239
									],
									[
										69242,
										69246
									],
									[
										69286,
										69290
									],
									[
										69293,
										69297
									],
									[
										69329,
										69333
									],
									[
										69343,
										69347
									],
									[
										69393,
										69397
									],
									[
										69461,
										69465
									],
									[
										69551,
										69555
									],
									[
										69629,
										69633
									],
									[
										69651,
										69655
									],
									[
										69683,
										69687
									],
									[
										69695,
										69699
									],
									[
										69726,
										69730
									],
									[
										69777,
										69781
									],
									[
										69809,
										69813
									],
									[
										69966,
										69970
									],
									[
										69991,
										69995
									],
									[
										70005,
										70009
									],
									[
										70054,
										70058
									],
									[
										70095,
										70099
									],
									[
										70152,
										70156
									],
									[
										70190,
										70194
									],
									[
										70347,
										70351
									],
									[
										70372,
										70376
									],
									[
										70386,
										70390
									],
									[
										70439,
										70443
									],
									[
										70480,
										70484
									],
									[
										70537,
										70541
									],
									[
										70575,
										70579
									],
									[
										70727,
										70731
									],
									[
										70836,
										70840
									],
									[
										70843,
										70847
									],
									[
										70886,
										70890
									],
									[
										70893,
										70897
									],
									[
										70984,
										70988
									],
									[
										71171,
										71175
									],
									[
										71191,
										71195
									],
									[
										71244,
										71248
									],
									[
										71396,
										71400
									],
									[
										71465,
										71469
									],
									[
										71535,
										71539
									],
									[
										71691,
										71695
									],
									[
										71728,
										71732
									],
									[
										71758,
										71762
									],
									[
										71792,
										71796
									],
									[
										71833,
										71837
									],
									[
										71890,
										71894
									],
									[
										71928,
										71932
									],
									[
										72087,
										72091
									],
									[
										72124,
										72128
									],
									[
										72158,
										72162
									],
									[
										72192,
										72196
									],
									[
										72233,
										72237
									],
									[
										72290,
										72294
									],
									[
										72328,
										72332
									],
									[
										72511,
										72515
									],
									[
										72593,
										72597
									],
									[
										72637,
										72641
									],
									[
										72659,
										72663
									],
									[
										72837,
										72841
									],
									[
										72923,
										72927
									],
									[
										72945,
										72949
									],
									[
										72974,
										72978
									],
									[
										73171,
										73175
									],
									[
										73256,
										73260
									],
									[
										73283,
										73287
									],
									[
										73469,
										73473
									],
									[
										73567,
										73571
									],
									[
										73596,
										73600
									],
									[
										73781,
										73785
									],
									[
										73934,
										73938
									],
									[
										74097,
										74101
									],
									[
										74210,
										74214
									],
									[
										74329,
										74333
									],
									[
										74356,
										74360
									],
									[
										74392,
										74396
									],
									[
										74421,
										74425
									],
									[
										74450,
										74454
									],
									[
										74487,
										74491
									],
									[
										74569,
										74573
									],
									[
										74581,
										74585
									],
									[
										74661,
										74665
									],
									[
										74765,
										74769
									],
									[
										74907,
										74911
									],
									[
										74926,
										74930
									],
									[
										74949,
										74953
									],
									[
										75032,
										75036
									],
									[
										75227,
										75231
									],
									[
										75412,
										75416
									],
									[
										75600,
										75604
									],
									[
										75739,
										75743
									],
									[
										75836,
										75840
									],
									[
										75890,
										75894
									],
									[
										75944,
										75948
									],
									[
										76025,
										76029
									],
									[
										76187,
										76191
									],
									[
										76309,
										76313
									],
									[
										76445,
										76449
									],
									[
										76533,
										76537
									],
									[
										76596,
										76600
									],
									[
										76659,
										76663
									],
									[
										76836,
										76840
									],
									[
										77044,
										77048
									],
									[
										77130,
										77134
									],
									[
										77333,
										77337
									],
									[
										77548,
										77552
									],
									[
										77748,
										77752
									],
									[
										78444,
										78448
									],
									[
										78518,
										78522
									],
									[
										78622,
										78626
									],
									[
										79766,
										79770
									],
									[
										79852,
										79856
									],
									[
										79988,
										79992
									],
									[
										80857,
										80861
									],
									[
										80943,
										80947
									],
									[
										81016,
										81020
									],
									[
										81247,
										81251
									],
									[
										81341,
										81345
									],
									[
										81589,
										81593
									],
									[
										81861,
										81865
									],
									[
										82003,
										82007
									],
									[
										82144,
										82148
									],
									[
										82279,
										82283
									],
									[
										82370,
										82374
									],
									[
										82540,
										82544
									],
									[
										82674,
										82678
									],
									[
										82891,
										82895
									],
									[
										82984,
										82988
									],
									[
										83205,
										83209
									],
									[
										83536,
										83540
									],
									[
										83851,
										83855
									],
									[
										83950,
										83954
									],
									[
										84051,
										84055
									],
									[
										84527,
										84531
									],
									[
										84624,
										84628
									],
									[
										84726,
										84730
									],
									[
										84872,
										84876
									],
									[
										85113,
										85117
									],
									[
										85224,
										85228
									],
									[
										85334,
										85338
									],
									[
										85445,
										85449
									],
									[
										85680,
										85684
									],
									[
										85693,
										85697
									],
									[
										85718,
										85722
									],
									[
										85732,
										85736
									],
									[
										85857,
										85861
									],
									[
										85992,
										85996
									],
									[
										86142,
										86146
									],
									[
										86175,
										86179
									],
									[
										86373,
										86377
									],
									[
										86398,
										86402
									],
									[
										86418,
										86422
									],
									[
										86472,
										86476
									],
									[
										86601,
										86605
									],
									[
										86797,
										86801
									],
									[
										87003,
										87007
									],
									[
										87151,
										87155
									],
									[
										87252,
										87256
									],
									[
										87340,
										87344
									],
									[
										87529,
										87533
									],
									[
										87712,
										87716
									],
									[
										87897,
										87901
									],
									[
										88097,
										88101
									],
									[
										88450,
										88454
									],
									[
										88728,
										88732
									],
									[
										88940,
										88944
									],
									[
										89222,
										89226
									],
									[
										89435,
										89439
									],
									[
										89598,
										89602
									],
									[
										89798,
										89802
									],
									[
										89916,
										89920
									],
									[
										90055,
										90059
									],
									[
										90073,
										90077
									],
									[
										90205,
										90209
									],
									[
										90222,
										90226
									],
									[
										90372,
										90376
									],
									[
										90421,
										90425
									],
									[
										90474,
										90478
									],
									[
										90527,
										90531
									],
									[
										90588,
										90592
									],
									[
										90641,
										90645
									],
									[
										90698,
										90702
									],
									[
										90755,
										90759
									],
									[
										90914,
										90918
									],
									[
										91078,
										91082
									],
									[
										91133,
										91137
									],
									[
										91359,
										91363
									],
									[
										91418,
										91422
									],
									[
										91661,
										91665
									],
									[
										91736,
										91740
									],
									[
										91806,
										91810
									],
									[
										91885,
										91889
									],
									[
										92089,
										92093
									],
									[
										92262,
										92266
									],
									[
										92382,
										92386
									],
									[
										92555,
										92559
									],
									[
										92568,
										92572
									],
									[
										92611,
										92615
									],
									[
										92659,
										92663
									],
									[
										92696,
										92700
									],
									[
										92841,
										92845
									],
									[
										93030,
										93034
									],
									[
										93229,
										93233
									],
									[
										93341,
										93345
									],
									[
										93420,
										93424
									],
									[
										93554,
										93558
									],
									[
										93636,
										93640
									],
									[
										93742,
										93746
									],
									[
										93872,
										93876
									],
									[
										93950,
										93954
									],
									[
										94105,
										94109
									],
									[
										94312,
										94316
									],
									[
										94679,
										94683
									],
									[
										94699,
										94703
									],
									[
										94926,
										94930
									],
									[
										95026,
										95030
									],
									[
										95195,
										95199
									],
									[
										95350,
										95354
									],
									[
										95553,
										95557
									],
									[
										95626,
										95630
									],
									[
										95744,
										95748
									],
									[
										95907,
										95911
									],
									[
										95923,
										95927
									],
									[
										96077,
										96081
									],
									[
										96292,
										96296
									],
									[
										96538,
										96542
									],
									[
										96643,
										96647
									],
									[
										96788,
										96792
									],
									[
										96809,
										96813
									],
									[
										96989,
										96993
									],
									[
										97010,
										97014
									],
									[
										97253,
										97257
									],
									[
										97383,
										97387
									],
									[
										97483,
										97487
									],
									[
										97686,
										97690
									],
									[
										97913,
										97917
									],
									[
										98036,
										98040
									],
									[
										98056,
										98060
									],
									[
										98110,
										98114
									],
									[
										98239,
										98243
									],
									[
										98389,
										98393
									],
									[
										98477,
										98481
									],
									[
										98538,
										98542
									],
									[
										98633,
										98637
									],
									[
										98796,
										98800
									],
									[
										99051,
										99055
									],
									[
										99144,
										99148
									],
									[
										99307,
										99311
									],
									[
										99492,
										99496
									],
									[
										99734,
										99738
									],
									[
										99887,
										99891
									],
									[
										100071,
										100075
									],
									[
										100137,
										100141
									],
									[
										100216,
										100220
									],
									[
										100296,
										100300
									],
									[
										100547,
										100551
									],
									[
										100808,
										100812
									],
									[
										100994,
										100998
									],
									[
										101166,
										101170
									],
									[
										101173,
										101177
									],
									[
										101209,
										101213
									],
									[
										101216,
										101220
									],
									[
										101256,
										101260
									],
									[
										101263,
										101267
									],
									[
										101299,
										101303
									],
									[
										101306,
										101310
									],
									[
										101344,
										101348
									],
									[
										101351,
										101355
									],
									[
										101387,
										101391
									],
									[
										101394,
										101398
									],
									[
										101436,
										101440
									],
									[
										101443,
										101447
									],
									[
										101481,
										101485
									],
									[
										101488,
										101492
									],
									[
										101528,
										101532
									],
									[
										101535,
										101539
									],
									[
										101737,
										101741
									],
									[
										101859,
										101863
									],
									[
										102015,
										102019
									],
									[
										102154,
										102158
									],
									[
										102187,
										102191
									],
									[
										102228,
										102232
									],
									[
										102474,
										102478
									],
									[
										102541,
										102545
									],
									[
										102583,
										102587
									],
									[
										102616,
										102620
									],
									[
										102650,
										102654
									],
									[
										102687,
										102691
									],
									[
										102760,
										102764
									],
									[
										102912,
										102916
									],
									[
										103098,
										103102
									],
									[
										103128,
										103132
									],
									[
										103170,
										103174
									],
									[
										103214,
										103218
									],
									[
										103254,
										103258
									],
									[
										103284,
										103288
									],
									[
										103412,
										103416
									],
									[
										103476,
										103480
									],
									[
										103503,
										103507
									],
									[
										103535,
										103539
									],
									[
										103671,
										103675
									],
									[
										103746,
										103750
									],
									[
										103993,
										103997
									],
									[
										104043,
										104047
									],
									[
										104148,
										104152
									],
									[
										104371,
										104375
									],
									[
										104437,
										104441
									],
									[
										104506,
										104510
									],
									[
										104582,
										104586
									],
									[
										104790,
										104794
									],
									[
										104912,
										104916
									],
									[
										104988,
										104992
									],
									[
										105198,
										105202
									],
									[
										105278,
										105282
									],
									[
										105316,
										105320
									],
									[
										105343,
										105347
									],
									[
										105552,
										105556
									],
									[
										105621,
										105625
									],
									[
										105762,
										105766
									],
									[
										105901,
										105905
									],
									[
										106198,
										106202
									],
									[
										106260,
										106264
									],
									[
										106352,
										106356
									],
									[
										106438,
										106442
									],
									[
										106686,
										106690
									],
									[
										106751,
										106755
									],
									[
										106982,
										106986
									],
									[
										107055,
										107059
									],
									[
										107069,
										107073
									],
									[
										107262,
										107266
									],
									[
										107380,
										107384
									],
									[
										107480,
										107484
									],
									[
										107660,
										107664
									],
									[
										107930,
										107934
									],
									[
										108097,
										108101
									],
									[
										108288,
										108292
									],
									[
										108374,
										108378
									],
									[
										108405,
										108409
									],
									[
										108434,
										108438
									],
									[
										108542,
										108546
									],
									[
										108565,
										108569
									],
									[
										108584,
										108588
									],
									[
										108704,
										108708
									],
									[
										108837,
										108841
									],
									[
										109023,
										109027
									],
									[
										109221,
										109225
									],
									[
										109286,
										109290
									],
									[
										109359,
										109363
									],
									[
										109437,
										109441
									],
									[
										109515,
										109519
									],
									[
										109858,
										109862
									],
									[
										110152,
										110156
									],
									[
										110407,
										110411
									],
									[
										110475,
										110479
									],
									[
										110524,
										110528
									],
									[
										110574,
										110578
									],
									[
										110644,
										110648
									],
									[
										110700,
										110704
									],
									[
										110758,
										110762
									],
									[
										110818,
										110822
									],
									[
										110885,
										110889
									],
									[
										110939,
										110943
									],
									[
										111062,
										111066
									],
									[
										111130,
										111134
									],
									[
										111413,
										111417
									],
									[
										111473,
										111477
									],
									[
										111714,
										111718
									],
									[
										111777,
										111781
									],
									[
										111822,
										111826
									],
									[
										112022,
										112026
									],
									[
										112229,
										112233
									],
									[
										112269,
										112273
									],
									[
										112400,
										112404
									],
									[
										112440,
										112444
									],
									[
										112504,
										112508
									],
									[
										112611,
										112615
									],
									[
										112656,
										112660
									],
									[
										112708,
										112712
									],
									[
										112764,
										112768
									],
									[
										112821,
										112825
									],
									[
										112874,
										112878
									],
									[
										112929,
										112933
									],
									[
										112975,
										112979
									],
									[
										113078,
										113082
									],
									[
										113123,
										113127
									],
									[
										113314,
										113318
									],
									[
										113381,
										113385
									],
									[
										113426,
										113430
									],
									[
										113709,
										113713
									],
									[
										113720,
										113724
									],
									[
										113920,
										113924
									],
									[
										113978,
										113982
									],
									[
										114045,
										114049
									],
									[
										114269,
										114273
									],
									[
										114327,
										114331
									],
									[
										114394,
										114398
									],
									[
										114535,
										114539
									],
									[
										114595,
										114599
									],
									[
										114742,
										114746
									],
									[
										114802,
										114806
									],
									[
										115045,
										115049
									],
									[
										115141,
										115145
									],
									[
										115208,
										115212
									],
									[
										115440,
										115444
									],
									[
										115536,
										115540
									],
									[
										115603,
										115607
									],
									[
										115757,
										115761
									],
									[
										115925,
										115929
									],
									[
										115988,
										115992
									],
									[
										116140,
										116144
									],
									[
										116308,
										116312
									],
									[
										116371,
										116375
									],
									[
										116510,
										116514
									],
									[
										116658,
										116662
									],
									[
										116718,
										116722
									],
									[
										116784,
										116788
									],
									[
										116888,
										116892
									],
									[
										116948,
										116952
									],
									[
										117014,
										117018
									],
									[
										117184,
										117188
									],
									[
										117234,
										117238
									],
									[
										117427,
										117431
									],
									[
										117501,
										117505
									],
									[
										117639,
										117643
									],
									[
										117706,
										117710
									],
									[
										117896,
										117900
									],
									[
										117956,
										117960
									],
									[
										118019,
										118023
									],
									[
										118232,
										118236
									],
									[
										118358,
										118362
									],
									[
										118406,
										118410
									],
									[
										118525,
										118529
									],
									[
										118587,
										118591
									],
									[
										118633,
										118637
									],
									[
										118678,
										118682
									],
									[
										118732,
										118736
									],
									[
										118826,
										118830
									],
									[
										118888,
										118892
									],
									[
										118934,
										118938
									],
									[
										118979,
										118983
									],
									[
										119033,
										119037
									],
									[
										119194,
										119198
									],
									[
										119402,
										119406
									],
									[
										119606,
										119610
									],
									[
										119870,
										119874
									],
									[
										120154,
										120158
									],
									[
										120225,
										120229
									],
									[
										120458,
										120462
									],
									[
										120554,
										120558
									],
									[
										120625,
										120629
									],
									[
										120639,
										120643
									],
									[
										120885,
										120889
									],
									[
										121141,
										121145
									],
									[
										121330,
										121334
									],
									[
										121405,
										121409
									],
									[
										121566,
										121570
									],
									[
										121779,
										121783
									],
									[
										122137,
										122141
									],
									[
										122203,
										122207
									],
									[
										122262,
										122266
									],
									[
										122319,
										122323
									],
									[
										122468,
										122472
									],
									[
										122579,
										122583
									],
									[
										122768,
										122772
									],
									[
										122871,
										122875
									],
									[
										122980,
										122984
									],
									[
										123187,
										123191
									],
									[
										123294,
										123298
									],
									[
										123453,
										123457
									],
									[
										123568,
										123572
									],
									[
										123720,
										123724
									],
									[
										123872,
										123876
									],
									[
										124000,
										124004
									],
									[
										124178,
										124182
									],
									[
										124413,
										124417
									],
									[
										124657,
										124661
									],
									[
										124818,
										124822
									],
									[
										124829,
										124833
									],
									[
										125012,
										125016
									],
									[
										125108,
										125112
									],
									[
										125221,
										125225
									],
									[
										125363,
										125367
									],
									[
										125399,
										125403
									],
									[
										125585,
										125589
									],
									[
										125661,
										125665
									],
									[
										125672,
										125676
									],
									[
										125784,
										125788
									],
									[
										125991,
										125995
									],
									[
										126047,
										126051
									],
									[
										126231,
										126235
									],
									[
										126396,
										126400
									],
									[
										126551,
										126555
									],
									[
										126713,
										126717
									],
									[
										126784,
										126788
									],
									[
										126855,
										126859
									],
									[
										127046,
										127050
									],
									[
										127155,
										127159
									],
									[
										127178,
										127182
									],
									[
										127310,
										127314
									],
									[
										127334,
										127338
									],
									[
										127356,
										127360
									],
									[
										127460,
										127464
									],
									[
										127567,
										127571
									],
									[
										127654,
										127658
									],
									[
										127680,
										127684
									],
									[
										127703,
										127707
									],
									[
										127731,
										127735
									],
									[
										127835,
										127839
									],
									[
										128019,
										128023
									],
									[
										128073,
										128077
									],
									[
										128138,
										128142
									],
									[
										128213,
										128217
									],
									[
										128260,
										128264
									],
									[
										128392,
										128396
									],
									[
										128413,
										128417
									],
									[
										128521,
										128525
									],
									[
										128542,
										128546
									],
									[
										128594,
										128598
									],
									[
										128618,
										128622
									],
									[
										128642,
										128646
									],
									[
										128667,
										128671
									],
									[
										128750,
										128754
									],
									[
										128774,
										128778
									],
									[
										128917,
										128921
									],
									[
										128986,
										128990
									],
									[
										129396,
										129400
									],
									[
										129481,
										129485
									],
									[
										129646,
										129650
									],
									[
										129668,
										129672
									],
									[
										129690,
										129694
									],
									[
										129714,
										129718
									],
									[
										129737,
										129741
									],
									[
										129761,
										129765
									],
									[
										129785,
										129789
									],
									[
										129808,
										129812
									],
									[
										129835,
										129839
									],
									[
										130067,
										130071
									],
									[
										130148,
										130152
									],
									[
										130232,
										130236
									],
									[
										130313,
										130317
									],
									[
										130389,
										130393
									],
									[
										130477,
										130481
									],
									[
										130555,
										130559
									],
									[
										130633,
										130637
									],
									[
										130746,
										130750
									],
									[
										130873,
										130877
									],
									[
										130894,
										130898
									],
									[
										130919,
										130923
									],
									[
										130943,
										130947
									],
									[
										130966,
										130970
									],
									[
										130990,
										130994
									],
									[
										131118,
										131122
									],
									[
										131145,
										131149
									],
									[
										131178,
										131182
									],
									[
										131291,
										131295
									],
									[
										131312,
										131316
									],
									[
										131450,
										131454
									],
									[
										131471,
										131475
									],
									[
										131612,
										131616
									],
									[
										131633,
										131637
									],
									[
										131658,
										131662
									],
									[
										131685,
										131689
									],
									[
										131712,
										131716
									],
									[
										131740,
										131744
									],
									[
										131768,
										131772
									],
									[
										131795,
										131799
									],
									[
										131822,
										131826
									],
									[
										131846,
										131850
									],
									[
										131868,
										131872
									],
									[
										131895,
										131899
									],
									[
										131920,
										131924
									],
									[
										131950,
										131954
									],
									[
										131979,
										131983
									],
									[
										132011,
										132015
									],
									[
										132042,
										132046
									],
									[
										132069,
										132073
									],
									[
										132094,
										132098
									],
									[
										132121,
										132125
									],
									[
										132241,
										132245
									],
									[
										132271,
										132275
									],
									[
										132392,
										132396
									],
									[
										132421,
										132425
									],
									[
										132449,
										132453
									],
									[
										132477,
										132481
									],
									[
										132502,
										132506
									],
									[
										132527,
										132531
									],
									[
										132554,
										132558
									],
									[
										132581,
										132585
									],
									[
										132606,
										132610
									],
									[
										132631,
										132635
									],
									[
										132660,
										132664
									],
									[
										132689,
										132693
									],
									[
										132728,
										132732
									],
									[
										132857,
										132861
									],
									[
										132878,
										132882
									],
									[
										132903,
										132907
									],
									[
										132927,
										132931
									],
									[
										133034,
										133038
									],
									[
										133221,
										133225
									],
									[
										133318,
										133322
									],
									[
										133491,
										133495
									],
									[
										133601,
										133605
									],
									[
										133634,
										133638
									],
									[
										133728,
										133732
									],
									[
										133778,
										133782
									],
									[
										133928,
										133932
									],
									[
										133978,
										133982
									],
									[
										134028,
										134032
									],
									[
										134078,
										134082
									],
									[
										134128,
										134132
									],
									[
										134166,
										134170
									],
									[
										134200,
										134204
									],
									[
										134323,
										134327
									],
									[
										134356,
										134360
									],
									[
										134498,
										134502
									],
									[
										134536,
										134540
									],
									[
										134588,
										134592
									],
									[
										134663,
										134667
									],
									[
										134719,
										134723
									],
									[
										134765,
										134769
									],
									[
										134880,
										134884
									],
									[
										134912,
										134916
									],
									[
										134934,
										134938
									],
									[
										134961,
										134965
									],
									[
										135071,
										135075
									],
									[
										135093,
										135097
									],
									[
										135188,
										135192
									],
									[
										135224,
										135228
									],
									[
										135258,
										135262
									],
									[
										135308,
										135312
									],
									[
										135356,
										135360
									],
									[
										135404,
										135408
									],
									[
										135439,
										135443
									],
									[
										135480,
										135484
									],
									[
										135522,
										135526
									],
									[
										135558,
										135562
									],
									[
										135653,
										135657
									],
									[
										135680,
										135684
									],
									[
										135713,
										135717
									],
									[
										135747,
										135751
									],
									[
										135869,
										135873
									],
									[
										135891,
										135895
									],
									[
										135986,
										135990
									],
									[
										136022,
										136026
									],
									[
										136056,
										136060
									],
									[
										136289,
										136293
									],
									[
										136431,
										136435
									],
									[
										136464,
										136468
									],
									[
										136609,
										136613
									],
									[
										136642,
										136646
									],
									[
										136737,
										136741
									],
									[
										136759,
										136763
									],
									[
										136789,
										136793
									],
									[
										136826,
										136830
									],
									[
										136978,
										136982
									],
									[
										137013,
										137017
									],
									[
										137126,
										137130
									],
									[
										137169,
										137173
									],
									[
										137210,
										137214
									],
									[
										137244,
										137248
									],
									[
										137283,
										137287
									],
									[
										137318,
										137322
									],
									[
										137436,
										137440
									],
									[
										137471,
										137475
									],
									[
										137521,
										137525
									],
									[
										137554,
										137558
									],
									[
										137587,
										137591
									],
									[
										137609,
										137613
									],
									[
										137726,
										137730
									],
									[
										137853,
										137857
									],
									[
										137883,
										137887
									],
									[
										137918,
										137922
									],
									[
										137960,
										137964
									],
									[
										137999,
										138003
									],
									[
										138047,
										138051
									],
									[
										138093,
										138097
									],
									[
										138229,
										138233
									],
									[
										138426,
										138430
									],
									[
										138459,
										138463
									],
									[
										138500,
										138504
									],
									[
										138744,
										138748
									],
									[
										138811,
										138815
									],
									[
										138853,
										138857
									],
									[
										138886,
										138890
									],
									[
										138920,
										138924
									],
									[
										138957,
										138961
									],
									[
										139030,
										139034
									],
									[
										139182,
										139186
									],
									[
										139382,
										139386
									],
									[
										139412,
										139416
									],
									[
										139454,
										139458
									],
									[
										139498,
										139502
									],
									[
										139538,
										139542
									],
									[
										139568,
										139572
									],
									[
										139617,
										139621
									],
									[
										139645,
										139649
									],
									[
										139680,
										139684
									],
									[
										139896,
										139900
									],
									[
										139923,
										139927
									],
									[
										139954,
										139958
									],
									[
										139987,
										139991
									],
									[
										140101,
										140105
									],
									[
										140140,
										140144
									],
									[
										140178,
										140182
									],
									[
										140216,
										140220
									],
									[
										140253,
										140257
									],
									[
										140283,
										140287
									],
									[
										140503,
										140507
									],
									[
										140533,
										140537
									],
									[
										140575,
										140579
									],
									[
										140619,
										140623
									],
									[
										140659,
										140663
									],
									[
										140717,
										140721
									],
									[
										140752,
										140756
									],
									[
										140968,
										140972
									],
									[
										140995,
										140999
									],
									[
										141026,
										141030
									],
									[
										141059,
										141063
									],
									[
										141254,
										141258
									],
									[
										141303,
										141307
									],
									[
										141501,
										141505
									],
									[
										141596,
										141600
									],
									[
										141758,
										141762
									],
									[
										141794,
										141798
									],
									[
										141841,
										141845
									],
									[
										141874,
										141878
									],
									[
										141908,
										141912
									],
									[
										141945,
										141949
									],
									[
										141985,
										141989
									],
									[
										142103,
										142107
									],
									[
										142217,
										142221
									],
									[
										142253,
										142257
									],
									[
										142281,
										142285
									],
									[
										142308,
										142312
									],
									[
										142438,
										142442
									],
									[
										142475,
										142479
									],
									[
										142529,
										142533
									],
									[
										142574,
										142578
									],
									[
										142609,
										142613
									],
									[
										142633,
										142637
									],
									[
										142739,
										142743
									],
									[
										142883,
										142887
									],
									[
										143123,
										143127
									],
									[
										143405,
										143409
									],
									[
										143452,
										143456
									],
									[
										143496,
										143500
									],
									[
										143516,
										143520
									],
									[
										143552,
										143556
									],
									[
										143872,
										143876
									],
									[
										144229,
										144233
									],
									[
										144414,
										144418
									],
									[
										144522,
										144526
									],
									[
										144844,
										144848
									],
									[
										145105,
										145109
									],
									[
										145138,
										145142
									],
									[
										145236,
										145240
									],
									[
										145294,
										145298
									],
									[
										145409,
										145413
									],
									[
										145425,
										145429
									],
									[
										145602,
										145606
									],
									[
										145627,
										145631
									],
									[
										145793,
										145797
									],
									[
										145915,
										145919
									],
									[
										145954,
										145958
									],
									[
										146018,
										146022
									],
									[
										146084,
										146088
									],
									[
										146108,
										146112
									],
									[
										146156,
										146160
									],
									[
										146343,
										146347
									],
									[
										146512,
										146516
									],
									[
										146703,
										146707
									],
									[
										146867,
										146871
									],
									[
										146922,
										146926
									],
									[
										147147,
										147151
									],
									[
										147158,
										147162
									],
									[
										147171,
										147175
									],
									[
										147385,
										147389
									],
									[
										147558,
										147562
									],
									[
										147700,
										147704
									],
									[
										147850,
										147854
									],
									[
										148083,
										148087
									],
									[
										148271,
										148275
									],
									[
										148447,
										148451
									],
									[
										148593,
										148597
									],
									[
										148734,
										148738
									],
									[
										148833,
										148837
									],
									[
										148843,
										148847
									],
									[
										148853,
										148857
									],
									[
										148964,
										148968
									],
									[
										148973,
										148977
									],
									[
										148982,
										148986
									],
									[
										149135,
										149139
									],
									[
										149145,
										149149
									],
									[
										149155,
										149159
									],
									[
										149185,
										149189
									],
									[
										149194,
										149198
									],
									[
										149203,
										149207
									],
									[
										149391,
										149395
									],
									[
										149402,
										149406
									],
									[
										149593,
										149597
									],
									[
										149636,
										149640
									],
									[
										149645,
										149649
									],
									[
										149654,
										149658
									],
									[
										149765,
										149769
									],
									[
										149774,
										149778
									],
									[
										149783,
										149787
									],
									[
										149841,
										149845
									],
									[
										150060,
										150064
									],
									[
										150086,
										150090
									],
									[
										150146,
										150150
									],
									[
										150209,
										150213
									],
									[
										150415,
										150419
									],
									[
										150489,
										150493
									],
									[
										150499,
										150503
									],
									[
										150509,
										150513
									],
									[
										150621,
										150625
									],
									[
										150631,
										150635
									],
									[
										150641,
										150645
									],
									[
										150838,
										150842
									],
									[
										150869,
										150873
									],
									[
										150909,
										150913
									],
									[
										150940,
										150944
									],
									[
										151111,
										151115
									],
									[
										151279,
										151283
									],
									[
										151590,
										151594
									],
									[
										151780,
										151784
									],
									[
										151869,
										151873
									],
									[
										151933,
										151937
									],
									[
										152109,
										152113
									],
									[
										152276,
										152280
									],
									[
										152384,
										152388
									],
									[
										152461,
										152465
									],
									[
										152486,
										152490
									],
									[
										152512,
										152516
									],
									[
										152533,
										152537
									],
									[
										152697,
										152701
									],
									[
										152876,
										152880
									],
									[
										152947,
										152951
									],
									[
										153133,
										153137
									],
									[
										153335,
										153339
									],
									[
										153532,
										153536
									],
									[
										153705,
										153709
									],
									[
										153883,
										153887
									],
									[
										154064,
										154068
									],
									[
										154153,
										154157
									],
									[
										154355,
										154359
									],
									[
										154516,
										154520
									],
									[
										154656,
										154660
									],
									[
										154817,
										154821
									],
									[
										155004,
										155008
									],
									[
										155238,
										155242
									],
									[
										155435,
										155439
									],
									[
										155605,
										155609
									],
									[
										155790,
										155794
									],
									[
										156032,
										156036
									],
									[
										156116,
										156120
									],
									[
										156304,
										156308
									],
									[
										156488,
										156492
									],
									[
										156804,
										156808
									],
									[
										156920,
										156924
									],
									[
										157062,
										157066
									],
									[
										157196,
										157200
									],
									[
										157388,
										157392
									],
									[
										157415,
										157419
									],
									[
										157740,
										157744
									],
									[
										157956,
										157960
									],
									[
										158160,
										158164
									],
									[
										158371,
										158375
									],
									[
										158555,
										158559
									],
									[
										158570,
										158574
									],
									[
										158797,
										158801
									],
									[
										159011,
										159015
									],
									[
										159128,
										159132
									],
									[
										159153,
										159157
									],
									[
										159354,
										159358
									],
									[
										159576,
										159580
									],
									[
										159829,
										159833
									],
									[
										159979,
										159983
									],
									[
										160006,
										160010
									],
									[
										160244,
										160248
									],
									[
										160396,
										160400
									],
									[
										160621,
										160625
									],
									[
										160718,
										160722
									],
									[
										160917,
										160921
									],
									[
										160991,
										160995
									],
									[
										161127,
										161131
									],
									[
										161364,
										161368
									],
									[
										161446,
										161450
									],
									[
										161570,
										161574
									],
									[
										161727,
										161731
									],
									[
										161909,
										161913
									],
									[
										161924,
										161928
									],
									[
										162157,
										162161
									],
									[
										162306,
										162310
									],
									[
										162508,
										162512
									],
									[
										162523,
										162527
									],
									[
										162776,
										162780
									],
									[
										162980,
										162984
									],
									[
										162995,
										162999
									],
									[
										163229,
										163233
									],
									[
										163379,
										163383
									],
									[
										163614,
										163618
									],
									[
										163641,
										163645
									],
									[
										163916,
										163920
									],
									[
										164122,
										164126
									],
									[
										164311,
										164315
									],
									[
										164424,
										164428
									],
									[
										164466,
										164470
									],
									[
										164673,
										164677
									],
									[
										164787,
										164791
									],
									[
										164974,
										164978
									],
									[
										165076,
										165080
									],
									[
										165300,
										165304
									],
									[
										165493,
										165497
									],
									[
										165691,
										165695
									],
									[
										165724,
										165728
									],
									[
										165893,
										165897
									],
									[
										166001,
										166005
									],
									[
										166191,
										166195
									],
									[
										166373,
										166377
									],
									[
										166668,
										166672
									],
									[
										166916,
										166920
									],
									[
										166953,
										166957
									],
									[
										166992,
										166996
									],
									[
										167060,
										167064
									],
									[
										167069,
										167073
									],
									[
										167091,
										167095
									],
									[
										167099,
										167103
									],
									[
										167196,
										167200
									],
									[
										167224,
										167228
									],
									[
										167313,
										167317
									],
									[
										167322,
										167326
									],
									[
										167344,
										167348
									],
									[
										167352,
										167356
									],
									[
										167396,
										167400
									],
									[
										167405,
										167409
									],
									[
										167492,
										167496
									],
									[
										167500,
										167504
									],
									[
										167687,
										167691
									],
									[
										167710,
										167714
									],
									[
										167734,
										167738
									],
									[
										167802,
										167806
									],
									[
										167832,
										167836
									],
									[
										167865,
										167869
									],
									[
										167915,
										167919
									],
									[
										167929,
										167933
									],
									[
										168021,
										168025
									],
									[
										168071,
										168075
									],
									[
										168085,
										168089
									],
									[
										168133,
										168137
									],
									[
										168204,
										168208
									],
									[
										168218,
										168222
									],
									[
										168389,
										168393
									],
									[
										168403,
										168407
									],
									[
										168534,
										168538
									],
									[
										168557,
										168561
									],
									[
										168581,
										168585
									],
									[
										168611,
										168615
									],
									[
										168673,
										168677
									],
									[
										168700,
										168704
									],
									[
										168724,
										168728
									],
									[
										168758,
										168762
									],
									[
										168779,
										168783
									],
									[
										168786,
										168790
									],
									[
										168834,
										168838
									],
									[
										168841,
										168845
									],
									[
										168873,
										168877
									],
									[
										168923,
										168927
									],
									[
										168930,
										168934
									],
									[
										168942,
										168946
									],
									[
										168950,
										168954
									],
									[
										169020,
										169024
									],
									[
										169040,
										169044
									],
									[
										169063,
										169067
									],
									[
										169105,
										169109
									],
									[
										169125,
										169129
									],
									[
										169148,
										169152
									],
									[
										169190,
										169194
									],
									[
										169215,
										169219
									],
									[
										169229,
										169233
									],
									[
										169246,
										169250
									],
									[
										169266,
										169270
									],
									[
										169296,
										169300
									],
									[
										169321,
										169325
									],
									[
										169335,
										169339
									],
									[
										169352,
										169356
									],
									[
										169372,
										169376
									],
									[
										169528,
										169532
									],
									[
										169565,
										169569
									],
									[
										169588,
										169592
									],
									[
										169757,
										169761
									],
									[
										169794,
										169798
									],
									[
										169821,
										169825
									],
									[
										169956,
										169960
									],
									[
										169981,
										169985
									],
									[
										169988,
										169992
									],
									[
										170095,
										170099
									],
									[
										170109,
										170113
									],
									[
										170121,
										170125
									],
									[
										170135,
										170139
									],
									[
										170345,
										170349
									],
									[
										170356,
										170360
									],
									[
										170438,
										170442
									],
									[
										170449,
										170453
									],
									[
										170531,
										170535
									],
									[
										170542,
										170546
									],
									[
										170705,
										170709
									],
									[
										170800,
										170804
									],
									[
										170807,
										170811
									],
									[
										170851,
										170855
									],
									[
										170858,
										170862
									],
									[
										170894,
										170898
									],
									[
										170908,
										170912
									],
									[
										170958,
										170962
									],
									[
										171026,
										171030
									],
									[
										171116,
										171120
									],
									[
										171194,
										171198
									],
									[
										171216,
										171220
									],
									[
										171248,
										171252
									],
									[
										171260,
										171264
									],
									[
										171291,
										171295
									],
									[
										171342,
										171346
									],
									[
										171374,
										171378
									],
									[
										171531,
										171535
									],
									[
										171556,
										171560
									],
									[
										171570,
										171574
									],
									[
										171619,
										171623
									],
									[
										171660,
										171664
									],
									[
										171717,
										171721
									],
									[
										171755,
										171759
									],
									[
										171912,
										171916
									],
									[
										171937,
										171941
									],
									[
										171951,
										171955
									],
									[
										172004,
										172008
									],
									[
										172045,
										172049
									],
									[
										172102,
										172106
									],
									[
										172140,
										172144
									],
									[
										172292,
										172296
									],
									[
										172401,
										172405
									],
									[
										172408,
										172412
									],
									[
										172451,
										172455
									],
									[
										172458,
										172462
									],
									[
										172549,
										172553
									],
									[
										172736,
										172740
									],
									[
										172756,
										172760
									],
									[
										172809,
										172813
									],
									[
										172961,
										172965
									],
									[
										173030,
										173034
									],
									[
										173100,
										173104
									],
									[
										173256,
										173260
									],
									[
										173293,
										173297
									],
									[
										173323,
										173327
									],
									[
										173357,
										173361
									],
									[
										173398,
										173402
									],
									[
										173455,
										173459
									],
									[
										173493,
										173497
									],
									[
										173652,
										173656
									],
									[
										173689,
										173693
									],
									[
										173723,
										173727
									],
									[
										173757,
										173761
									],
									[
										173798,
										173802
									],
									[
										173855,
										173859
									],
									[
										173893,
										173897
									],
									[
										174076,
										174080
									],
									[
										174158,
										174162
									],
									[
										174202,
										174206
									],
									[
										174224,
										174228
									],
									[
										174402,
										174406
									],
									[
										174488,
										174492
									],
									[
										174510,
										174514
									],
									[
										174539,
										174543
									],
									[
										174736,
										174740
									],
									[
										174821,
										174825
									],
									[
										174848,
										174852
									],
									[
										175034,
										175038
									],
									[
										175132,
										175136
									],
									[
										175161,
										175165
									],
									[
										175346,
										175350
									],
									[
										175501,
										175505
									],
									[
										175637,
										175641
									],
									[
										175729,
										175733
									],
									[
										175752,
										175756
									],
									[
										175920,
										175924
									],
									[
										175940,
										175944
									],
									[
										175947,
										175951
									],
									[
										176166,
										176170
									],
									[
										176237,
										176241
									],
									[
										176322,
										176326
									],
									[
										176520,
										176524
									],
									[
										176662,
										176666
									],
									[
										176827,
										176831
									],
									[
										176839,
										176843
									],
									[
										177004,
										177008
									],
									[
										177167,
										177171
									],
									[
										177285,
										177289
									],
									[
										177305,
										177309
									],
									[
										177359,
										177363
									],
									[
										177488,
										177492
									],
									[
										177655,
										177659
									],
									[
										177782,
										177786
									],
									[
										177936,
										177940
									],
									[
										177975,
										177979
									],
									[
										178123,
										178127
									],
									[
										178348,
										178352
									],
									[
										178460,
										178464
									],
									[
										178687,
										178691
									],
									[
										178819,
										178823
									],
									[
										178850,
										178854
									],
									[
										179101,
										179105
									],
									[
										179305,
										179309
									],
									[
										179433,
										179437
									],
									[
										179456,
										179460
									],
									[
										179614,
										179618
									],
									[
										179808,
										179812
									],
									[
										180039,
										180043
									],
									[
										180255,
										180259
									],
									[
										180388,
										180392
									],
									[
										180534,
										180538
									],
									[
										180651,
										180655
									],
									[
										180928,
										180932
									],
									[
										181128,
										181132
									],
									[
										181262,
										181266
									],
									[
										181460,
										181464
									],
									[
										181543,
										181547
									],
									[
										181836,
										181840
									],
									[
										181919,
										181923
									],
									[
										182007,
										182011
									],
									[
										182259,
										182263
									],
									[
										182636,
										182640
									],
									[
										182753,
										182757
									],
									[
										183086,
										183090
									],
									[
										183367,
										183371
									],
									[
										183445,
										183449
									],
									[
										183730,
										183734
									],
									[
										183820,
										183824
									],
									[
										183943,
										183947
									],
									[
										184268,
										184272
									],
									[
										184581,
										184585
									],
									[
										184674,
										184678
									],
									[
										184949,
										184953
									],
									[
										185039,
										185043
									],
									[
										185162,
										185166
									],
									[
										185481,
										185485
									],
									[
										185846,
										185850
									],
									[
										186064,
										186068
									],
									[
										186243,
										186247
									],
									[
										186491,
										186495
									],
									[
										186559,
										186563
									],
									[
										186713,
										186717
									],
									[
										186779,
										186783
									],
									[
										186964,
										186968
									],
									[
										187141,
										187145
									],
									[
										187404,
										187408
									],
									[
										187702,
										187706
									],
									[
										187814,
										187818
									],
									[
										187937,
										187941
									],
									[
										188108,
										188112
									],
									[
										188353,
										188357
									],
									[
										188598,
										188602
									],
									[
										188901,
										188905
									],
									[
										189072,
										189076
									],
									[
										189226,
										189230
									],
									[
										189251,
										189255
									],
									[
										189310,
										189314
									],
									[
										189335,
										189339
									],
									[
										189424,
										189428
									],
									[
										189503,
										189507
									],
									[
										189574,
										189578
									],
									[
										189809,
										189813
									],
									[
										190046,
										190050
									],
									[
										190368,
										190372
									],
									[
										190609,
										190613
									],
									[
										190759,
										190763
									],
									[
										190905,
										190909
									],
									[
										191127,
										191131
									],
									[
										191305,
										191309
									],
									[
										191531,
										191535
									],
									[
										191574,
										191578
									],
									[
										191816,
										191820
									],
									[
										192022,
										192026
									],
									[
										192284,
										192288
									],
									[
										192331,
										192335
									],
									[
										192581,
										192585
									],
									[
										192724,
										192728
									],
									[
										192870,
										192874
									],
									[
										193010,
										193014
									],
									[
										193181,
										193185
									],
									[
										193310,
										193314
									],
									[
										193458,
										193462
									],
									[
										193478,
										193482
									],
									[
										193583,
										193587
									],
									[
										193719,
										193723
									],
									[
										193872,
										193876
									],
									[
										194035,
										194039
									],
									[
										194194,
										194198
									],
									[
										194367,
										194371
									],
									[
										194492,
										194496
									],
									[
										194706,
										194710
									],
									[
										194887,
										194891
									],
									[
										195084,
										195088
									],
									[
										195236,
										195240
									],
									[
										195328,
										195332
									],
									[
										195373,
										195377
									],
									[
										195402,
										195406
									],
									[
										195586,
										195590
									],
									[
										195816,
										195820
									],
									[
										195964,
										195968
									],
									[
										196150,
										196154
									],
									[
										196178,
										196182
									],
									[
										196307,
										196311
									],
									[
										196473,
										196477
									],
									[
										196684,
										196688
									],
									[
										196815,
										196819
									],
									[
										197012,
										197016
									],
									[
										197104,
										197108
									],
									[
										197360,
										197364
									],
									[
										197587,
										197591
									],
									[
										197880,
										197884
									],
									[
										198120,
										198124
									],
									[
										198223,
										198227
									],
									[
										198474,
										198478
									],
									[
										198620,
										198624
									],
									[
										198870,
										198874
									],
									[
										199092,
										199096
									],
									[
										199304,
										199308
									],
									[
										199630,
										199635
									],
									[
										199736,
										199741
									],
									[
										200060,
										200065
									],
									[
										200176,
										200181
									],
									[
										200415,
										200420
									],
									[
										200643,
										200648
									],
									[
										200699,
										200704
									],
									[
										200958,
										200963
									],
									[
										201096,
										201101
									],
									[
										201105,
										201110
									],
									[
										201114,
										201119
									],
									[
										201269,
										201274
									],
									[
										201278,
										201283
									],
									[
										201287,
										201292
									],
									[
										201475,
										201480
									],
									[
										201486,
										201491
									],
									[
										201634,
										201639
									],
									[
										201643,
										201648
									],
									[
										201652,
										201657
									],
									[
										201763,
										201768
									],
									[
										201772,
										201777
									],
									[
										201781,
										201786
									],
									[
										201839,
										201844
									],
									[
										202068,
										202073
									],
									[
										202107,
										202112
									],
									[
										202175,
										202180
									],
									[
										202206,
										202211
									],
									[
										202214,
										202219
									],
									[
										202339,
										202344
									],
									[
										202459,
										202464
									],
									[
										202467,
										202472
									],
									[
										202581,
										202586
									],
									[
										202589,
										202594
									],
									[
										202757,
										202762
									],
									[
										203510,
										203515
									],
									[
										203584,
										203589
									],
									[
										203688,
										203693
									],
									[
										204512,
										204517
									],
									[
										204525,
										204530
									],
									[
										204689,
										204694
									],
									[
										204884,
										204889
									],
									[
										204917,
										204922
									],
									[
										205167,
										205172
									],
									[
										205184,
										205189
									],
									[
										205339,
										205344
									],
									[
										205476,
										205481
									],
									[
										205489,
										205494
									],
									[
										205532,
										205537
									],
									[
										205723,
										205728
									],
									[
										205918,
										205923
									],
									[
										206121,
										206126
									],
									[
										206194,
										206199
									],
									[
										206375,
										206380
									],
									[
										206481,
										206486
									],
									[
										206805,
										206810
									],
									[
										206921,
										206926
									],
									[
										207160,
										207165
									],
									[
										207388,
										207393
									],
									[
										207444,
										207449
									],
									[
										207703,
										207708
									],
									[
										207841,
										207846
									],
									[
										207850,
										207855
									],
									[
										207859,
										207864
									],
									[
										208014,
										208019
									],
									[
										208023,
										208028
									],
									[
										208032,
										208037
									],
									[
										208220,
										208225
									],
									[
										208231,
										208236
									],
									[
										208379,
										208384
									],
									[
										208388,
										208393
									],
									[
										208397,
										208402
									],
									[
										208508,
										208513
									],
									[
										208517,
										208522
									],
									[
										208526,
										208531
									],
									[
										208584,
										208589
									],
									[
										208813,
										208818
									],
									[
										208852,
										208857
									],
									[
										208920,
										208925
									],
									[
										208951,
										208956
									],
									[
										208959,
										208964
									],
									[
										209084,
										209089
									],
									[
										209204,
										209209
									],
									[
										209212,
										209217
									],
									[
										209326,
										209331
									],
									[
										209334,
										209339
									],
									[
										209523,
										209528
									],
									[
										209702,
										209707
									],
									[
										210011,
										210016
									],
									[
										210202,
										210207
									],
									[
										210222,
										210227
									],
									[
										210327,
										210332
									],
									[
										210480,
										210485
									],
									[
										210643,
										210648
									],
									[
										210802,
										210807
									],
									[
										210970,
										210975
									],
									[
										211138,
										211143
									],
									[
										211467,
										211473
									],
									[
										211670,
										211676
									],
									[
										211743,
										211749
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								211673,
								211673
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 3,
							"result_base_dir": "",
							"result_file_regex": "^([^ \t].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 117018.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "/home/roman/Sources/c-utils/genmakefile.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 144523,
						"regions":
						{
						},
						"selection":
						[
							[
								45477,
								45477
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 34752.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 64607,
						"regions":
						{
						},
						"selection":
						[
							[
								1187,
								1187
							]
						],
						"settings":
						{
							"syntax": "Packages/CMakeEditor/CMakeEditor.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 66.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "response.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3254,
						"regions":
						{
						},
						"selection":
						[
							[
								625,
								625
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "response.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1113,
						"regions":
						{
						},
						"selection":
						[
							[
								328,
								328
							]
						],
						"settings":
						{
							"syntax": "Packages/C11/C11.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "lib/io/io_dump.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 623,
						"regions":
						{
						},
						"selection":
						[
							[
								267,
								267
							]
						],
						"settings":
						{
							"syntax": "Packages/C Improved/C Improved.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 27.0
	},
	"input":
	{
		"height": 49.0
	},
	"layout":
	{
		"cells":
		[
			[
				2,
				0,
				3,
				2
			],
			[
				0,
				0,
				2,
				2
			]
		],
		"cols":
		[
			0.0,
			0.2,
			0.750261799928,
			1.0
		],
		"rows":
		[
			0.0,
			0.5,
			1.0
		]
	},
	"menu_visible": true,
	"output.doc":
	{
		"height": 0.0
	},
	"output.exec":
	{
		"height": 138.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "c-utils.sublime-project",
	"replace":
	{
		"height": 71.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"lib/io/io_wantread.c"
			],
			[
				"path.h",
				"lib/path.h"
			],
			[
				"genmake",
				"genmakefile.c"
			],
			[
				"genma",
				"genmakefile.c"
			],
			[
				"response.h",
				"response.h"
			],
			[
				"response",
				"response.c"
			],
			[
				"cmake",
				"CMakeLists.txt"
			],
			[
				"io_dump",
				"lib/io/io_dump.c"
			],
			[
				"logser",
				"logserial.c"
			],
			[
				"cmakelists",
				"CMakeLists.txt"
			],
			[
				"io_waitun",
				"lib/io/io_waituntil2.c"
			],
			[
				"io_wantread",
				"lib/io/io_wantread.c"
			],
			[
				"io_du",
				"lib/io/io_dump.c"
			],
			[
				"io_in",
				"lib/io_internal.h"
			],
			[
				"io.h",
				"lib/io.h"
			],
			[
				"io_wantwr",
				"lib/io/io_wantwrite.c"
			],
			[
				"cmakeli",
				"CMakeLists.txt"
			],
			[
				"io_waituntil2",
				"lib/io/io_waituntil2.c"
			],
			[
				"io_non",
				"lib/io/io_nonblock.c"
			],
			[
				"buffer_get",
				"lib/buffer/buffer_get.c"
			],
			[
				"buffer_putc",
				"lib/buffer/buffer_putc.c"
			],
			[
				"buffer.h",
				"lib/buffer.h"
			],
			[
				"logserial",
				"logserial.c"
			],
			[
				"coff_li",
				"lib/coff/coff_line_numbers.c"
			],
			[
				"cofflist",
				"cofflist.c"
			],
			[
				"io_inter",
				"lib/io_internal.h"
			],
			[
				"process_crea",
				"lib/process/process_create.c"
			],
			[
				"cfg.sh",
				"cfg.sh"
			],
			[
				"cmakelis",
				"CMakeLists.txt"
			],
			[
				"getifname",
				"lib/socket/socket_getifname.c"
			],
			[
				"socket_getif",
				"lib/socket/socket_getifidx.c"
			],
			[
				"socket_",
				"lib/socket/socket_getifidx.c"
			],
			[
				"ifidx.",
				"lib/socket/socket_getifidx.c"
			],
			[
				"omf.h",
				"lib/omf.h"
			],
			[
				"omflist",
				"omflist.c"
			],
			[
				" io_waituntil2 ",
				"lib/io/io_waituntil2.c"
			],
			[
				"cmakelist",
				"CMakeLists.txt"
			],
			[
				"tinyproxy",
				"tinyproxy.c"
			],
			[
				"tinyp",
				"tinyproxy.c"
			],
			[
				"tinypox",
				"tinyproxy.c"
			],
			[
				"pkgcfg.c",
				"pkgcfg.c"
			],
			[
				"ar-wr",
				"ar-wrap.c"
			],
			[
				"wait.h",
				"lib/wait.h"
			],
			[
				"process.h",
				"lib/process.h"
			],
			[
				"ar-wrap",
				"ar-wrap.c"
			],
			[
				"inypro",
				"tinyproxy.c"
			],
			[
				"wait_pid",
				"lib/wait/wait_pid.c"
			],
			[
				"glob.c",
				"lib/unix/glob.c"
			],
			[
				"dir_inter",
				"lib/dir_internal.h"
			],
			[
				"dir_time.c",
				"lib/dir/dir_time.c"
			],
			[
				"dir_in",
				"lib/dir_internal.h"
			],
			[
				"dir_type",
				"lib/dir/dir_type.c"
			],
			[
				"dir_open",
				"lib/dir/dir_open.c"
			],
			[
				"config.h",
				"build/cmake/config.h.cmake"
			],
			[
				"typedef",
				"lib/typedefs.h"
			],
			[
				"stralloc.h",
				"lib/stralloc.h"
			],
			[
				"stralloc_repl",
				"lib/stralloc/stralloc_replace.c"
			],
			[
				"apth.h",
				"3rdparty/openssl/external/perl/Text-Template-1.46/t/02-hash.t"
			],
			[
				"str.h",
				"lib/str.h"
			],
			[
				"strarray.h",
				"lib/strarray.h"
			],
			[
				"set.h",
				"lib/set.h"
			],
			[
				"str_diff",
				"lib/str/str_diff.c"
			],
			[
				"byte.h",
				"lib/byte.h"
			],
			[
				"genmakefile.h",
				"genmakefile.h"
			],
			[
				"path_ex",
				"lib/path/path_exists.c"
			],
			[
				"sig.h",
				"lib/sig.h"
			],
			[
				"str_strat",
				"lib/str/str_start.c"
			],
			[
				"xml.h",
				"lib/xml.h"
			],
			[
				"mediathek-list",
				"mediathek-list.c"
			],
			[
				"quotedshell",
				"lib/fmt/fmt_escapecharquotedshell.c"
			],
			[
				"str_find",
				"lib/str/str_find.c"
			],
			[
				"str_dup",
				"lib/str/str_dup.c"
			],
			[
				"pipeinf",
				"pipeinfo.c"
			],
			[
				"puts_esca",
				"lib/stralloc/buffer_puts_escaped.c"
			],
			[
				"fmt.h",
				"lib/fmt.h"
			],
			[
				"utf8_latin",
				"lib/ucs/str_utf8_latin.c"
			],
			[
				"mediathek-par",
				"mediathek-parser.c"
			],
			[
				"http.h",
				"lib/http.h"
			],
			[
				"buffer_puts",
				"lib/buffer/buffer_puts.c"
			],
			[
				"io_wait",
				"lib/io/io_waituntil2.c"
			],
			[
				"errmsg_puts",
				"lib/errmsg/errmsg_puts.c"
			],
			[
				"io_internal",
				"lib/io_internal.h"
			],
			[
				"mediathek",
				"mediathek-list.c"
			],
			[
				"httptest",
				"httptest.c"
			],
			[
				"winsock2err",
				"lib/socket/winsock2errno.c"
			],
			[
				"socket_tc",
				"lib/socket/socket_tcp4.c"
			],
			[
				"errmsg_write",
				"lib/errmsg/errmsg_write.c"
			],
			[
				"errmsg_warn",
				"lib/errmsg/errmsg_warnsys.c"
			],
			[
				"taia_sub",
				"lib/taia/taia_sub.c"
			],
			[
				"taia.h",
				"lib/taia.h"
			],
			[
				"waituntil",
				"lib/io/io_waituntil.c"
			],
			[
				"waitunt",
				"lib/io/io_waituntil2.c"
			],
			[
				"mediathek-list.c",
				"mediathek-list.c"
			],
			[
				"ndelay_on",
				"lib/ndelay/ndelay_on.c"
			],
			[
				"socket.h",
				"lib/socket.h"
			],
			[
				"io_close",
				"lib/io/io_close.c"
			],
			[
				"pe.h",
				"lib/pe.h"
			],
			[
				"impgen",
				"impgen.c"
			],
			[
				"pelist",
				"pelist.c"
			],
			[
				"scan.h",
				"lib/scan.h"
			],
			[
				"pelist.c",
				"pelist.c"
			],
			[
				"parse.c",
				"parse.c"
			],
			[
				"mediathek-parser",
				"mediathek-parser.c"
			],
			[
				"plsconv",
				"plsconv.c"
			],
			[
				"ntldd",
				"ntldd.c"
			],
			[
				"ready",
				"lib/stralloc/stralloc_ready.c"
			],
			[
				"genmak",
				"genmakefile.h"
			],
			[
				"umul",
				"lib/safemult/umult16.c"
			],
			[
				"umult",
				"lib/safemult/umult64.c"
			],
			[
				"et.h",
				"lib/set.h"
			],
			[
				"get-pro",
				"scripts/get-prototypes.sh"
			],
			[
				"str_ndup",
				"lib/str/str_ndup.c"
			],
			[
				"set_find",
				"lib/set/set_find.c"
			],
			[
				"genm",
				"genmakefile.c"
			],
			[
				"path_abs",
				"lib/path/path_absolute.c"
			],
			[
				"636",
				"build/x86_64-linux-gnu/try-33vNky.c"
			],
			[
				"strlist.h",
				"lib/strlist.h"
			],
			[
				"strlist_push",
				"lib/strlist/strlist_push_unique_sa.c"
			],
			[
				"replacec",
				"lib/stralloc/stralloc_replacec.c"
			],
			[
				"stralloc_replace",
				"lib/stralloc/stralloc_replace.c"
			],
			[
				"str_end",
				"lib/str/str_end.c"
			],
			[
				"unix.h",
				"lib/unix.h"
			],
			[
				"path_is",
				"lib/path/path_is_absolute.c"
			],
			[
				"absolute_sa",
				"lib/path/path_absolute_sa.c"
			],
			[
				"query.h",
				"query.h"
			],
			[
				"names.c",
				"names.c"
			],
			[
				"names.h",
				"names.h"
			],
			[
				"dns.h",
				"lib/dns.h"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 1,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 306.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
